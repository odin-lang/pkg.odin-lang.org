<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>package mem - pkg.odin-lang.org</title>	<link rel="icon" href="/favicon.svg">
	<link rel="stylesheet" type="text/css" href="https://odin-lang.org/scss/custom.min.css">
	<link rel=stylesheet href="//odin-lang.org/lib/highlight/styles/github-dark.min.css">
	<script src="//odin-lang.org/lib/highlight/highlight.min.js"></script>

	<script>hljs.registerLanguage("odin",function(a){return{aliases:["odin","odinlang","odin-lang"],keywords:{keyword:"auto_cast bit_set break case cast context continue defer distinct do dynamic else enum fallthrough for foreign if import in map not_in or_else or_return package proc return struct switch transmute type_of typeid union using when where",literal:"true false nil",built_in:"abs align_of cap clamp complex conj expand_to_tuple imag jmag kmag len max min offset_of quaternion real size_of soa_unzip soa_zip swizzle type_info_of type_of typeid_of"},illegal:"</",contains:[a.C_LINE_COMMENT_MODE,a.C_BLOCK_COMMENT_MODE,{className:"string",variants:[a.QUOTE_STRING_MODE,{begin:"'",end:"[^\\\\]'"},{begin:"`",end:"`"}]},{className:"number",variants:[{begin:a.C_NUMBER_RE+"[ijk]",relevance:1},a.C_NUMBER_MODE]}]}})</script>
	<script>hljs.highlightAll()</script>
	<script>
		function OSDarkModeQuery() {
			return window.matchMedia?.("(prefers-color-scheme: dark)");
		}
		function setDarkMode() {
			document.body.classList.add("dark-mode");
			window.localStorage.setItem("theme", "dark");
		}
		function removeDarkMode() {
			document.body.classList.remove("dark-mode");
			window.localStorage.setItem("theme", "light");
		}
		function toggleDarkMode() {
			if (document.body.classList.contains("dark-mode")) removeDarkMode()
			else setDarkMode()
		}
		function syncThemeToOS() {
			if (OSDarkModeQuery().matches) setDarkMode()
			else removeDarkMode()
		}
		document.addEventListener("DOMContentLoaded", () => {
			OSDarkModeQuery().addEventListener("change", syncThemeToOS);
		});
	</script>
	<link rel="stylesheet" type="text/css" href="https://odin-lang.org/css/style.css">

	<link rel="stylesheet" type="text/css" href="/style.css">

	</style>
</head>
<body>
<script>
	const themeSet = window.localStorage.getItem("theme");
	if (themeSet === null) {
		syncThemeToOS();
	} else if (themeSet === "dark") {
		setDarkMode();
	} else if (themeSet === "light") {
		removeDarkMode();
	}
</script>
<header class="sticky-top">
	<nav class="navbar navbar-expand-lg navbar-dark bg-primary odin-menu">
		<div class="container">
			<a class="navbar-brand" href="https://odin-lang.org/">
			<img src="https://odin-lang.org/logo.svg" height="30" alt="Odin"></a>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#odin-navbar-content" aria-controls="odin-navbar-content" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
			<div class="collapse navbar-collapse" id="odin-navbar-content">
			<ul class="navbar-nav ms-md-auto">
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/">Home</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/docs">Docs</a></li>
				<li class="nav-item"><a class="nav-link active" href="/">Packages</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/news">News</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/showcase">Showcase</a></li>
				<li class="nav-item"><a class="nav-link" href="https://forum.odin-lang.org">Forum</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/community">Community</a></li>
				<li class="nav-item"><a class="nav-link" href="https://github.com/odin-lang/Odin" target="_blank">GitHub</a></li>
				<li class="nav-item">
					<a
						class="nav-link btn-dark-mode"
						onclick="toggleDarkMode();"
						title="Toggle Light/Dark Mode"
					>
						<span class="dark-mode-appearance">Appearance:</span>
						<svg fill="white" id="dark-mode-icon" viewBox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"/></svg>
						<svg fill="white" id="light-mode-icon" viewBox="0 0 16 16">
						  <path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8M8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0m0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13m8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5M3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8m10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0m-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0m9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707M4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708"/>
						</svg>
					</button>
					</a>
				</li>
			</ul>
		</div>
		</div>
	</nav>
</header>
<main>
<div class="container full-width">
<div class="row odin-main my-4" id="pkg">
<nav id="pkg-sidebar" class="col-lg-2 odin-sidebar-border navbar-light sticky-top odin-below-navbar">
<div class="py-3">
<h4><a style="text-transform: capitalize; color: inherit;" href="/core">core Library</a></h4>
<ul>
<li class="nav-item"><a href="/core/bufio">bufio</a></li>
<li class="nav-item"><a href="/core/bytes">bytes</a></li>
<li class="nav-item"><a href="/core/c">c</a><ul>
<li><a href="/core/c/libc">libc</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/compress">compress</a><ul>
<li><a href="/core/compress/gzip">gzip</a></li>
<li><a href="/core/compress/shoco">shoco</a></li>
<li><a href="/core/compress/zlib">zlib</a></li>
</ul>

</li>
<li class="nav-item">container<ul>
<li><a href="/core/container/avl">avl</a></li>
<li><a href="/core/container/bit_array">bit_array</a></li>
<li><a href="/core/container/intrusive/list">intrusive/list</a></li>
<li><a href="/core/container/lru">lru</a></li>
<li><a href="/core/container/priority_queue">priority_queue</a></li>
<li><a href="/core/container/queue">queue</a></li>
<li><a href="/core/container/rbtree">rbtree</a></li>
<li><a href="/core/container/small_array">small_array</a></li>
<li><a href="/core/container/topological_sort">topological_sort</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/crypto">crypto</a><ul>
<li><a href="/core/crypto/aead">aead</a></li>
<li><a href="/core/crypto/aegis">aegis</a></li>
<li><a href="/core/crypto/aes">aes</a></li>
<li><a href="/core/crypto/blake2b">blake2b</a></li>
<li><a href="/core/crypto/blake2s">blake2s</a></li>
<li><a href="/core/crypto/chacha20">chacha20</a></li>
<li><a href="/core/crypto/chacha20poly1305">chacha20poly1305</a></li>
<li><a href="/core/crypto/deoxysii">deoxysii</a></li>
<li><a href="/core/crypto/ed25519">ed25519</a></li>
<li><a href="/core/crypto/hash">hash</a></li>
<li><a href="/core/crypto/hkdf">hkdf</a></li>
<li><a href="/core/crypto/hmac">hmac</a></li>
<li><a href="/core/crypto/kmac">kmac</a></li>
<li><a href="/core/crypto/legacy/keccak">legacy/keccak</a></li>
<li><a href="/core/crypto/legacy/md5">legacy/md5</a></li>
<li><a href="/core/crypto/legacy/sha1">legacy/sha1</a></li>
<li><a href="/core/crypto/pbkdf2">pbkdf2</a></li>
<li><a href="/core/crypto/poly1305">poly1305</a></li>
<li><a href="/core/crypto/ristretto255">ristretto255</a></li>
<li><a href="/core/crypto/sha2">sha2</a></li>
<li><a href="/core/crypto/sha3">sha3</a></li>
<li><a href="/core/crypto/shake">shake</a></li>
<li><a href="/core/crypto/sm3">sm3</a></li>
<li><a href="/core/crypto/tuplehash">tuplehash</a></li>
<li><a href="/core/crypto/x25519">x25519</a></li>
<li><a href="/core/crypto/x448">x448</a></li>
</ul>

</li>
<li class="nav-item">debug<ul>
<li><a href="/core/debug/pe">pe</a></li>
<li><a href="/core/debug/trace">trace</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/dynlib">dynlib</a></li>
<li class="nav-item">encoding<ul>
<li><a href="/core/encoding/base32">base32</a></li>
<li><a href="/core/encoding/base64">base64</a></li>
<li><a href="/core/encoding/cbor">cbor</a></li>
<li><a href="/core/encoding/csv">csv</a></li>
<li><a href="/core/encoding/endian">endian</a></li>
<li><a href="/core/encoding/entity">entity</a></li>
<li><a href="/core/encoding/hex">hex</a></li>
<li><a href="/core/encoding/hxa">hxa</a></li>
<li><a href="/core/encoding/ini">ini</a></li>
<li><a href="/core/encoding/json">json</a></li>
<li><a href="/core/encoding/uuid">uuid</a></li>
<li><a href="/core/encoding/uuid/legacy">uuid/legacy</a></li>
<li><a href="/core/encoding/varint">varint</a></li>
<li><a href="/core/encoding/xml">xml</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/flags">flags</a></li>
<li class="nav-item"><a href="/core/fmt">fmt</a></li>
<li class="nav-item"><a href="/core/hash">hash</a><ul>
<li><a href="/core/hash/xxhash">xxhash</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/image">image</a><ul>
<li><a href="/core/image/bmp">bmp</a></li>
<li><a href="/core/image/jpeg">jpeg</a></li>
<li><a href="/core/image/netpbm">netpbm</a></li>
<li><a href="/core/image/png">png</a></li>
<li><a href="/core/image/qoi">qoi</a></li>
<li><a href="/core/image/tga">tga</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/io">io</a></li>
<li class="nav-item"><a href="/core/log">log</a></li>
<li class="nav-item"><a href="/core/math">math</a><ul>
<li><a href="/core/math/big">big</a></li>
<li><a href="/core/math/bits">bits</a></li>
<li><a href="/core/math/cmplx">cmplx</a></li>
<li><a href="/core/math/ease">ease</a></li>
<li><a href="/core/math/fixed">fixed</a></li>
<li><a href="/core/math/linalg">linalg</a></li>
<li><a href="/core/math/linalg/glsl">linalg/glsl</a></li>
<li><a href="/core/math/linalg/hlsl">linalg/hlsl</a></li>
<li><a href="/core/math/noise">noise</a></li>
<li><a href="/core/math/rand">rand</a></li>
</ul>

</li>
<li class="nav-item"><a class="active" href="/core/mem">mem</a><ul>
<li><a href="/core/mem/tlsf">tlsf</a></li>
<li><a href="/core/mem/virtual">virtual</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/net">net</a></li>
<li class="nav-item">odin<ul>
<li><a href="/core/odin/ast">ast</a></li>
<li><a href="/core/odin/doc-format">doc-format</a></li>
<li><a href="/core/odin/parser">parser</a></li>
<li><a href="/core/odin/tokenizer">tokenizer</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/os">os</a></li>
<li class="nav-item">path<ul>
<li><a href="/core/path/filepath">filepath</a></li>
<li><a href="/core/path/slashpath">slashpath</a></li>
</ul>

</li>
<li class="nav-item">prof<ul>
<li><a href="/core/prof/spall">spall</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/reflect">reflect</a></li>
<li class="nav-item"><a href="/core/relative">relative</a></li>
<li class="nav-item"><a href="/core/simd">simd</a><ul>
<li><a href="/core/simd/x86">x86</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/slice">slice</a><ul>
<li><a href="/core/slice/heap">heap</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/sort">sort</a></li>
<li class="nav-item"><a href="/core/strconv">strconv</a><ul>
<li><a href="/core/strconv/decimal">decimal</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/strings">strings</a></li>
<li class="nav-item"><a href="/core/sync">sync</a><ul>
<li><a href="/core/sync/chan">chan</a></li>
</ul>

</li>
<li class="nav-item">sys<ul>
<li><a href="/core/sys/darwin">darwin</a></li>
<li><a href="/core/sys/darwin/CoreFoundation">darwin/CoreFoundation</a></li>
<li><a href="/core/sys/darwin/Foundation">darwin/Foundation</a></li>
<li><a href="/core/sys/darwin/Security">darwin/Security</a></li>
<li><a href="/core/sys/freebsd">freebsd</a></li>
<li><a href="/core/sys/haiku">haiku</a></li>
<li><a href="/core/sys/info">info</a></li>
<li><a href="/core/sys/kqueue">kqueue</a></li>
<li><a href="/core/sys/linux">linux</a></li>
<li><a href="/core/sys/orca">orca</a></li>
<li><a href="/core/sys/posix">posix</a></li>
<li><a href="/core/sys/unix">unix</a></li>
<li><a href="/core/sys/valgrind">valgrind</a></li>
<li><a href="/core/sys/windows">windows</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/terminal">terminal</a><ul>
<li><a href="/core/terminal/ansi">ansi</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/testing">testing</a></li>
<li class="nav-item">text<ul>
<li><a href="/core/text/edit">edit</a></li>
<li><a href="/core/text/i18n">i18n</a></li>
<li><a href="/core/text/match">match</a></li>
<li><a href="/core/text/regex">regex</a></li>
<li><a href="/core/text/regex/common">regex/common</a></li>
<li><a href="/core/text/regex/compiler">regex/compiler</a></li>
<li><a href="/core/text/regex/optimizer">regex/optimizer</a></li>
<li><a href="/core/text/regex/parser">regex/parser</a></li>
<li><a href="/core/text/regex/tokenizer">regex/tokenizer</a></li>
<li><a href="/core/text/regex/virtual_machine">regex/virtual_machine</a></li>
<li><a href="/core/text/scanner">scanner</a></li>
<li><a href="/core/text/table">table</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/thread">thread</a></li>
<li class="nav-item"><a href="/core/time">time</a><ul>
<li><a href="/core/time/datetime">datetime</a></li>
<li><a href="/core/time/timezone">timezone</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/unicode">unicode</a><ul>
<li><a href="/core/unicode/utf16">utf16</a></li>
<li><a href="/core/unicode/utf8">utf8</a></li>
<li><a href="/core/unicode/utf8/utf8string">utf8/utf8string</a></li>
</ul>

</li>
</ul>
</div>
</nav>
<article class="col-lg-8 p-4 documentation odin-article">
<nav class="pkg-breadcrumb" aria-label="breadcrumb">
<ol class="breadcrumb">
<li class="breadcrumb-item"><a href="/core">core</a></li>
<li class="breadcrumb-item active" aria-current="page"><a href="/core/mem">mem</a></li>
</ol>
</nav>
<h1>package core:mem<div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem"><em>Source</em></a></div></h1>

		<div class="odin-search-wrapper">
			<input type="search" id="odin-search" class="odin-search-package" autocomplete="off" spellcheck="false" placeholder="Fuzzy Search...">
			<div class="odin-search-shortcut">
				<div class="odin-search-key key-macos">⌘K</div>
				<div class="odin-search-key key-windows">Ctrl+K</div>
				<span class="odin-search-or">or</span>
				<div class="odin-search-key">/</div>
			</div>
		</div>
	
<div id="odin-search-info">
<div id="odin-search-time"></div>

		<div id="odin-search-options">
			<input type="checkbox" id="odin-search-filter" name="odin-search-filter">
			<label for="odin-search-filter">Filter Results</label>
		</div>
</div>
<ul id="odin-search-results"></ul>
<div id="pkg-top">
<h2>Overview</h2>
<div id="pkg-overview">
<p>Various allocators and provides helpers for dealing with memory, pointers and slices.</p>
<p>The documentation below describes basic concepts, applicable to the <code>mem</code>
package.</p>
<p></p>
<h4> Pointers, multipointers, and slices</h4><p></p>
<p>A <i>pointer</i> is an abstraction of an <i>address</i>, a numberic value representing the
location of an object in memory. That object is said to be <i>pointed to</i> by the
pointer. To obtain the address of a pointer, cast it to <code>uintptr</code>.</p>
<p>A multipointer is a pointer that points to multiple objects. Unlike a pointer,
a multipointer can be indexed, but does not have a definite length. A slice is
a pointer that points to multiple objects equipped with the length, specifying
the amount of objects a slice points to.</p>
<p>When an object's values are read through a pointer, that operation is called a
<i>load</i> operation. When memory is written to through a pointer, that operation is
called a <i>store</i> operation. Both of these operations can be called a *memory
access operation*.</p>
<p></p>
<h4> Allocators</h4><p></p>
<p>In C and C++ memory models, allocations of objects in memory are typically
treated individually with a generic allocator (The <code>malloc</code> procedure). Which in
some scenarios can lead to poor cache utilization, slowdowns on individual
objects' memory management and growing complexity of the code needing to keep
track of the pointers and their lifetimes.</p>
<p>Using different kinds of <i>allocators</i> for different purposes can solve these
problems. The allocators are typically optimized for specific use-cases and
can potentially simplify the memory management code.</p>
<p>For example, in the context of making a game, having an Arena allocator could
simplify allocations of any temporary memory, because the programmer doesn't
have to keep track of which objects need to be freed every time they are
allocated, because at the end of every frame the whole allocator is reset to
its initial state and all objects are freed at once.</p>
<p>The allocators have different kinds of restrictions on object lifetimes, sizes,
alignment and can be a significant gain, if used properly. Odin supports
allocators on a language level.</p>
<p>Operations such as <code>new</code>, <code>free</code> and <code>delete</code> by default will use
<code>context.allocator</code>, which can be overridden by the user. When an override
happens all called procedures will inherit the new context and use the same
allocator.</p>
<p>We will define one concept to simplify the description of some allocator-related
procedures, which is ownership. If the memory was allocated via a specific
allocator, that allocator is said to be the <i>owner</i> of that memory region. To
note, unlike Rust, in Odin the memory ownership model is not strict.</p>
<p></p>
<h4> Alignment</h4><p></p>
<p>An address is said to be <i>aligned to `N` bytes</i>, if the addresses's numeric
value is divisible by <code>N</code>. The number <code>N</code> in this case can be referred to as
the <i>alignment boundary</i>. Typically an alignment is a power of two integer
value.</p>
<p>A <i>natural alignment</i> of an object is typically equal to its size. For example
a 16 bit integer has a natural alignment of 2 bytes. When an object is not
located on its natural alignment boundary, accesses to that object are
considered <i>unaligned</i>.</p>
<p>Some machines issue a hardware <b>exception</b>, or experience <b>slowdowns</b> when a
memory access operation occurs from an unaligned address. Examples of such
operations are:</p>
<p><span class="doc-list">SIMD instructions on x86. These instructions require all memory accesses to be</span>
  on an address that is aligned to 16 bytes.
<span class="doc-list">On ARM unaligned loads have an extra cycle penalty.</span></p>
<p>As such, many operations that allocate memory in this package allow to
explicitly specify the alignment of allocated pointers/slices. The default
alignment for all operations is specified in a constant <code>mem.DEFAULT_ALIGNMENT</code>.</p>
<p></p>
<h4> Zero by default</h4><p></p>
<p>Whenever new memory is allocated, via an allocator, or on the stack, by default
Odin will zero-initialize that memory, even if it wasn't explicitly
initialized. This allows for some convenience in certain scenarios and ease of
debugging, which will not be described in detail here.</p>
<p>However zero-initialization can be a cause of slowdowns, when allocating large
buffers. For this reason, allocators have <code>*_non_zeroed</code> modes of allocation
that allow the user to request for uninitialized memory and will avoid a
relatively expensive zero-filling of the buffer.</p>
<p></p>
<h4> Naming conventions</h4><p></p>
<p>The word <code>size</code> is used to denote the <b>size in bytes</b>. The word <code>length</code> is
used to denote the count of objects.</p>
<p>The allocation procedures use the following conventions:</p>
<p><span class="doc-list">If the name contains <code>alloc_bytes</code> or <code>resize_bytes</code>, then the procedure takes</span>
  in slice parameters and returns slices.
<span class="doc-list">If the procedure name contains <code>alloc</code> or <code>resize</code>, then the procedure takes</span>
  in a raw pointer and returns raw pointers.
<span class="doc-list">If the procedure name contains <code>free_bytes</code>, then the procedure takes in a</span>
  slice.
<span class="doc-list">If the procedure name contains <code>free</code>, then the procedure takes in a pointer.</span></p>
<p>Higher-level allocation procedures follow the following naming scheme:</p>
<p><span class="doc-list"><code>new</code>: Allocates a single object</span>
<span class="doc-list"><code>free</code>: Free a single object (opposite of <code>new</code>)</span>
<span class="doc-list"><code>make</code>: Allocate a group of objects</span>
<span class="doc-list"><code>delete</code>: Free a group of objects (opposite of <code>make</code>)</span></p>
</div>
<div id="pkg-index">
<h2>Index</h2>
<div>
<details class="doc-index" id="doc-index-Types" aria-labelledby="#doc-index-Types-header">
<summary id="#doc-index-Types-header">
Types (46)</summary>
<ul>
<li><a href="#Allocator">Allocator</a></li>
<li><a href="#Allocator_Error">Allocator_Error</a></li>
<li><a href="#Allocator_Mode">Allocator_Mode</a></li>
<li><a href="#Allocator_Mode_Set">Allocator_Mode_Set</a></li>
<li><a href="#Allocator_Proc">Allocator_Proc</a></li>
<li><a href="#Allocator_Query_Info">Allocator_Query_Info</a></li>
<li><a href="#Arena">Arena</a></li>
<li><a href="#Arena_Temp_Memory">Arena_Temp_Memory</a></li>
<li><a href="#Buddy_Allocator">Buddy_Allocator</a></li>
<li><a href="#Buddy_Block">Buddy_Block</a></li>
<li><a href="#Compat_Allocator">Compat_Allocator</a></li>
<li><a href="#Dynamic_Arena">Dynamic_Arena</a></li>
<li><a href="#Dynamic_Pool">Dynamic_Pool</a></li>
<li><a href="#Fixed_Byte_Buffer">Fixed_Byte_Buffer</a></li>
<li><a href="#Mutex_Allocator">Mutex_Allocator</a></li>
<li><a href="#Raw_Any">Raw_Any</a></li>
<li><a href="#Raw_Complex128">Raw_Complex128</a></li>
<li><a href="#Raw_Complex32">Raw_Complex32</a></li>
<li><a href="#Raw_Complex64">Raw_Complex64</a></li>
<li><a href="#Raw_Cstring">Raw_Cstring</a></li>
<li><a href="#Raw_Cstring16">Raw_Cstring16</a></li>
<li><a href="#Raw_Dynamic_Array">Raw_Dynamic_Array</a></li>
<li><a href="#Raw_Map">Raw_Map</a></li>
<li><a href="#Raw_Quaternion128">Raw_Quaternion128</a></li>
<li><a href="#Raw_Quaternion128_Vector_Scalar">Raw_Quaternion128_Vector_Scalar</a></li>
<li><a href="#Raw_Quaternion256">Raw_Quaternion256</a></li>
<li><a href="#Raw_Quaternion256_Vector_Scalar">Raw_Quaternion256_Vector_Scalar</a></li>
<li><a href="#Raw_Quaternion64">Raw_Quaternion64</a></li>
<li><a href="#Raw_Quaternion64_Vector_Scalar">Raw_Quaternion64_Vector_Scalar</a></li>
<li><a href="#Raw_Slice">Raw_Slice</a></li>
<li><a href="#Raw_Soa_Pointer">Raw_Soa_Pointer</a></li>
<li><a href="#Raw_String">Raw_String</a></li>
<li><a href="#Raw_String16">Raw_String16</a></li>
<li><a href="#Rollback_Stack">Rollback_Stack</a></li>
<li><a href="#Rollback_Stack_Block">Rollback_Stack_Block</a></li>
<li><a href="#Rollback_Stack_Header">Rollback_Stack_Header</a></li>
<li><a href="#Scratch">Scratch</a></li>
<li><a href="#Scratch_Allocator">Scratch_Allocator</a></li>
<li><a href="#Small_Stack">Small_Stack</a></li>
<li><a href="#Small_Stack_Allocation_Header">Small_Stack_Allocation_Header</a></li>
<li><a href="#Stack">Stack</a></li>
<li><a href="#Stack_Allocation_Header">Stack_Allocation_Header</a></li>
<li><a href="#Tracking_Allocator">Tracking_Allocator</a></li>
<li><a href="#Tracking_Allocator_Bad_Free_Callback">Tracking_Allocator_Bad_Free_Callback</a></li>
<li><a href="#Tracking_Allocator_Bad_Free_Entry">Tracking_Allocator_Bad_Free_Entry</a></li>
<li><a href="#Tracking_Allocator_Entry">Tracking_Allocator_Entry</a></li>
</ul>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Constants" aria-labelledby="#doc-index-Constants-header">
<summary id="#doc-index-Constants-header">
Constants (15)</summary>
<ul>
<li><a href="#Byte">Byte</a></li>
<li><a href="#DEFAULT_ALIGNMENT">DEFAULT_ALIGNMENT</a></li>
<li><a href="#DEFAULT_PAGE_SIZE">DEFAULT_PAGE_SIZE</a></li>
<li><a href="#DYNAMIC_ARENA_BLOCK_SIZE_DEFAULT">DYNAMIC_ARENA_BLOCK_SIZE_DEFAULT</a></li>
<li><a href="#DYNAMIC_ARENA_OUT_OF_BAND_SIZE_DEFAULT">DYNAMIC_ARENA_OUT_OF_BAND_SIZE_DEFAULT</a></li>
<li><a href="#DYNAMIC_POOL_BLOCK_SIZE_DEFAULT">DYNAMIC_POOL_BLOCK_SIZE_DEFAULT</a></li>
<li><a href="#DYNAMIC_POOL_OUT_OF_BAND_SIZE_DEFAULT">DYNAMIC_POOL_OUT_OF_BAND_SIZE_DEFAULT</a></li>
<li><a href="#Exabyte">Exabyte</a></li>
<li><a href="#Gigabyte">Gigabyte</a></li>
<li><a href="#Kilobyte">Kilobyte</a></li>
<li><a href="#Megabyte">Megabyte</a></li>
<li><a href="#Petabyte">Petabyte</a></li>
<li><a href="#ROLLBACK_STACK_DEFAULT_BLOCK_SIZE">ROLLBACK_STACK_DEFAULT_BLOCK_SIZE</a></li>
<li><a href="#ROLLBACK_STACK_MAX_HEAD_BLOCK_SIZE">ROLLBACK_STACK_MAX_HEAD_BLOCK_SIZE</a></li>
<li><a href="#Terabyte">Terabyte</a></li>
</ul>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Variables" aria-labelledby="#doc-index-Variables-header">
<summary id="#doc-index-Variables-header">
Variables (0)</summary>
<p class="pkg-empty-section">This section is empty.</p>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Procedures" aria-labelledby="#doc-index-Procedures-header">
<summary id="#doc-index-Procedures-header">
Procedures (198)</summary>
<ul>
<li><a href="#align_backward">align_backward</a></li>
<li><a href="#align_backward_int">align_backward_int</a></li>
<li><a href="#align_backward_uint">align_backward_uint</a></li>
<li><a href="#align_backward_uintptr">align_backward_uintptr</a></li>
<li><a href="#align_formula">align_formula</a></li>
<li><a href="#align_forward">align_forward</a></li>
<li><a href="#align_forward_int">align_forward_int</a></li>
<li><a href="#align_forward_uint">align_forward_uint</a></li>
<li><a href="#align_forward_uintptr">align_forward_uintptr</a></li>
<li><a href="#alloc">alloc</a></li>
<li><a href="#alloc_bytes">alloc_bytes</a></li>
<li><a href="#alloc_bytes_non_zeroed">alloc_bytes_non_zeroed</a></li>
<li><a href="#any_to_bytes">any_to_bytes</a></li>
<li><a href="#arena_alloc">arena_alloc</a></li>
<li><a href="#arena_alloc_bytes">arena_alloc_bytes</a></li>
<li><a href="#arena_alloc_bytes_non_zeroed">arena_alloc_bytes_non_zeroed</a></li>
<li><a href="#arena_alloc_non_zeroed">arena_alloc_non_zeroed</a></li>
<li><a href="#arena_allocator">arena_allocator</a></li>
<li><a href="#arena_allocator_proc">arena_allocator_proc</a></li>
<li><a href="#arena_free_all">arena_free_all</a></li>
<li><a href="#arena_init">arena_init</a></li>
<li><a href="#begin_arena_temp_memory">begin_arena_temp_memory</a></li>
<li><a href="#buddy_allocator">buddy_allocator</a></li>
<li><a href="#buddy_allocator_alloc">buddy_allocator_alloc</a></li>
<li><a href="#buddy_allocator_alloc_bytes">buddy_allocator_alloc_bytes</a></li>
<li><a href="#buddy_allocator_alloc_bytes_non_zeroed">buddy_allocator_alloc_bytes_non_zeroed</a></li>
<li><a href="#buddy_allocator_alloc_non_zeroed">buddy_allocator_alloc_non_zeroed</a></li>
<li><a href="#buddy_allocator_free">buddy_allocator_free</a></li>
<li><a href="#buddy_allocator_free_all">buddy_allocator_free_all</a></li>
<li><a href="#buddy_allocator_init">buddy_allocator_init</a></li>
<li><a href="#buddy_allocator_proc">buddy_allocator_proc</a></li>
<li><a href="#buddy_block_coalescence">buddy_block_coalescence</a></li>
<li><a href="#buddy_block_find_best">buddy_block_find_best</a></li>
<li><a href="#buddy_block_next">buddy_block_next</a></li>
<li><a href="#buddy_block_size_required">buddy_block_size_required</a></li>
<li><a href="#buddy_block_split">buddy_block_split</a></li>
<li><a href="#buffer_from_slice">buffer_from_slice</a></li>
<li><a href="#byte_slice">byte_slice</a></li>
<li><a href="#calc_padding_with_header">calc_padding_with_header</a></li>
<li><a href="#check_zero">check_zero</a></li>
<li><a href="#check_zero_ptr">check_zero_ptr</a></li>
<li><a href="#compare">compare</a></li>
<li><a href="#compare_byte_ptrs">compare_byte_ptrs</a></li>
<li><a href="#compare_ptrs">compare_ptrs</a></li>
<li><a href="#compat_allocator">compat_allocator</a></li>
<li><a href="#compat_allocator_init">compat_allocator_init</a></li>
<li><a href="#compat_allocator_proc">compat_allocator_proc</a></li>
<li><a href="#context_from_allocator">context_from_allocator</a></li>
<li><a href="#copy">copy</a></li>
<li><a href="#copy_non_overlapping">copy_non_overlapping</a></li>
<li><a href="#default_resize_align">default_resize_align</a></li>
<li><a href="#default_resize_bytes_align">default_resize_bytes_align</a></li>
<li><a href="#default_resize_bytes_align_non_zeroed">default_resize_bytes_align_non_zeroed</a></li>
<li><a href="#delete_cstring">delete_cstring</a></li>
<li><a href="#delete_dynamic_array">delete_dynamic_array</a></li>
<li><a href="#delete_map">delete_map</a></li>
<li><a href="#delete_slice">delete_slice</a></li>
<li><a href="#delete_soa_dynamic_array">delete_soa_dynamic_array</a></li>
<li><a href="#delete_soa_slice">delete_soa_slice</a></li>
<li><a href="#delete_string">delete_string</a></li>
<li><a href="#dynamic_arena_alloc">dynamic_arena_alloc</a></li>
<li><a href="#dynamic_arena_alloc_bytes">dynamic_arena_alloc_bytes</a></li>
<li><a href="#dynamic_arena_alloc_bytes_non_zeroed">dynamic_arena_alloc_bytes_non_zeroed</a></li>
<li><a href="#dynamic_arena_alloc_non_zeroed">dynamic_arena_alloc_non_zeroed</a></li>
<li><a href="#dynamic_arena_allocator">dynamic_arena_allocator</a></li>
<li><a href="#dynamic_arena_allocator_proc">dynamic_arena_allocator_proc</a></li>
<li><a href="#dynamic_arena_destroy">dynamic_arena_destroy</a></li>
<li><a href="#dynamic_arena_free_all">dynamic_arena_free_all</a></li>
<li><a href="#dynamic_arena_init">dynamic_arena_init</a></li>
<li><a href="#dynamic_arena_reset">dynamic_arena_reset</a></li>
<li><a href="#dynamic_arena_resize">dynamic_arena_resize</a></li>
<li><a href="#dynamic_arena_resize_bytes">dynamic_arena_resize_bytes</a></li>
<li><a href="#dynamic_arena_resize_bytes_non_zeroed">dynamic_arena_resize_bytes_non_zeroed</a></li>
<li><a href="#dynamic_arena_resize_non_zeroed">dynamic_arena_resize_non_zeroed</a></li>
<li><a href="#dynamic_pool_alloc">dynamic_pool_alloc</a></li>
<li><a href="#dynamic_pool_alloc_bytes">dynamic_pool_alloc_bytes</a></li>
<li><a href="#dynamic_pool_allocator">dynamic_pool_allocator</a></li>
<li><a href="#dynamic_pool_allocator_proc">dynamic_pool_allocator_proc</a></li>
<li><a href="#dynamic_pool_destroy">dynamic_pool_destroy</a></li>
<li><a href="#dynamic_pool_free_all">dynamic_pool_free_all</a></li>
<li><a href="#dynamic_pool_init">dynamic_pool_init</a></li>
<li><a href="#dynamic_pool_reset">dynamic_pool_reset</a></li>
<li><a href="#end_arena_temp_memory">end_arena_temp_memory</a></li>
<li><a href="#free">free</a></li>
<li><a href="#free_all">free_all</a></li>
<li><a href="#free_bytes">free_bytes</a></li>
<li><a href="#free_with_size">free_with_size</a></li>
<li><a href="#is_aligned">is_aligned</a></li>
<li><a href="#is_power_of_two">is_power_of_two</a></li>
<li><a href="#make_aligned">make_aligned</a></li>
<li><a href="#make_any">make_any</a></li>
<li><a href="#make_dynamic_array">make_dynamic_array</a></li>
<li><a href="#make_dynamic_array_len">make_dynamic_array_len</a></li>
<li><a href="#make_dynamic_array_len_cap">make_dynamic_array_len_cap</a></li>
<li><a href="#make_fixed_byte_buffer">make_fixed_byte_buffer</a></li>
<li><a href="#make_map">make_map</a></li>
<li><a href="#make_map_cap">make_map_cap</a></li>
<li><a href="#make_multi_pointer">make_multi_pointer</a></li>
<li><a href="#make_over_aligned">make_over_aligned</a></li>
<li><a href="#make_slice">make_slice</a></li>
<li><a href="#make_soa_dynamic_array">make_soa_dynamic_array</a></li>
<li><a href="#make_soa_dynamic_array_len">make_soa_dynamic_array_len</a></li>
<li><a href="#make_soa_dynamic_array_len_cap">make_soa_dynamic_array_len_cap</a></li>
<li><a href="#make_soa_slice">make_soa_slice</a></li>
<li><a href="#mutex_allocator">mutex_allocator</a></li>
<li><a href="#mutex_allocator_init">mutex_allocator_init</a></li>
<li><a href="#mutex_allocator_proc">mutex_allocator_proc</a></li>
<li><a href="#new">new</a></li>
<li><a href="#new_aligned">new_aligned</a></li>
<li><a href="#new_clone">new_clone</a></li>
<li><a href="#nil_allocator">nil_allocator</a></li>
<li><a href="#nil_allocator_proc">nil_allocator_proc</a></li>
<li><a href="#panic_allocator">panic_allocator</a></li>
<li><a href="#panic_allocator_proc">panic_allocator_proc</a></li>
<li><a href="#ptr_offset">ptr_offset</a></li>
<li><a href="#ptr_sub">ptr_sub</a></li>
<li><a href="#ptr_to_bytes">ptr_to_bytes</a></li>
<li><a href="#query_features">query_features</a></li>
<li><a href="#query_info">query_info</a></li>
<li><a href="#raw_data">raw_data</a></li>
<li><a href="#rb_alloc">rb_alloc</a></li>
<li><a href="#rb_alloc_bytes">rb_alloc_bytes</a></li>
<li><a href="#rb_alloc_bytes_non_zeroed">rb_alloc_bytes_non_zeroed</a></li>
<li><a href="#rb_alloc_non_zeroed">rb_alloc_non_zeroed</a></li>
<li><a href="#rb_resize">rb_resize</a></li>
<li><a href="#rb_resize_bytes">rb_resize_bytes</a></li>
<li><a href="#rb_resize_bytes_non_zeroed">rb_resize_bytes_non_zeroed</a></li>
<li><a href="#rb_resize_non_zeroed">rb_resize_non_zeroed</a></li>
<li><a href="#reinterpret_copy">reinterpret_copy</a></li>
<li><a href="#resize">resize</a></li>
<li><a href="#resize_bytes">resize_bytes</a></li>
<li><a href="#resize_bytes_non_zeroed">resize_bytes_non_zeroed</a></li>
<li><a href="#resize_non_zeroed">resize_non_zeroed</a></li>
<li><a href="#rollback_stack_allocator">rollback_stack_allocator</a></li>
<li><a href="#rollback_stack_allocator_proc">rollback_stack_allocator_proc</a></li>
<li><a href="#rollback_stack_destroy">rollback_stack_destroy</a></li>
<li><a href="#rollback_stack_init_buffered">rollback_stack_init_buffered</a></li>
<li><a href="#rollback_stack_init_dynamic">rollback_stack_init_dynamic</a></li>
<li><a href="#scratch_alloc">scratch_alloc</a></li>
<li><a href="#scratch_alloc_bytes">scratch_alloc_bytes</a></li>
<li><a href="#scratch_alloc_bytes_non_zeroed">scratch_alloc_bytes_non_zeroed</a></li>
<li><a href="#scratch_alloc_non_zeroed">scratch_alloc_non_zeroed</a></li>
<li><a href="#scratch_allocator">scratch_allocator</a></li>
<li><a href="#scratch_allocator_destroy">scratch_allocator_destroy</a></li>
<li><a href="#scratch_allocator_init">scratch_allocator_init</a></li>
<li><a href="#scratch_allocator_proc">scratch_allocator_proc</a></li>
<li><a href="#scratch_destroy">scratch_destroy</a></li>
<li><a href="#scratch_free">scratch_free</a></li>
<li><a href="#scratch_free_all">scratch_free_all</a></li>
<li><a href="#scratch_init">scratch_init</a></li>
<li><a href="#scratch_resize">scratch_resize</a></li>
<li><a href="#scratch_resize_bytes">scratch_resize_bytes</a></li>
<li><a href="#scratch_resize_bytes_non_zeroed">scratch_resize_bytes_non_zeroed</a></li>
<li><a href="#scratch_resize_non_zeroed">scratch_resize_non_zeroed</a></li>
<li><a href="#set">set</a></li>
<li><a href="#simple_equal">simple_equal</a></li>
<li><a href="#slice_data_cast">slice_data_cast</a></li>
<li><a href="#slice_ptr">slice_ptr</a></li>
<li><a href="#slice_to_bytes">slice_to_bytes</a></li>
<li><a href="#slice_to_components">slice_to_components</a></li>
<li><a href="#small_stack_alloc">small_stack_alloc</a></li>
<li><a href="#small_stack_alloc_bytes">small_stack_alloc_bytes</a></li>
<li><a href="#small_stack_alloc_bytes_non_zeroed">small_stack_alloc_bytes_non_zeroed</a></li>
<li><a href="#small_stack_alloc_non_zeroed">small_stack_alloc_non_zeroed</a></li>
<li><a href="#small_stack_allocator">small_stack_allocator</a></li>
<li><a href="#small_stack_allocator_proc">small_stack_allocator_proc</a></li>
<li><a href="#small_stack_free">small_stack_free</a></li>
<li><a href="#small_stack_free_all">small_stack_free_all</a></li>
<li><a href="#small_stack_init">small_stack_init</a></li>
<li><a href="#small_stack_resize">small_stack_resize</a></li>
<li><a href="#small_stack_resize_bytes">small_stack_resize_bytes</a></li>
<li><a href="#small_stack_resize_bytes_non_zeroed">small_stack_resize_bytes_non_zeroed</a></li>
<li><a href="#small_stack_resize_non_zeroed">small_stack_resize_non_zeroed</a></li>
<li><a href="#stack_alloc">stack_alloc</a></li>
<li><a href="#stack_alloc_bytes">stack_alloc_bytes</a></li>
<li><a href="#stack_alloc_bytes_non_zeroed">stack_alloc_bytes_non_zeroed</a></li>
<li><a href="#stack_alloc_non_zeroed">stack_alloc_non_zeroed</a></li>
<li><a href="#stack_allocator">stack_allocator</a></li>
<li><a href="#stack_allocator_proc">stack_allocator_proc</a></li>
<li><a href="#stack_free">stack_free</a></li>
<li><a href="#stack_free_all">stack_free_all</a></li>
<li><a href="#stack_init">stack_init</a></li>
<li><a href="#stack_resize">stack_resize</a></li>
<li><a href="#stack_resize_bytes">stack_resize_bytes</a></li>
<li><a href="#stack_resize_bytes_non_zeroed">stack_resize_bytes_non_zeroed</a></li>
<li><a href="#stack_resize_non_zeroed">stack_resize_non_zeroed</a></li>
<li><a href="#tracking_allocator">tracking_allocator</a></li>
<li><a href="#tracking_allocator_bad_free_callback_add_to_array">tracking_allocator_bad_free_callback_add_to_array</a></li>
<li><a href="#tracking_allocator_bad_free_callback_panic">tracking_allocator_bad_free_callback_panic</a></li>
<li><a href="#tracking_allocator_clear">tracking_allocator_clear</a></li>
<li><a href="#tracking_allocator_destroy">tracking_allocator_destroy</a></li>
<li><a href="#tracking_allocator_init">tracking_allocator_init</a></li>
<li><a href="#tracking_allocator_proc">tracking_allocator_proc</a></li>
<li><a href="#tracking_allocator_reset">tracking_allocator_reset</a></li>
<li><a href="#zero">zero</a></li>
<li><a href="#zero_explicit">zero_explicit</a></li>
<li><a href="#zero_item">zero_item</a></li>
<li><a href="#zero_slice">zero_slice</a></li>
</ul>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Procedure Groups" aria-labelledby="#doc-index-Procedure Groups-header">
<summary id="#doc-index-Procedure Groups-header">
Procedure Groups (3)</summary>
<ul>
<li><a href="#delete">delete</a></li>
<li><a href="#make">make</a></li>
<li><a href="#rollback_stack_init">rollback_stack_init</a></li>
</ul>
</details>
</div>
</div>
</div>
<section class="documentation">
<h2 id="pkg-Types" class="pkg-header">Types</h2>
<div class="pkg-entity">
<h3 id="Allocator"><span><a class="doc-id-link" href="#Allocator">Allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L247"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Allocator :: runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocator.</p>
<p>This type represents generic interface for all allocators. Currently this type
is defined as follows:</p>
<pre>Allocator :: struct {
	procedure: Allocator_Proc,
	data: rawptr,
}

</pre>
<p><span class="doc-list"><code>procedure</code>: Pointer to the allocation procedure.</span>
<span class="doc-list"><code>data</code>: Pointer to the allocator data.</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Allocator_Error"><span><a class="doc-id-link" href="#Allocator_Error">Allocator_Error<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L103"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Allocator_Error :: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>An allocation request error.</p>
<p>This type represents error values the allocators may return upon requests.</p>
<pre>Allocator_Error :: enum byte {
	None                 = 0,
	Out_Of_Memory        = 1,
	Invalid_Pointer      = 2,
	Invalid_Argument     = 3,
	Mode_Not_Implemented = 4,
}

</pre>
<p>The meaning of the errors is as follows:</p>
<p><span class="doc-list"><code>None</code>: No error.</span>
<span class="doc-list"><code>Out_Of_Memory</code>: Either:</span></p>
<pre>1. The allocator has ran out of the backing buffer, or the requested
	allocation size is too large to fit into a backing buffer.
2. The operating system error during memory allocation.
3. The backing allocator was used to allocate a new backing buffer and the
	backing allocator returned Out_Of_Memory.
</pre>
<p><span class="doc-list"><code>Invalid_Pointer</code>: The pointer referring to a memory region does not belong</span></p>
<pre>to any of the allocators backing buffers or does not point to a valid start
of an allocation made in that allocator.
</pre>
<p><span class="doc-list"><code>Invalid_Argument</code>: Can occur if one of the arguments makes it impossible to</span></p>
<pre>satisfy a request (i.e. having alignment larger than the backing buffer
of the allocation).
</pre>
<p><span class="doc-list"><code>Mode_Not_Implemented</code>: The allocator does not support the specified</span></p>
<pre>operation. For example, an arena does not support freeing individual
allocations.
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="Allocator_Mode"><span><a class="doc-id-link" href="#Allocator_Mode">Allocator_Mode<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L39"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Allocator_Mode :: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Mode">Allocator_Mode</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>A request to allocator procedure.</p>
<p>This type represents a type of allocation request made to an allocator
procedure. There is one allocator procedure per allocator, and this value is
used to discriminate between different functions of the allocator.</p>
<p>The type is defined as follows:</p>
<pre>Allocator_Mode :: enum byte {
	Alloc,
	Alloc_Non_Zeroed,
	Free,
	Free_All,
	Resize,
	Resize_Non_Zeroed,
	Query_Features,
}

</pre>
<p>Depending on which value is used, the allocator procedure will perform different
functions:</p>
<p><span class="doc-list"><code>Alloc</code>: Allocates a memory region with a given <code>size</code> and <code>alignment</code>.</span>
<span class="doc-list"><code>Alloc_Non_Zeroed</code>: Same as <code>Alloc</code> without explicit zero-initialization of</span></p>
<pre>the memory region.
</pre>
<p><span class="doc-list"><code>Free</code>: Free a memory region located at address <code>ptr</code> with a given <code>size</code>.</span>
<span class="doc-list"><code>Free_All</code>: Free all memory allocated using this allocator.</span>
<span class="doc-list"><code>Resize</code>: Resize a memory region located at address <code>old_ptr</code> with size</span></p>
<pre>`old_size` to be `size` bytes in length and have the specified `alignment`,
in case a re-alllocation occurs.
</pre>
<p><span class="doc-list"><code>Resize_Non_Zeroed</code>: Same as <code>Resize</code>, without explicit zero-initialization.</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Allocator_Mode_Set"><span><a class="doc-id-link" href="#Allocator_Mode_Set">Allocator_Mode_Set<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L49"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Allocator_Mode_Set :: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Mode_Set">Allocator_Mode_Set</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>A set of allocator features.</p>
<p>This type represents values that contain a set of features an allocator has.
Currently the type is defined as follows:</p>
<pre>Allocator_Mode_Set :: distinct bit_set[Allocator_Mode];
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="Allocator_Proc"><span><a class="doc-id-link" href="#Allocator_Proc">Allocator_Proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L231"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Allocator_Proc :: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Proc">Allocator_Proc</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>The allocator procedure.</p>
<p>This type represents allocation procedures. An allocation procedure is a single
procedure, implementing all allocator functions such as allocating the memory,
freeing the memory, etc.</p>
<p>Currently the type is defined as follows:</p>
<pre>Allocator_Proc :: #type proc(
	allocator_data: rawptr,
	mode: Allocator_Mode,
	size: int,
	alignment: int,
	old_memory: rawptr,
	old_size: int,
	location: Source_Code_Location = #caller_location,
) -&gt; ([]byte, Allocator_Error);

</pre>
<p>The function of this procedure and the meaning of parameters depends on the
value of the <code>mode</code> parameter. For any operation the following constraints
apply:</p>
<p><span class="doc-list">The <code>alignment</code> must be a power of two.</span>
<span class="doc-list">The <code>size</code> must be a positive integer.</span></p>
<p></p>
<h4> 1. <code>.Alloc</code>, <code>.Alloc_Non_Zeroed</code></h4><p></p>
<p>Allocates a memory region of size <code>size</code>, aligned on a boundary specified by
<code>alignment</code>.</p>
<p><b>Inputs</b>:
<span class="doc-list"><code>allocator_data</code>: Pointer to the allocator data.</span>
<span class="doc-list"><code>mode</code>: <code>.Alloc</code> or <code>.Alloc_Non_Zeroed</code>.</span>
<span class="doc-list"><code>size</code>: The desired size of the memory region.</span>
<span class="doc-list"><code>alignment</code>: The desired alignmnet of the allocation.</span>
<span class="doc-list"><code>old_memory</code>: Unused, should  be <code>nil</code>.</span>
<span class="doc-list"><code>old_size</code>: Unused, should be 0.</span></p>
<p><b>Returns</b>:
1. The memory region, if allocated successfully, or <code>nil</code> otherwise.
2. An error, if allocation failed.</p>
<p><b>Note</b>: The nil allocator may return <code>nil</code>, even if no error is returned.
Always check both the error and the allocated buffer.</p>
<p><b>Note</b>: The <code>.Alloc</code> mode is required to be implemented for an allocator
and can not return a <code>.Mode_Not_Implemented</code> error.</p>
<p></p>
<h4> 2. <code>Free</code></h4><p></p>
<p>Frees a memory region located at the address specified by <code>old_memory</code>. If the
allocator does not track sizes of allocations, the size should be specified in
the <code>old_size</code> parameter.</p>
<p><b>Inputs</b>:
<span class="doc-list"><code>allocator_data</code>: Pointer to the allocator data.</span>
<span class="doc-list"><code>mode</code>: <code>.Free</code>.</span>
<span class="doc-list"><code>size</code>: Unused, should be 0.</span>
<span class="doc-list"><code>alignment</code>: Unused, should be 0.</span>
<span class="doc-list"><code>old_memory</code>: Pointer to the memory region to free.</span>
<span class="doc-list"><code>old_size</code>: The size of the memory region to free. This parameter is optional</span></p>
<pre>if the allocator keeps track of the sizes of allocations.

</pre>
<p><b>Returns</b>:
1. <code>nil</code>
2. Error, if freeing failed.</p>
<p></p>
<h4> 3. <code>Free_All</code></h4><p></p>
<p>Frees all allocations, associated with the allocator, making it available for
further allocations using the same backing buffers.</p>
<p><b>Inputs</b>:
<span class="doc-list"><code>allocator_data</code>: Pointer to the allocator data.</span>
<span class="doc-list"><code>mode</code>: <code>.Free_All</code>.</span>
<span class="doc-list"><code>size</code>: Unused, should be 0.</span>
<span class="doc-list"><code>alignment</code>: Unused, should be 0.</span>
<span class="doc-list"><code>old_memory</code>: Unused, should be <code>nil</code>.</span>
<span class="doc-list"><code>old_size</code>: Unused, should be <code>0</code>.</span></p>
<p><b>Returns</b>:
1. <code>nil</code>.
2. Error, if freeing failed.</p>
<p></p>
<h4> 4. <code>Resize</code>, <code>Resize_Non_Zeroed</code></h4><p></p>
<p>Resizes the memory region, of the size <code>old_size</code> located at the address
specified by <code>old_memory</code> to have the new size <code>size</code>. The slice of the new
memory region is returned from the procedure. The allocator may attempt to
keep the new memory region at the same address as the previous allocation,
however no such guarantee is made. Do not assume the new memory region will
be at the same address as the old memory region.</p>
<p>If <code>old_memory</code> pointer is <code>nil</code>, this function acts just like <code>.Alloc</code> or
<code>.Alloc_Non_Zeroed</code>, using <code>size</code> and <code>alignment</code> to allocate a new memory
region.</p>
<p>If <code>new_size</code> is <code>nil</code>, the procedure acts just like <code>.Free</code>, freeing the
memory region <code>old_size</code> bytes in length, located at the address specified by
<code>old_memory</code>.</p>
<p>If the <code>old_memory</code> pointer is not aligned to the boundary specified by
<code>alignment</code>, the procedure relocates the buffer such that the reallocated
buffer is aligned to the boundary specified by <code>alignment</code>.</p>
<p><b>Inputs</b>:
<span class="doc-list"><code>allocator_data</code>: Pointer to the allocator data.</span>
<span class="doc-list"><code>mode</code>: <code>.Resize</code> or <code>.Resize_All</code>.</span>
<span class="doc-list"><code>size</code>: The desired new size of the memory region.</span>
<span class="doc-list"><code>alignment</code>: The alignment of the new memory region, if its allocated</span>
<span class="doc-list"><code>old_memory</code>: The pointer to the memory region to resize.</span>
<span class="doc-list"><code>old_size</code>: The size of the memory region to resize. If the allocator</span></p>
<pre>keeps track of the sizes of allocations, this parameter is optional.

</pre>
<p><b>Returns</b>:
1. The slice of the  memory region after resize operation, if successfull,</p>
<pre>`nil` otherwise.
</pre>
<p>2. An error, if the resize failed.</p>
<p><b>Note</b>: Some allocators may return <code>nil</code>, even if no error is returned.
Always check both the error and the allocated buffer.</p>
<p><b>Note</b>: if <code>old_size</code> is <code>0</code> and <code>old_memory</code> is <code>nil</code>, this operation is a
no-op, and should not return errors.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Allocator_Query_Info"><span><a class="doc-id-link" href="#Allocator_Query_Info">Allocator_Query_Info<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L69"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Allocator_Query_Info :: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Query_Info">Allocator_Query_Info</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocator information.</p>
<p>This type represents information about a given allocator at a specific point
in time. Currently the type is defined as follows:</p>
<pre>Allocator_Query_Info :: struct {
	pointer:   rawptr,
	size:      Maybe(int),
	alignment: Maybe(int),
}

</pre>
<p><span class="doc-list"><code>pointer</code>: Pointer to a backing buffer.</span>
<span class="doc-list"><code>size</code>: Size of the backing buffer.</span>
<span class="doc-list"><code>alignment</code>: The allocator's alignment.</span></p>
<p>If not applicable, any of these fields may be <code>nil</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Arena"><span><a class="doc-id-link" href="#Arena">Arena<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L147"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Arena :: <span class="keyword-type">struct</span> {
	data:       []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>,
	offset:     <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	peak_used:  <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	temp_count: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Arena allocator data.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/mem/#arena_alloc">arena_alloc</a></li>
<li><a href="/core/mem/#arena_alloc_bytes">arena_alloc_bytes</a></li>
<li><a href="/core/mem/#arena_alloc_bytes_non_zeroed">arena_alloc_bytes_non_zeroed</a></li>
<li><a href="/core/mem/#arena_alloc_non_zeroed">arena_alloc_non_zeroed</a></li>
<li><a href="/core/mem/#arena_allocator">arena_allocator</a></li>
<li><a href="/core/mem/#arena_free_all">arena_free_all</a></li>
<li><a href="/core/mem/#arena_init">arena_init</a></li>
<li><a href="/core/mem/#begin_arena_temp_memory">begin_arena_temp_memory</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Arena_Temp_Memory"><span><a class="doc-id-link" href="#Arena_Temp_Memory">Arena_Temp_Memory<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L337"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Arena_Temp_Memory :: <span class="keyword-type">struct</span> {
	arena:       ^<a class="code-typename" href="/core/mem/#Arena">Arena</a>,
	prev_offset: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Temporary memory region of an <code>Arena</code> allocator.</p>
<p>Temporary memory regions of an arena act as "save-points" for the allocator.
When one is created, the subsequent allocations are done inside the temporary
memory region. When <code>end_arena_temp_memory</code> is called, the arena is rolled
back, and all of the memory that was allocated from the arena will be freed.</p>
<p>Multiple temporary memory regions can exist at the same time for an arena.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/mem/#end_arena_temp_memory">end_arena_temp_memory</a></li>
</ul>
<h5>Related Procedures With Returns</h5>
<ul>
<li><a href="/core/mem/#begin_arena_temp_memory">begin_arena_temp_memory</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Buddy_Allocator"><span><a class="doc-id-link" href="#Buddy_Allocator">Buddy_Allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2197"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Buddy_Allocator :: <span class="keyword-type">struct</span> {
	head:      ^<a class="code-typename" href="/core/mem/#Buddy_Block">Buddy_Block</a>,
	tail:      ^<a class="code-typename" href="/core/mem/#Buddy_Block">Buddy_Block</a> <span class="string">`fmt:"-"`</span>,
	alignment: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>The buddy allocator data.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/mem/#buddy_allocator">buddy_allocator</a></li>
<li><a href="/core/mem/#buddy_allocator_alloc">buddy_allocator_alloc</a></li>
<li><a href="/core/mem/#buddy_allocator_alloc_bytes">buddy_allocator_alloc_bytes</a></li>
<li><a href="/core/mem/#buddy_allocator_alloc_bytes_non_zeroed">buddy_allocator_alloc_bytes_non_zeroed</a></li>
<li><a href="/core/mem/#buddy_allocator_alloc_non_zeroed">buddy_allocator_alloc_non_zeroed</a></li>
<li><a href="/core/mem/#buddy_allocator_free">buddy_allocator_free</a></li>
<li><a href="/core/mem/#buddy_allocator_free_all">buddy_allocator_free_all</a></li>
<li><a href="/core/mem/#buddy_allocator_init">buddy_allocator_init</a></li>
<li><a href="/core/mem/#buddy_block_size_required">buddy_block_size_required</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Buddy_Block"><span><a class="doc-id-link" href="#Buddy_Block">Buddy_Block<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2060"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Buddy_Block :: <span class="keyword-type">struct</span> <span class="directive">#align</span>&nbsp;(align_of(uint)) {
	size:    <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>,
	is_free: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Header of the buddy block.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/mem/#buddy_block_coalescence">buddy_block_coalescence</a></li>
<li><a href="/core/mem/#buddy_block_find_best">buddy_block_find_best</a></li>
<li><a href="/core/mem/#buddy_block_next">buddy_block_next</a></li>
<li><a href="/core/mem/#buddy_block_split">buddy_block_split</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Compat_Allocator"><span><a class="doc-id-link" href="#Compat_Allocator">Compat_Allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2431"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Compat_Allocator :: <span class="keyword-type">struct</span> {
	parent: runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>An allocator that keeps track of allocation sizes and passes it along to resizes.
This is useful if you are using a library that needs an equivalent of <code>realloc</code> but want to use
the Odin allocator interface.</p>
<p>You want to wrap your allocator into this one if you are trying to use any allocator that relies
on the old size to work.</p>
<p>The overhead of this allocator is an extra max(alignment, size_of(Header)) bytes allocated for each allocation, these bytes are
used to store the size and alignment.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/mem/#compat_allocator">compat_allocator</a></li>
<li><a href="/core/mem/#compat_allocator_init">compat_allocator_init</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Dynamic_Arena"><span><a class="doc-id-link" href="#Dynamic_Arena">Dynamic_Arena<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1658"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Dynamic_Arena :: <span class="keyword-type">struct</span> {
	block_size:           <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	out_band_size:        <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	alignment:            <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	unused_blocks:        [<span class="keyword">dynamic</span>]<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>,
	used_blocks:          [<span class="keyword">dynamic</span>]<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>,
	out_band_allocations: [<span class="keyword">dynamic</span>]<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>,
	current_block:        <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>,
	current_pos:          <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>,
	bytes_left:           <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	block_allocator:      runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Dynamic arena allocator data.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/mem/#dynamic_arena_alloc">dynamic_arena_alloc</a></li>
<li><a href="/core/mem/#dynamic_arena_alloc_bytes">dynamic_arena_alloc_bytes</a></li>
<li><a href="/core/mem/#dynamic_arena_alloc_bytes_non_zeroed">dynamic_arena_alloc_bytes_non_zeroed</a></li>
<li><a href="/core/mem/#dynamic_arena_alloc_non_zeroed">dynamic_arena_alloc_non_zeroed</a></li>
<li><a href="/core/mem/#dynamic_arena_allocator">dynamic_arena_allocator</a></li>
<li><a href="/core/mem/#dynamic_arena_destroy">dynamic_arena_destroy</a></li>
<li><a href="/core/mem/#dynamic_arena_free_all">dynamic_arena_free_all</a></li>
<li><a href="/core/mem/#dynamic_arena_init">dynamic_arena_init</a></li>
<li><a href="/core/mem/#dynamic_arena_reset">dynamic_arena_reset</a></li>
<li><a href="/core/mem/#dynamic_arena_resize">dynamic_arena_resize</a></li>
<li><a href="/core/mem/#dynamic_arena_resize_bytes">dynamic_arena_resize_bytes</a></li>
<li><a href="/core/mem/#dynamic_arena_resize_bytes_non_zeroed">dynamic_arena_resize_bytes_non_zeroed</a></li>
<li><a href="/core/mem/#dynamic_arena_resize_non_zeroed">dynamic_arena_resize_non_zeroed</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Dynamic_Pool"><span><a class="doc-id-link" href="#Dynamic_Pool">Dynamic_Pool<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1633"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Dynamic_Pool :: <a class="code-typename" href="/core/mem/#Dynamic_Arena">Dynamic_Arena</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Preserved for compatibility</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Fixed_Byte_Buffer"><span><a class="doc-id-link" href="#Fixed_Byte_Buffer">Fixed_Byte_Buffer<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L636"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Fixed_Byte_Buffer :: <span class="keyword-type">distinct</span> [<span class="keyword">dynamic</span>]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Dynamic array with a fixed capacity buffer.</p>
<p>This type represents dynamic arrays with a fixed-size backing buffer. Upon
allocating memory beyond reaching the maximum capacity, allocations from fixed
byte buffers return <code>nil</code> and no error.</p>
</details>
<h5>Related Procedures With Returns</h5>
<ul>
<li><a href="/core/mem/#make_fixed_byte_buffer">make_fixed_byte_buffer</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Mutex_Allocator"><span><a class="doc-id-link" href="#Mutex_Allocator">Mutex_Allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mutex_allocator.odin#L9"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Mutex_Allocator :: <span class="keyword-type">struct</span> {
	backing: runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a>,
	mutex:   sync.<a class="code-typename" href="/core/sync/#Mutex">Mutex</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>The data for mutex allocator.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/mem/#mutex_allocator">mutex_allocator</a></li>
<li><a href="/core/mem/#mutex_allocator_init">mutex_allocator_init</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Raw_Any"><span><a class="doc-id-link" href="#Raw_Any">Raw_Any<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L9"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_Any :: runtime.<a class="code-typename" href="/base/runtime/#Raw_Any">Raw_Any</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of the <code>any</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_Complex128"><span><a class="doc-id-link" href="#Raw_Complex128">Raw_Complex128<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L65"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_Complex128 :: runtime.<a class="code-typename" href="/base/runtime/#Raw_Complex128">Raw_Complex128</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of the <code>complex128</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_Complex32"><span><a class="doc-id-link" href="#Raw_Complex32">Raw_Complex32<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L55"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_Complex32 :: runtime.<a class="code-typename" href="/base/runtime/#Raw_Complex32">Raw_Complex32</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of the <code>complex32</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_Complex64"><span><a class="doc-id-link" href="#Raw_Complex64">Raw_Complex64<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L60"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_Complex64 :: runtime.<a class="code-typename" href="/base/runtime/#Raw_Complex64">Raw_Complex64</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of the <code>complex64</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_Cstring"><span><a class="doc-id-link" href="#Raw_Cstring">Raw_Cstring<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L19"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_Cstring :: runtime.<a class="code-typename" href="/base/runtime/#Raw_Cstring">Raw_Cstring</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of the <code>cstring</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_Cstring16"><span><a class="doc-id-link" href="#Raw_Cstring16">Raw_Cstring16<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L30"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_Cstring16 :: runtime.<a class="code-typename" href="/base/runtime/#Raw_Cstring16">Raw_Cstring16</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of the <code>cstring16</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_Dynamic_Array"><span><a class="doc-id-link" href="#Raw_Dynamic_Array">Raw_Dynamic_Array<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L40"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_Dynamic_Array :: runtime.<a class="code-typename" href="/base/runtime/#Raw_Dynamic_Array">Raw_Dynamic_Array</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of <code>[dynamic]T</code> types.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_Map"><span><a class="doc-id-link" href="#Raw_Map">Raw_Map<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L45"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_Map :: runtime.<a class="code-typename" href="/base/runtime/#Raw_Map">Raw_Map</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of <code>map[K]V</code> types.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_Quaternion128"><span><a class="doc-id-link" href="#Raw_Quaternion128">Raw_Quaternion128<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L75"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_Quaternion128 :: runtime.<a class="code-typename" href="/base/runtime/#Raw_Quaternion128">Raw_Quaternion128</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of the <code>quaternion128</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_Quaternion128_Vector_Scalar"><span><a class="doc-id-link" href="#Raw_Quaternion128_Vector_Scalar">Raw_Quaternion128_Vector_Scalar<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L90"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_Quaternion128_Vector_Scalar :: runtime.<a class="code-typename" href="/base/runtime/#Raw_Quaternion128_Vector_Scalar">Raw_Quaternion128_Vector_Scalar</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of the <code>quaternion128</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_Quaternion256"><span><a class="doc-id-link" href="#Raw_Quaternion256">Raw_Quaternion256<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L80"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_Quaternion256 :: runtime.<a class="code-typename" href="/base/runtime/#Raw_Quaternion256">Raw_Quaternion256</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of the <code>quaternion256</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_Quaternion256_Vector_Scalar"><span><a class="doc-id-link" href="#Raw_Quaternion256_Vector_Scalar">Raw_Quaternion256_Vector_Scalar<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L95"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_Quaternion256_Vector_Scalar :: runtime.<a class="code-typename" href="/base/runtime/#Raw_Quaternion256_Vector_Scalar">Raw_Quaternion256_Vector_Scalar</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of the <code>quaternion256</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_Quaternion64"><span><a class="doc-id-link" href="#Raw_Quaternion64">Raw_Quaternion64<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L70"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_Quaternion64 :: runtime.<a class="code-typename" href="/base/runtime/#Raw_Quaternion64">Raw_Quaternion64</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of the <code>quaternion64</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_Quaternion64_Vector_Scalar"><span><a class="doc-id-link" href="#Raw_Quaternion64_Vector_Scalar">Raw_Quaternion64_Vector_Scalar<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L85"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_Quaternion64_Vector_Scalar :: runtime.<a class="code-typename" href="/base/runtime/#Raw_Quaternion64_Vector_Scalar">Raw_Quaternion64_Vector_Scalar</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of the <code>quaternion64</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_Slice"><span><a class="doc-id-link" href="#Raw_Slice">Raw_Slice<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L35"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_Slice :: runtime.<a class="code-typename" href="/base/runtime/#Raw_Slice">Raw_Slice</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of <code>[]T</code> types.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_Soa_Pointer"><span><a class="doc-id-link" href="#Raw_Soa_Pointer">Raw_Soa_Pointer<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L50"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_Soa_Pointer :: runtime.<a class="code-typename" href="/base/runtime/#Raw_Soa_Pointer">Raw_Soa_Pointer</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of <code>#soa []T</code> types.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_String"><span><a class="doc-id-link" href="#Raw_String">Raw_String<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L14"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_String :: runtime.<a class="code-typename" href="/base/runtime/#Raw_String">Raw_String</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of the <code>string</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Raw_String16"><span><a class="doc-id-link" href="#Raw_String16">Raw_String16<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L25"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Raw_String16 :: runtime.<a class="code-typename" href="/base/runtime/#Raw_String16">Raw_String16</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Memory layout of the <code>string16</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Rollback_Stack"><span><a class="doc-id-link" href="#Rollback_Stack">Rollback_Stack<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L45"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Rollback_Stack :: <span class="keyword-type">struct</span> {
	head:            ^<a class="code-typename" href="/core/mem/#Rollback_Stack_Block">Rollback_Stack_Block</a>,
	block_size:      <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	block_allocator: runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Rollback stack allocator data.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/mem/#rb_alloc">rb_alloc</a></li>
<li><a href="/core/mem/#rb_alloc_bytes">rb_alloc_bytes</a></li>
<li><a href="/core/mem/#rb_alloc_bytes_non_zeroed">rb_alloc_bytes_non_zeroed</a></li>
<li><a href="/core/mem/#rb_alloc_non_zeroed">rb_alloc_non_zeroed</a></li>
<li><a href="/core/mem/#rb_resize">rb_resize</a></li>
<li><a href="/core/mem/#rb_resize_bytes">rb_resize_bytes</a></li>
<li><a href="/core/mem/#rb_resize_bytes_non_zeroed">rb_resize_bytes_non_zeroed</a></li>
<li><a href="/core/mem/#rb_resize_non_zeroed">rb_resize_non_zeroed</a></li>
<li><a href="/core/mem/#rollback_stack_allocator">rollback_stack_allocator</a></li>
<li><a href="/core/mem/#rollback_stack_destroy">rollback_stack_destroy</a></li>
<li><a href="/core/mem/#rollback_stack_init_buffered">rollback_stack_init_buffered</a></li>
<li><a href="/core/mem/#rollback_stack_init_dynamic">rollback_stack_init_dynamic</a></li>
<li><a href="/core/mem/#rollback_stack_init">rollback_stack_init</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Rollback_Stack_Block"><span><a class="doc-id-link" href="#Rollback_Stack_Block">Rollback_Stack_Block<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L35"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Rollback_Stack_Block :: <span class="keyword-type">struct</span> {
	next_block: ^<a class="code-typename" href="/core/mem/#Rollback_Stack_Block">Rollback_Stack_Block</a>,
	last_alloc: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>,
	offset:     <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>,
	buffer:     []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Block header of the rollback stack allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Rollback_Stack_Header"><span><a class="doc-id-link" href="#Rollback_Stack_Header">Rollback_Stack_Header<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L26"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Rollback_Stack_Header :: <span class="keyword-type">distinct</span> <span class="keyword-type">bit_field</span>&nbsp;<a href="/base/builtin#u64"><span class="doc-builtin">u64</span></a> {
	prev_offset: <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a> | 32,
	is_free:     <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> | 1,
	prev_ptr:    <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a> | 31,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocation header of the rollback stack allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Scratch"><span><a class="doc-id-link" href="#Scratch">Scratch<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L380"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Scratch :: <span class="keyword-type">struct</span> {
	data:                 []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>,
	curr_offset:          <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	prev_allocation:      <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>,
	prev_allocation_root: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>,
	backup_allocator:     runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a>,
	leaked_allocations:   [<span class="keyword">dynamic</span>][]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Scratch allocator data.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/mem/#scratch_alloc">scratch_alloc</a></li>
<li><a href="/core/mem/#scratch_alloc_bytes">scratch_alloc_bytes</a></li>
<li><a href="/core/mem/#scratch_alloc_bytes_non_zeroed">scratch_alloc_bytes_non_zeroed</a></li>
<li><a href="/core/mem/#scratch_alloc_non_zeroed">scratch_alloc_non_zeroed</a></li>
<li><a href="/core/mem/#scratch_allocator">scratch_allocator</a></li>
<li><a href="/core/mem/#scratch_destroy">scratch_destroy</a></li>
<li><a href="/core/mem/#scratch_free">scratch_free</a></li>
<li><a href="/core/mem/#scratch_free_all">scratch_free_all</a></li>
<li><a href="/core/mem/#scratch_init">scratch_init</a></li>
<li><a href="/core/mem/#scratch_resize">scratch_resize</a></li>
<li><a href="/core/mem/#scratch_resize_bytes">scratch_resize_bytes</a></li>
<li><a href="/core/mem/#scratch_resize_bytes_non_zeroed">scratch_resize_bytes_non_zeroed</a></li>
<li><a href="/core/mem/#scratch_resize_non_zeroed">scratch_resize_non_zeroed</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Scratch_Allocator"><span><a class="doc-id-link" href="#Scratch_Allocator">Scratch_Allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L373"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Scratch_Allocator :: <a class="code-typename" href="/core/mem/#Scratch">Scratch</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Preserved for compatibility</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Small_Stack"><span><a class="doc-id-link" href="#Small_Stack">Small_Stack<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1247"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Small_Stack :: <span class="keyword-type">struct</span> {
	data:      []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>,
	offset:    <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	peak_used: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Small stack allocator data.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/mem/#small_stack_alloc">small_stack_alloc</a></li>
<li><a href="/core/mem/#small_stack_alloc_bytes">small_stack_alloc_bytes</a></li>
<li><a href="/core/mem/#small_stack_alloc_bytes_non_zeroed">small_stack_alloc_bytes_non_zeroed</a></li>
<li><a href="/core/mem/#small_stack_alloc_non_zeroed">small_stack_alloc_non_zeroed</a></li>
<li><a href="/core/mem/#small_stack_allocator">small_stack_allocator</a></li>
<li><a href="/core/mem/#small_stack_free">small_stack_free</a></li>
<li><a href="/core/mem/#small_stack_free_all">small_stack_free_all</a></li>
<li><a href="/core/mem/#small_stack_init">small_stack_init</a></li>
<li><a href="/core/mem/#small_stack_resize">small_stack_resize</a></li>
<li><a href="/core/mem/#small_stack_resize_bytes">small_stack_resize_bytes</a></li>
<li><a href="/core/mem/#small_stack_resize_bytes_non_zeroed">small_stack_resize_bytes_non_zeroed</a></li>
<li><a href="/core/mem/#small_stack_resize_non_zeroed">small_stack_resize_non_zeroed</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Small_Stack_Allocation_Header"><span><a class="doc-id-link" href="#Small_Stack_Allocation_Header">Small_Stack_Allocation_Header<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1240"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Small_Stack_Allocation_Header :: <span class="keyword-type">struct</span> {
	padding: <a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocation header of the small stack allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Stack"><span><a class="doc-id-link" href="#Stack">Stack<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L821"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Stack :: <span class="keyword-type">struct</span> {
	data:        []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>,
	prev_offset: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	curr_offset: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	peak_used:   <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Stack allocator data.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/mem/#stack_alloc">stack_alloc</a></li>
<li><a href="/core/mem/#stack_alloc_bytes">stack_alloc_bytes</a></li>
<li><a href="/core/mem/#stack_alloc_bytes_non_zeroed">stack_alloc_bytes_non_zeroed</a></li>
<li><a href="/core/mem/#stack_alloc_non_zeroed">stack_alloc_non_zeroed</a></li>
<li><a href="/core/mem/#stack_allocator">stack_allocator</a></li>
<li><a href="/core/mem/#stack_free">stack_free</a></li>
<li><a href="/core/mem/#stack_free_all">stack_free_all</a></li>
<li><a href="/core/mem/#stack_init">stack_init</a></li>
<li><a href="/core/mem/#stack_resize">stack_resize</a></li>
<li><a href="/core/mem/#stack_resize_bytes">stack_resize_bytes</a></li>
<li><a href="/core/mem/#stack_resize_bytes_non_zeroed">stack_resize_bytes_non_zeroed</a></li>
<li><a href="/core/mem/#stack_resize_non_zeroed">stack_resize_non_zeroed</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Stack_Allocation_Header"><span><a class="doc-id-link" href="#Stack_Allocation_Header">Stack_Allocation_Header<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L831"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Stack_Allocation_Header :: <span class="keyword-type">struct</span> {
	prev_offset: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	padding:     <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Header of a stack allocation.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Tracking_Allocator"><span><a class="doc-id-link" href="#Tracking_Allocator">Tracking_Allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/tracking_allocator.odin#L45"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Tracking_Allocator :: <span class="keyword-type">struct</span> {
	backing:                  runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a>,
	allocation_map:           <span class="keyword-type">map</span>[<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>]<a class="code-typename" href="/core/mem/#Tracking_Allocator_Entry">Tracking_Allocator_Entry</a>,
	bad_free_callback:        <a class="code-typename" href="/core/mem/#Tracking_Allocator_Bad_Free_Callback">Tracking_Allocator_Bad_Free_Callback</a>,
	bad_free_array:           [<span class="keyword">dynamic</span>]<a class="code-typename" href="/core/mem/#Tracking_Allocator_Bad_Free_Entry">Tracking_Allocator_Bad_Free_Entry</a>,
	mutex:                    sync.<a class="code-typename" href="/core/sync/#Mutex">Mutex</a>,
	clear_on_free_all:        <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>,
	total_memory_allocated:   <a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a>,
	total_allocation_count:   <a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a>,
	total_memory_freed:       <a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a>,
	total_free_count:         <a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a>,
	peak_memory_allocated:    <a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a>,
	current_memory_allocated: <a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Tracking allocator data.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/mem/#tracking_allocator">tracking_allocator</a></li>
<li><a href="/core/mem/#tracking_allocator_bad_free_callback_add_to_array">tracking_allocator_bad_free_callback_add_to_array</a></li>
<li><a href="/core/mem/#tracking_allocator_bad_free_callback_panic">tracking_allocator_bad_free_callback_panic</a></li>
<li><a href="/core/mem/#tracking_allocator_clear">tracking_allocator_clear</a></li>
<li><a href="/core/mem/#tracking_allocator_destroy">tracking_allocator_destroy</a></li>
<li><a href="/core/mem/#tracking_allocator_init">tracking_allocator_init</a></li>
<li><a href="/core/mem/#tracking_allocator_reset">tracking_allocator_reset</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Tracking_Allocator_Bad_Free_Callback"><span><a class="doc-id-link" href="#Tracking_Allocator_Bad_Free_Callback">Tracking_Allocator_Bad_Free_Callback<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/tracking_allocator.odin#L40"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Tracking_Allocator_Bad_Free_Callback :: <span class="keyword-type">proc</span>(t: ^<a class="code-typename" href="/core/mem/#Tracking_Allocator">Tracking_Allocator</a>, memory: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, location: runtime.<a class="code-typename" href="/base/runtime/#Source_Code_Location">Source_Code_Location</a>)</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Callback type for when tracking allocator runs into a bad free.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Tracking_Allocator_Bad_Free_Entry"><span><a class="doc-id-link" href="#Tracking_Allocator_Bad_Free_Entry">Tracking_Allocator_Bad_Free_Entry<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/tracking_allocator.odin#L30"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Tracking_Allocator_Bad_Free_Entry :: <span class="keyword-type">struct</span> {
	<span class="comment">// Pointer, on which free operation was called.</span>
	memory:   <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>,
	<span class="comment">// The source location of where the operation was called.</span>
	location: runtime.<a class="code-typename" href="/base/runtime/#Source_Code_Location">Source_Code_Location</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Bad free entry for a tracking allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Tracking_Allocator_Entry"><span><a class="doc-id-link" href="#Tracking_Allocator_Entry">Tracking_Allocator_Entry<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/tracking_allocator.odin#L12"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Tracking_Allocator_Entry :: <span class="keyword-type">struct</span> {
	<span class="comment">// Pointer to an allocated region.</span>
	memory:    <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>,
	<span class="comment">// Size of the allocated memory region.</span>
	size:      <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	<span class="comment">// Requested alignment.</span>
	alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	<span class="comment">// Mode of the operation.</span>
	mode:      runtime.<a class="code-typename" href="/base/runtime/#Allocator_Mode">Allocator_Mode</a>,
	<span class="comment">// Error.</span>
	err:       runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>,
	<span class="comment">// Location of the allocation.</span>
	location:  runtime.<a class="code-typename" href="/base/runtime/#Source_Code_Location">Source_Code_Location</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocation entry for the tracking allocator.</p>
<p>This structure stores the data related to an allocation.</p>
</details>
</div>
<h2 id="pkg-Constants" class="pkg-header">Constants</h2>
<div class="pkg-entity">
<h3 id="Byte"><span><a class="doc-id-link" href="#Byte">Byte<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L11"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Byte: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> : runtime.Byte</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>The size, in bytes, of a single byte.</p>
<p>This constant is equal to the value of <code>1</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="DEFAULT_ALIGNMENT"><span><a class="doc-id-link" href="#DEFAULT_ALIGNMENT">DEFAULT_ALIGNMENT<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L255"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">DEFAULT_ALIGNMENT: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> : 2 * align_of(rawptr)</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Default alignment.</p>
<p>This value is the default alignment for all platforms that is used, if the
alignment is not specified explicitly.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="DEFAULT_PAGE_SIZE"><span><a class="doc-id-link" href="#DEFAULT_PAGE_SIZE">DEFAULT_PAGE_SIZE<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L262"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">DEFAULT_PAGE_SIZE: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> : 64 * 1024 when ODIN_ARCH == .wasm32 || ODIN_ARCH == .wasm64p32 else 16 * 1024 when ODIN_OS == .Darwin && ODIN_ARCH == .arm64 else 4 * 1024</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Default page size.</p>
<p>This value is the default page size for the current platform.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="DYNAMIC_ARENA_BLOCK_SIZE_DEFAULT"><span><a class="doc-id-link" href="#DYNAMIC_ARENA_BLOCK_SIZE_DEFAULT">DYNAMIC_ARENA_BLOCK_SIZE_DEFAULT<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1648"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">DYNAMIC_ARENA_BLOCK_SIZE_DEFAULT: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> : 65536</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Default block size for dynamic arena.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="DYNAMIC_ARENA_OUT_OF_BAND_SIZE_DEFAULT"><span><a class="doc-id-link" href="#DYNAMIC_ARENA_OUT_OF_BAND_SIZE_DEFAULT">DYNAMIC_ARENA_OUT_OF_BAND_SIZE_DEFAULT<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1653"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">DYNAMIC_ARENA_OUT_OF_BAND_SIZE_DEFAULT: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> : 6554</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Default out-band size of the dynamic arena.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="DYNAMIC_POOL_BLOCK_SIZE_DEFAULT"><span><a class="doc-id-link" href="#DYNAMIC_POOL_BLOCK_SIZE_DEFAULT">DYNAMIC_POOL_BLOCK_SIZE_DEFAULT<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1634"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">DYNAMIC_POOL_BLOCK_SIZE_DEFAULT: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> : DYNAMIC_ARENA_BLOCK_SIZE_DEFAULT</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="DYNAMIC_POOL_OUT_OF_BAND_SIZE_DEFAULT"><span><a class="doc-id-link" href="#DYNAMIC_POOL_OUT_OF_BAND_SIZE_DEFAULT">DYNAMIC_POOL_OUT_OF_BAND_SIZE_DEFAULT<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1635"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">DYNAMIC_POOL_OUT_OF_BAND_SIZE_DEFAULT: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> : DYNAMIC_ARENA_OUT_OF_BAND_SIZE_DEFAULT</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="Exabyte"><span><a class="doc-id-link" href="#Exabyte">Exabyte<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L59"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Exabyte: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> : runtime.Exabyte</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>The size, in bytes, of one exabyte.</p>
<p>This constant is equal to the amount of bytes in one exabyte (also known as
exbibyte), which is equal to 1024 petabytes.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Gigabyte"><span><a class="doc-id-link" href="#Gigabyte">Gigabyte<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L35"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Gigabyte: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> : runtime.Gigabyte</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>The size, in bytes, of one gigabyte.</p>
<p>This constant is equal to the amount of bytes in one gigabyte (also known as
gibiibyte), which is equal to 1024 megabytes.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Kilobyte"><span><a class="doc-id-link" href="#Kilobyte">Kilobyte<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L19"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Kilobyte: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> : runtime.Kilobyte</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>The size, in bytes, of one kilobyte.</p>
<p>This constant is equal to the amount of bytes in one kilobyte (also known as
kibibyte), which is equal to 1024 bytes.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Megabyte"><span><a class="doc-id-link" href="#Megabyte">Megabyte<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L27"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Megabyte: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> : runtime.Megabyte</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>The size, in bytes, of one megabyte.</p>
<p>This constant is equal to the amount of bytes in one megabyte (also known as
mebibyte), which is equal to 1024 kilobyte.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Petabyte"><span><a class="doc-id-link" href="#Petabyte">Petabyte<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L51"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Petabyte: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> : runtime.Petabyte</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>The size, in bytes, of one petabyte.</p>
<p>This constant is equal to the amount of bytes in one petabyte (also known as
pebiibyte), which is equal to 1024 terabytes.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="ROLLBACK_STACK_DEFAULT_BLOCK_SIZE"><span><a class="doc-id-link" href="#ROLLBACK_STACK_DEFAULT_BLOCK_SIZE">ROLLBACK_STACK_DEFAULT_BLOCK_SIZE<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L9"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">ROLLBACK_STACK_DEFAULT_BLOCK_SIZE: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> : 4 * Megabyte</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Rollback stack default block size.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="ROLLBACK_STACK_MAX_HEAD_BLOCK_SIZE"><span><a class="doc-id-link" href="#ROLLBACK_STACK_MAX_HEAD_BLOCK_SIZE">ROLLBACK_STACK_MAX_HEAD_BLOCK_SIZE<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L21"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">ROLLBACK_STACK_MAX_HEAD_BLOCK_SIZE: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> : 2 * Gigabyte</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Rollback stack max head block size.</p>
<p>This limitation is due to the size of <code>prev_ptr</code>, but it is only for the
head block; any allocation in excess of the allocator's <code>block_size</code> is
valid, so long as the block allocator can handle it.</p>
<p>This is because allocations over the block size are not split up if the item
within is freed; they are immediately returned to the block allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Terabyte"><span><a class="doc-id-link" href="#Terabyte">Terabyte<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L43"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Terabyte: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> : runtime.Terabyte</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>The size, in bytes, of one terabyte.</p>
<p>This constant is equal to the amount of bytes in one terabyte (also known as
tebiibyte), which is equal to 1024 gigabytes.</p>
</details>
</div>
<h2 id="pkg-Variables" class="pkg-header">Variables</h2>
<p class="pkg-empty-section">This section is empty.</p>
<h2 id="pkg-Procedures" class="pkg-header">Procedures</h2>
<div class="pkg-entity">
<h3 id="align_backward"><span><a class="doc-id-link" href="#align_backward">align_backward<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L573"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">align_backward :: <span class="keyword-type">proc</span>(ptr: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, align: <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>) -> <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Align rawptr backwards.</p>
<p>This procedure returns the previous address before <code>ptr</code>, that is located on the
alignment boundary specified by <code>align</code>. If <code>ptr</code> is already aligned to <code>align</code>
bytes, <code>ptr</code> is returned.</p>
<p>The specified alignment must be a power of 2.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="align_backward_int"><span><a class="doc-id-link" href="#align_backward_int">align_backward_int<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L587"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">align_backward_int :: <span class="keyword-type">proc</span>(ptr, align: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Align int backwards.</p>
<p>This procedure returns the previous address before <code>ptr</code>, that is located on the
alignment boundary specified by <code>align</code>. If <code>ptr</code> is already aligned to <code>align</code>
bytes, <code>ptr</code> is returned.</p>
<p>The specified alignment must be a power of 2.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="align_backward_uint"><span><a class="doc-id-link" href="#align_backward_uint">align_backward_uint<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L601"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">align_backward_uint :: <span class="keyword-type">proc</span>(ptr, align: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>) -> <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Align uint backwards.</p>
<p>This procedure returns the previous address before <code>ptr</code>, that is located on the
alignment boundary specified by <code>align</code>. If <code>ptr</code> is already aligned to <code>align</code>
bytes, <code>ptr</code> is returned.</p>
<p>The specified alignment must be a power of 2.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="align_backward_uintptr"><span><a class="doc-id-link" href="#align_backward_uintptr">align_backward_uintptr<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L558"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">align_backward_uintptr :: <span class="keyword-type">proc</span>(ptr, align: <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>) -> <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Align uintptr backwards.</p>
<p>This procedure returns the previous address before <code>ptr</code>, that is located on the
alignment boundary specified by <code>align</code>. If <code>ptr</code> is already aligned to <code>align</code>
bytes, <code>ptr</code> is returned.</p>
<p>The specified alignment must be a power of 2.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="align_formula"><span><a class="doc-id-link" href="#align_formula">align_formula<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L662"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">align_formula :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (size, align: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>General-purpose align formula.</p>
<p>This procedure is equivalent to <code>align_forward</code>, but it does not require the
alignment to be a power of two.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="align_forward"><span><a class="doc-id-link" href="#align_forward">align_forward<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L516"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">align_forward :: <span class="keyword-type">proc</span>(ptr: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, align: <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>) -> <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Align pointer forward.</p>
<p>This procedure returns the next address after <code>ptr</code>, that is located on the
alignment boundary specified by <code>align</code>. If <code>ptr</code> is already aligned to <code>align</code>
bytes, <code>ptr</code> is returned.</p>
<p>The specified alignment must be a power of 2.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="align_forward_int"><span><a class="doc-id-link" href="#align_forward_int">align_forward_int<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L530"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">align_forward_int :: <span class="keyword-type">proc</span>(ptr, align: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Align int forward.</p>
<p>This procedure returns the next address after <code>ptr</code>, that is located on the
alignment boundary specified by <code>align</code>. If <code>ptr</code> is already aligned to <code>align</code>
bytes, <code>ptr</code> is returned.</p>
<p>The specified alignment must be a power of 2.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="align_forward_uint"><span><a class="doc-id-link" href="#align_forward_uint">align_forward_uint<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L544"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">align_forward_uint :: <span class="keyword-type">proc</span>(ptr, align: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>) -> <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Align uint forward.</p>
<p>This procedure returns the next address after <code>ptr</code>, that is located on the
alignment boundary specified by <code>align</code>. If <code>ptr</code> is already aligned to <code>align</code>
bytes, <code>ptr</code> is returned.</p>
<p>The specified alignment must be a power of 2.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="align_forward_uintptr"><span><a class="doc-id-link" href="#align_forward_uintptr">align_forward_uintptr<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L501"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">align_forward_uintptr :: <span class="keyword-type">proc</span>(ptr, align: <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>) -> <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Align uintptr forward.</p>
<p>This procedure returns the next address after <code>ptr</code>, that is located on the
alignment boundary specified by <code>align</code>. If <code>ptr</code> is already aligned to <code>align</code>
bytes, <code>ptr</code> is returned.</p>
<p>The specified alignment must be a power of 2.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="alloc"><span><a class="doc-id-link" href="#alloc">alloc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L293"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">alloc :: <span class="keyword-type">proc</span>(size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory.</p>
<p>This function allocates <code>size</code> bytes of memory, aligned to a boundary specified
by <code>alignment</code> using the allocator specified by <code>allocator</code>.</p>
<p>If the <code>size</code> parameter is <code>0</code>, the operation is a no-op.</p>
<p><b>Inputs</b>:
<span class="doc-list"><code>size</code>: The desired size of the allocated memory region.</span>
<span class="doc-list"><code>alignment</code>: The desired alignment of the allocated memory region.</span>
<span class="doc-list"><code>allocator</code>: The allocator to allocate from.</span></p>
<p><b>Returns</b>:
1. Pointer to the allocated memory, or <code>nil</code> if allocation failed.
2. Error, if the allocation failed.</p>
<p><b>Errors</b>:
<span class="doc-list"><code>None</code>: If no error occurred.</span>
<span class="doc-list"><code>Out_Of_Memory</code>: Occurs when the allocator runs out of space in any of its</span></p>
<pre>backing buffers, the backing allocator has ran out of space, or an operating
system failure occurred.
</pre>
<p><span class="doc-list"><code>Invalid_Argument</code>: If the supplied <code>size</code> is negative, alignment is not a</span></p>
<pre>power of two.
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="alloc_bytes"><span><a class="doc-id-link" href="#alloc_bytes">alloc_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L327"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">alloc_bytes :: <span class="keyword-type">proc</span>(size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory.</p>
<p>This function allocates <code>size</code> bytes of memory, aligned to a boundary specified
by <code>alignment</code> using the allocator specified by <code>allocator</code>.</p>
<p><b>Inputs</b>:
<span class="doc-list"><code>size</code>: The desired size of the allocated memory region.</span>
<span class="doc-list"><code>alignment</code>: The desired alignment of the allocated memory region.</span>
<span class="doc-list"><code>allocator</code>: The allocator to allocate from.</span></p>
<p><b>Returns</b>:
1. Slice of the allocated memory region, or <code>nil</code> if allocation failed.
2. Error, if the allocation failed.</p>
<p><b>Errors</b>:
<span class="doc-list"><code>None</code>: If no error occurred.</span>
<span class="doc-list"><code>Out_Of_Memory</code>: Occurs when the allocator runs out of space in any of its</span></p>
<pre>backing buffers, the backing allocator has ran out of space, or an operating
system failure occurred.
</pre>
<p><span class="doc-list"><code>Invalid_Argument</code>: If the supplied <code>size</code> is negative, alignment is not a</span></p>
<pre>power of two.
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="alloc_bytes_non_zeroed"><span><a class="doc-id-link" href="#alloc_bytes_non_zeroed">alloc_bytes_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L361"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">alloc_bytes_non_zeroed :: <span class="keyword-type">proc</span>(size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate non-zeroed memory.</p>
<p>This function allocates <code>size</code> bytes of memory, aligned to a boundary specified
by <code>alignment</code> using the allocator specified by <code>allocator</code>. This procedure
does not explicitly zero-initialize allocated memory region.</p>
<p><b>Inputs</b>:
<span class="doc-list"><code>size</code>: The desired size of the allocated memory region.</span>
<span class="doc-list"><code>alignment</code>: The desired alignment of the allocated memory region.</span>
<span class="doc-list"><code>allocator</code>: The allocator to allocate from.</span></p>
<p><b>Returns</b>:
1. Slice of the allocated memory region, or <code>nil</code> if allocation failed.
2. Error, if the allocation failed.</p>
<p><b>Errors</b>:
<span class="doc-list"><code>None</code>: If no error occurred.</span>
<span class="doc-list"><code>Out_Of_Memory</code>: Occurs when the allocator runs out of space in any of its</span></p>
<pre>backing buffers, the backing allocator has ran out of space, or an operating
system failure occurred.
</pre>
<p><span class="doc-list"><code>Invalid_Argument</code>: If the supplied <code>size</code> is negative, alignment is not a</span></p>
<pre>power of two.
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="any_to_bytes"><span><a class="doc-id-link" href="#any_to_bytes">any_to_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L393"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">any_to_bytes :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (val: <a href="/base/builtin#any"><span class="doc-builtin">any</span></a>) -> []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Obtain the slice, pointing to the contents of <code>any</code>.</p>
<p>This procedure returns the slice, pointing to the contents of the specified
value of the <code>any</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="arena_alloc"><span><a class="doc-id-link" href="#arena_alloc">arena_alloc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L202"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">arena_alloc :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Arena">Arena</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from an arena.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned on a boundary specified
by <code>alignment</code> from an arena <code>a</code>. The allocated memory is zero-initialized.
This procedure returns a pointer to the newly allocated memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="arena_alloc_bytes"><span><a class="doc-id-link" href="#arena_alloc_bytes">arena_alloc_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L220"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">arena_alloc_bytes :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Arena">Arena</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from an arena.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned on a boundary specified
by <code>alignment</code> from an arena <code>a</code>. The allocated memory is zero-initialized.
This procedure returns a slice of the newly allocated memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="arena_alloc_bytes_non_zeroed"><span><a class="doc-id-link" href="#arena_alloc_bytes_non_zeroed">arena_alloc_bytes_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L261"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">arena_alloc_bytes_non_zeroed :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Arena">Arena</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate non-initialized memory from an arena.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned on a boundary specified
by <code>alignment</code> from an arena <code>a</code>. The allocated memory is not explicitly
zero-initialized. This procedure returns a slice of the newly allocated
memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="arena_alloc_non_zeroed"><span><a class="doc-id-link" href="#arena_alloc_non_zeroed">arena_alloc_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L242"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">arena_alloc_non_zeroed :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Arena">Arena</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate non-initialized memory from an arena.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned on a boundary specified
by <code>alignment</code> from an arena <code>a</code>. The allocated memory is not explicitly
zero-initialized. This procedure returns a pointer to the newly allocated
memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="arena_allocator"><span><a class="doc-id-link" href="#arena_allocator">arena_allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L173"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">arena_allocator :: <span class="keyword-type">proc</span>(arena: ^<a class="code-typename" href="/core/mem/#Arena">Arena</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Arena allocator.</p>
<p>The arena allocator (also known as a linear allocator, bump allocator,
region allocator) is an allocator that uses a single backing buffer for
allocations.</p>
<p>The buffer is used contiguously, from start to end. Each subsequent allocation
occupies the next adjacent region of memory in the buffer. Since the arena
allocator does not keep track of any metadata associated with the allocations
and their locations, it is impossible to free individual allocations.</p>
<p>The arena allocator can be used for temporary allocations in frame-based memory
management. Games are one example of such applications. A global arena can be
used for any temporary memory allocations, and at the end of each frame all
temporary allocations are freed. Since no temporary object is going to live
longer than a frame, no lifetimes are violated.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="arena_allocator_proc"><span><a class="doc-id-link" href="#arena_allocator_proc">arena_allocator_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L292"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">arena_allocator_proc :: <span class="keyword-type">proc</span>(
	allocator_data:  <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	mode:            runtime.<a class="code-typename" href="/base/runtime/#Allocator_Mode">Allocator_Mode</a>, 
	size, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	old_memory:      <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:        <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="arena_free_all"><span><a class="doc-id-link" href="#arena_free_all">arena_free_all<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L287"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">arena_free_all :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Arena">Arena</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free all memory back to the arena allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="arena_init"><span><a class="doc-id-link" href="#arena_init">arena_init<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L186"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">arena_init :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Arena">Arena</a>, data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initialize an arena.</p>
<p>This procedure initializes the arena <code>a</code> with memory region <code>data</code> as its
backing buffer.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="begin_arena_temp_memory"><span><a class="doc-id-link" href="#begin_arena_temp_memory">begin_arena_temp_memory<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L350"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">begin_arena_temp_memory :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Arena">Arena</a>) -> <a class="code-typename" href="/core/mem/#Arena_Temp_Memory">Arena_Temp_Memory</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Start a temporary memory region.</p>
<p>This procedure creates a temporary memory region. After a temporary memory
region is created, all allocations are said to be <i>inside</i> the temporary memory
region, until <code>end_arena_temp_memory</code> is called.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="buddy_allocator"><span><a class="doc-id-link" href="#buddy_allocator">buddy_allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2214"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">buddy_allocator :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/mem/#Buddy_Allocator">Buddy_Allocator</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Buddy allocator.</p>
<p>The buddy allocator is a type of allocator that splits the backing buffer into
multiple regions called buddy blocks. Initially, the allocator only has one
block with the size of the backing buffer. Upon each allocation, the allocator
finds the smallest block that can fit the size of requested memory region, and
splits the block according to the allocation size. If no block can be found,
the contiguous free blocks are coalesced and the search is performed again.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="buddy_allocator_alloc"><span><a class="doc-id-link" href="#buddy_allocator_alloc">buddy_allocator_alloc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2275"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">buddy_allocator_alloc :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/mem/#Buddy_Allocator">Buddy_Allocator</a>, size: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a buddy allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory. The allocation's alignment is
fixed to the <code>alignment</code> specified at initialization. The allocated memory
region is zero-initialized. This procedure returns a pointer to the allocated
memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="buddy_allocator_alloc_bytes"><span><a class="doc-id-link" href="#buddy_allocator_alloc_bytes">buddy_allocator_alloc_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2289"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">buddy_allocator_alloc_bytes :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/mem/#Buddy_Allocator">Buddy_Allocator</a>, size: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a buddy allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory. The allocation's alignment is
fixed to the <code>alignment</code> specified at initialization. The allocated memory
region is zero-initialized. This procedure returns a slice of the allocated
memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="buddy_allocator_alloc_bytes_non_zeroed"><span><a class="doc-id-link" href="#buddy_allocator_alloc_bytes_non_zeroed">buddy_allocator_alloc_bytes_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2320"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">buddy_allocator_alloc_bytes_non_zeroed :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/mem/#Buddy_Allocator">Buddy_Allocator</a>, size: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate non-initialized memory from a buddy allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory. The allocation's alignment is
fixed to the <code>alignment</code> specified at initialization. The allocated memory
region is not explicitly zero-initialized. This procedure returns a slice of
the allocated memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="buddy_allocator_alloc_non_zeroed"><span><a class="doc-id-link" href="#buddy_allocator_alloc_non_zeroed">buddy_allocator_alloc_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2306"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">buddy_allocator_alloc_non_zeroed :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/mem/#Buddy_Allocator">Buddy_Allocator</a>, size: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate non-initialized memory from a buddy allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory. The allocation's alignment is
fixed to the <code>alignment</code> specified at initialization. The allocated memory
region is not explicitly zero-initialized. This procedure returns a pointer to
the allocated memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="buddy_allocator_free"><span><a class="doc-id-link" href="#buddy_allocator_free">buddy_allocator_free<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2351"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">buddy_allocator_free :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/mem/#Buddy_Allocator">Buddy_Allocator</a>, ptr: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free memory back to the buddy allocator.</p>
<p>This procedure frees the memory region allocated at pointer <code>ptr</code>.</p>
<p>If <code>ptr</code> is not the latest allocation and is not a leaked allocation, this
operation is a no-op.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="buddy_allocator_free_all"><span><a class="doc-id-link" href="#buddy_allocator_free_all">buddy_allocator_free_all<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2368"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">buddy_allocator_free_all :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/mem/#Buddy_Allocator">Buddy_Allocator</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free all memory back to the buddy allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="buddy_allocator_init"><span><a class="doc-id-link" href="#buddy_allocator_init">buddy_allocator_init<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2230"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">buddy_allocator_init :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/mem/#Buddy_Allocator">Buddy_Allocator</a>, data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, alignment: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initialize a buddy allocator.</p>
<p>This procedure initializes the buddy allocator <code>b</code> with a backing buffer <code>data</code>
and block alignment specified by <code>alignment</code>.</p>
<p><code>alignment</code> may be any power of two, but the backing buffer must be aligned to
at least <code>size_of(Buddy_Block)</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="buddy_allocator_proc"><span><a class="doc-id-link" href="#buddy_allocator_proc">buddy_allocator_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2377"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">buddy_allocator_proc :: <span class="keyword-type">proc</span>(
	allocator_data:  <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	mode:            runtime.<a class="code-typename" href="/base/runtime/#Allocator_Mode">Allocator_Mode</a>, 
	size, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	old_memory:      <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:        <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="buddy_block_coalescence"><span><a class="doc-id-link" href="#buddy_block_coalescence">buddy_block_coalescence<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2100"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">buddy_block_coalescence :: <span class="keyword-type">proc</span>(head, tail: ^<a class="code-typename" href="/core/mem/#Buddy_Block">Buddy_Block</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Coalesce contiguous blocks in a range of blocks into one.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="buddy_block_find_best"><span><a class="doc-id-link" href="#buddy_block_find_best">buddy_block_find_best<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2137"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">buddy_block_find_best :: <span class="keyword-type">proc</span>(head, tail: ^<a class="code-typename" href="/core/mem/#Buddy_Block">Buddy_Block</a>, size: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>) -> ^<a class="code-typename" href="/core/mem/#Buddy_Block">Buddy_Block</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Find the best block for storing a given size in a range of blocks.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="buddy_block_next"><span><a class="doc-id-link" href="#buddy_block_next">buddy_block_next<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2069"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">buddy_block_next :: <span class="keyword-type">proc</span>(block: ^<a class="code-typename" href="/core/mem/#Buddy_Block">Buddy_Block</a>) -> ^<a class="code-typename" href="/core/mem/#Buddy_Block">Buddy_Block</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Obtain the next buddy block.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="buddy_block_size_required"><span><a class="doc-id-link" href="#buddy_block_size_required">buddy_block_size_required<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2253"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">buddy_block_size_required :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/mem/#Buddy_Allocator">Buddy_Allocator</a>, size: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>) -> <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Get required block size to fit in the allocation as well as the alignment padding.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="buddy_block_split"><span><a class="doc-id-link" href="#buddy_block_split">buddy_block_split<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2077"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">buddy_block_split :: <span class="keyword-type">proc</span>(block: ^<a class="code-typename" href="/core/mem/#Buddy_Block">Buddy_Block</a>, size: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>) -> ^<a class="code-typename" href="/core/mem/#Buddy_Block">Buddy_Block</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Split the block into two, by truncating the given block to a given size.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="buffer_from_slice"><span><a class="doc-id-link" href="#buffer_from_slice">buffer_from_slice<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L452"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">buffer_from_slice :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (backing: $T/[]$E) -> [<span class="keyword">dynamic</span>]$E {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Create a dynamic array from slice.</p>
<p>This procedure creates a dynamic array, using slice <code>backing</code> as the backing
buffer for the dynamic array. The resulting dynamic array can not grow beyond
the size of the specified slice.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="byte_slice"><span><a class="doc-id-link" href="#byte_slice">byte_slice<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L371"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">byte_slice :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (data: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Construct a byte slice from raw pointer and length.</p>
<p>This procedure creates a byte slice, that points to <code>len</code> amount of bytes
located at an address specified by <code>data</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="calc_padding_with_header"><span><a class="doc-id-link" href="#calc_padding_with_header">calc_padding_with_header<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L690"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">calc_padding_with_header :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (ptr: <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>, align: <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>, header_size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Calculate the padding for header preceding aligned data.</p>
<p>This procedure returns the padding, following the specified pointer <code>ptr</code> that
will be able to fit in a header of the size <code>header_size</code>, immediately
preceding the memory region, aligned on a boundary specified by <code>align</code>. See
the following diagram for a visual representation.</p>
<p>        header size</p>
<pre>    |&lt;------&gt;|
+---+--------+------------- - - -
    | HEADER |  DATA...
+---+--------+------------- - - -
^            ^
|&lt;----------&gt;|
|  padding   |
ptr          aligned ptr

</pre>
<p>The function takes in <code>ptr</code> and <code>header_size</code>, as well as the required
alignment for <code>DATA</code>. The return value of the function is the padding between
<code>ptr</code> and <code>aligned_ptr</code> that will be able to fit the header.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="check_zero"><span><a class="doc-id-link" href="#check_zero">check_zero<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L267"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">check_zero :: <span class="keyword-type">proc</span>(data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Check if the memory range defined by a slice is zero-filled.</p>
<p>This procedure checks whether every byte, pointed to by the slice, specified
by the parameter <code>data</code>, is zero. If all bytes of the slice are zero, this
procedure returns <code>true</code>. Otherwise this procedure returns <code>false</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="check_zero_ptr"><span><a class="doc-id-link" href="#check_zero_ptr">check_zero_ptr<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L279"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">check_zero_ptr :: <span class="keyword-type">proc</span>(ptr: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Check if the memory range defined defined by a pointer is zero-filled.</p>
<p>This procedure checks whether each of the <code>len</code> bytes, starting at address
<code>ptr</code> is zero. If all bytes of this range are zero, this procedure returns
<code>true</code>. Otherwise this procedure returns <code>false</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="compare"><span><a class="doc-id-link" href="#compare">compare<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L185"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">compare :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (a, b: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>) -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Compare two memory ranges defined by slices.</p>
<p>This procedure performs a byte-by-byte comparison between memory ranges
specified by slices <code>a</code> and <code>b</code>, and returns a value, specifying their relative
ordering.</p>
<p>If the return value is:
<span class="doc-list">Equal to <code>-1</code>, then <code>a</code> is "smaller" than <code>b</code>.</span>
<span class="doc-list">Equal to <code>+1</code>, then <code>a</code> is "bigger"  than <code>b</code>.</span>
<span class="doc-list">Equal to <code>0</code>, then <code>a</code> and <code>b</code> are equal.</span></p>
<p>The comparison is performed as follows:
1. Each byte, upto <code>min(len(a), len(b))</code> bytes is compared between <code>a</code> and <code>b</code>.</p>
<pre>- If the byte in slice `a` is smaller than a byte in slice `b`, then comparison
  stops and this procedure returns `-1`.
- If the byte in slice `a` is bigger than a byte in slice `b`, then comparison
  stops and this procedure returns `+1`.
- Otherwise the comparison continues until `min(len(a), len(b))` are compared.
</pre>
<p>2. If all the bytes in the range are equal, then the lengths of the slices are compared.</p>
<pre>- If the length of slice `a` is smaller than the length of slice `b`, then `-1` is returned.
- If the length of slice `b` is smaller than the length of slice `b`, then `+1` is returned.
- Otherwise `0` is returned.
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="compare_byte_ptrs"><span><a class="doc-id-link" href="#compare_byte_ptrs">compare_byte_ptrs<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L217"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">compare_byte_ptrs :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (a, b: ^<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Compare two memory ranges defined by byte pointers.</p>
<p>This procedure performs a byte-by-byte comparison between memory ranges of size
<code>n</code> located at addresses <code>a</code> and <code>b</code>, and returns a value, specifying their relative
ordering.</p>
<p>If the return value is:
<span class="doc-list">Equal to <code>-1</code>, then <code>a</code> is "smaller" than <code>b</code>.</span>
<span class="doc-list">Equal to <code>+1</code>, then <code>a</code> is "bigger"  than <code>b</code>.</span>
<span class="doc-list">Equal to <code>0</code>, then <code>a</code> and <code>b</code> are equal.</span></p>
<p>The comparison is performed as follows:
1. Each byte, upto <code>n</code> bytes is compared between <code>a</code> and <code>b</code>.</p>
<pre>- If the byte in `a` is smaller than a byte in `b`, then comparison stops
  and this procedure returns `-1`.
- If the byte in `a` is bigger than a byte in `b`, then comparison stops
  and this procedure returns `+1`.
- Otherwise the comparison continues until `n` bytes are compared.
</pre>
<p>2. If all the bytes in the range are equal, this procedure returns <code>0</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="compare_ptrs"><span><a class="doc-id-link" href="#compare_ptrs">compare_ptrs<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L243"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">compare_ptrs :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (a, b: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Compare two memory ranges defined by pointers.</p>
<p>This procedure performs a byte-by-byte comparison between memory ranges of size
<code>n</code> located at addresses <code>a</code> and <code>b</code>, and returns a value, specifying their relative
ordering.</p>
<p>If the return value is:
<span class="doc-list">Equal to <code>-1</code>, then <code>a</code> is "smaller" than <code>b</code>.</span>
<span class="doc-list">Equal to <code>+1</code>, then <code>a</code> is "bigger"  than <code>b</code>.</span>
<span class="doc-list">Equal to <code>0</code>, then <code>a</code> and <code>b</code> are equal.</span></p>
<p>The comparison is performed as follows:
1. Each byte, upto <code>n</code> bytes is compared between <code>a</code> and <code>b</code>.</p>
<pre>- If the byte in `a` is smaller than a byte in `b`, then comparison stops
  and this procedure returns `-1`.
- If the byte in `a` is bigger than a byte in `b`, then comparison stops
  and this procedure returns `+1`.
- Otherwise the comparison continues until `n` bytes are compared.
</pre>
<p>2. If all the bytes in the range are equal, this procedure returns <code>0</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="compat_allocator"><span><a class="doc-id-link" href="#compat_allocator">compat_allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2440"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">compat_allocator :: <span class="keyword-type">proc</span>(rra: ^<a class="code-typename" href="/core/mem/#Compat_Allocator">Compat_Allocator</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a> {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="compat_allocator_init"><span><a class="doc-id-link" href="#compat_allocator_init">compat_allocator_init<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2435"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">compat_allocator_init :: <span class="keyword-type">proc</span>(rra: ^<a class="code-typename" href="/core/mem/#Compat_Allocator">Compat_Allocator</a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="compat_allocator_proc"><span><a class="doc-id-link" href="#compat_allocator_proc">compat_allocator_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2447"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">compat_allocator_proc :: <span class="keyword-type">proc</span>(
	allocator_data:  <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	mode:            runtime.<a class="code-typename" href="/base/runtime/#Allocator_Mode">Allocator_Mode</a>, 
	size, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	old_memory:      <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:        <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	location := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> (data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="context_from_allocator"><span><a class="doc-id-link" href="#context_from_allocator">context_from_allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L612"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">context_from_allocator :: <span class="keyword-type">proc</span>(a: runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Context">Context</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Create a context with a given allocator.</p>
<p>This procedure returns a copy of the current context with the allocator replaced
by the allocator <code>a</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="copy"><span><a class="doc-id-link" href="#copy">copy<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L138"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">copy :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (dst, src: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Copy bytes from one memory range to another.</p>
<p>This procedure copies <code>len</code> bytes of data, from the memory range pointed to by
the <code>src</code> pointer into the memory range pointed to by the <code>dst</code> pointer, and
returns the <code>dst</code> pointer.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="copy_non_overlapping"><span><a class="doc-id-link" href="#copy_non_overlapping">copy_non_overlapping<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L155"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">copy_non_overlapping :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (dst, src: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Copy bytes between two non-overlapping memory ranges.</p>
<p>This procedure copies <code>len</code> bytes of data, from the memory range pointed to by
the <code>src</code> pointer into the memory range pointed to by the <code>dst</code> pointer, and
returns the <code>dst</code> pointer.</p>
<p>This is a slightly more optimized version of the <code>copy</code> procedure that requires
that memory ranges specified by the parameters to this procedure are not
overlapping. If the memory ranges specified by <code>dst</code> and <code>src</code> pointers overlap,
the behavior of this function may be unpredictable.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="default_resize_align"><span><a class="doc-id-link" href="#default_resize_align">default_resize_align<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L1133"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">default_resize_align :: <span class="keyword-type">proc</span>(
	old_memory: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:   <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	new_size:   <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	alignment:  <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	allocator := <a href="/base/runtime/#Context">context.allocator</a>, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> (res: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Default resize procedure.</p>
<p>When allocator does not support resize operation, but supports <code>.Alloc</code> and
<code>.Free</code>, this procedure is used to implement allocator's default behavior on
resize.</p>
<p>The behavior of the function is as follows:</p>
<p><span class="doc-list">If <code>new_size</code> is <code>0</code>, the function acts like <code>free()</code>, freeing the memory</span></p>
<pre>region of `old_size` bytes located at `old_memory`.
</pre>
<p><span class="doc-list">If <code>old_memory</code> is <code>nil</code>, the function acts like <code>alloc()</code>, allocating</span></p>
<pre>`new_size` bytes of memory aligned on a boundary specified by `alignment`.
</pre>
<p><span class="doc-list">Otherwise, a new memory region of size <code>new_size</code> is allocated, then the</span></p>
<pre>data from the old memory region is copied and the old memory region is
freed.
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="default_resize_bytes_align"><span><a class="doc-id-link" href="#default_resize_bytes_align">default_resize_bytes_align<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L1202"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">default_resize_bytes_align :: <span class="keyword-type">proc</span>(old_data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, new_size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Default resize procedure.</p>
<p>When allocator does not support resize operation, but supports <code>.Alloc</code> and
<code>.Free</code>, this procedure is used to implement allocator's default behavior on
resize.</p>
<p>The behavior of the function is as follows:</p>
<p><span class="doc-list">If <code>new_size</code> is <code>0</code>, the function acts like <code>free()</code>, freeing the memory</span></p>
<pre>region specified by `old_data`.
</pre>
<p><span class="doc-list">If <code>old_data</code> is <code>nil</code>, the function acts like <code>alloc()</code>, allocating</span></p>
<pre>`new_size` bytes of memory aligned on a boundary specified by `alignment`.
</pre>
<p><span class="doc-list">Otherwise, a new memory region of size <code>new_size</code> is allocated, then the</span></p>
<pre>data from the old memory region is copied and the old memory region is
freed.
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="default_resize_bytes_align_non_zeroed"><span><a class="doc-id-link" href="#default_resize_bytes_align_non_zeroed">default_resize_bytes_align_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L1174"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">default_resize_bytes_align_non_zeroed :: <span class="keyword-type">proc</span>(old_data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, new_size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Default resize procedure.</p>
<p>When allocator does not support resize operation, but supports
<code>.Alloc_Non_Zeroed</code> and <code>.Free</code>, this procedure is used to implement allocator's
default behavior on resize.</p>
<p>Unlike <code>default_resize_align</code> no new memory is being explicitly
zero-initialized.</p>
<p>The behavior of the function is as follows:</p>
<p><span class="doc-list">If <code>new_size</code> is <code>0</code>, the function acts like <code>free()</code>, freeing the memory</span></p>
<pre>region of `old_size` bytes located at `old_memory`.
</pre>
<p><span class="doc-list">If <code>old_memory</code> is <code>nil</code>, the function acts like <code>alloc()</code>, allocating</span></p>
<pre>`new_size` bytes of memory aligned on a boundary specified by `alignment`.
</pre>
<p><span class="doc-list">Otherwise, a new memory region of size <code>new_size</code> is allocated, then the</span></p>
<pre>data from the old memory region is copied and the old memory region is
freed.
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="delete_cstring"><span><a class="doc-id-link" href="#delete_cstring">delete_cstring<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L749"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">delete_cstring :: <span class="keyword-type">proc</span>(str: <a href="/base/builtin#cstring"><span class="doc-builtin">cstring</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free a cstring.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="delete_dynamic_array"><span><a class="doc-id-link" href="#delete_dynamic_array">delete_dynamic_array<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L760"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">delete_dynamic_array :: <span class="keyword-type">proc</span>(array: [<span class="keyword">dynamic</span>]$E, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free a dynamic array.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="delete_map"><span><a class="doc-id-link" href="#delete_map">delete_map<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L781"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">delete_map :: <span class="keyword-type">proc</span>(m: $T/<span class="keyword-type">map</span>[$K]$V, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free a map.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="delete_slice"><span><a class="doc-id-link" href="#delete_slice">delete_slice<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L770"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">delete_slice :: <span class="keyword-type">proc</span>(array: $T/[]$E, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free a slice.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="delete_soa_dynamic_array"><span><a class="doc-id-link" href="#delete_soa_dynamic_array">delete_soa_dynamic_array<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L802"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">delete_soa_dynamic_array :: <span class="keyword-type">proc</span>(array: $T/<span class="directive">#soa</span>[<span class="keyword">dynamic</span>]$E, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free an SoA dynamic array.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="delete_soa_slice"><span><a class="doc-id-link" href="#delete_soa_slice">delete_soa_slice<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L791"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">delete_soa_slice :: <span class="keyword-type">proc</span>(array: $T/<span class="directive">#soa</span>[]$E, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free an SoA slice.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="delete_string"><span><a class="doc-id-link" href="#delete_string">delete_string<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L738"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">delete_string :: <span class="keyword-type">proc</span>(str: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free a string.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_arena_alloc"><span><a class="doc-id-link" href="#dynamic_arena_alloc">dynamic_arena_alloc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1776"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_arena_alloc :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Dynamic_Arena">Dynamic_Arena</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a dynamic arena.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned on a boundary specified
by <code>alignment</code> from a dynamic arena <code>a</code>. The allocated memory is
zero-initialized. This procedure returns a pointer to the newly allocated memory
region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_arena_alloc_bytes"><span><a class="doc-id-link" href="#dynamic_arena_alloc_bytes">dynamic_arena_alloc_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1790"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_arena_alloc_bytes :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Dynamic_Arena">Dynamic_Arena</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a dynamic arena.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned on a boundary specified
by <code>alignment</code> from a dynamic arena <code>a</code>. The allocated memory is
zero-initialized. This procedure returns a slice of the newly allocated memory
region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_arena_alloc_bytes_non_zeroed"><span><a class="doc-id-link" href="#dynamic_arena_alloc_bytes_non_zeroed">dynamic_arena_alloc_bytes_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1821"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_arena_alloc_bytes_non_zeroed :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Dynamic_Arena">Dynamic_Arena</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate non-initialized memory from a dynamic arena.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned on a boundary specified
by <code>alignment</code> from a dynamic arena <code>a</code>. The allocated memory is not explicitly
zero-initialized. This procedure returns a slice of the newly allocated
memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_arena_alloc_non_zeroed"><span><a class="doc-id-link" href="#dynamic_arena_alloc_non_zeroed">dynamic_arena_alloc_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1807"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_arena_alloc_non_zeroed :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Dynamic_Arena">Dynamic_Arena</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate non-initialized memory from a dynamic arena.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned on a boundary specified
by <code>alignment</code> from a dynamic arena <code>a</code>. The allocated memory is not explicitly
zero-initialized. This procedure returns a pointer to the newly allocated
memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_arena_allocator"><span><a class="doc-id-link" href="#dynamic_arena_allocator">dynamic_arena_allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1716"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_arena_allocator :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Dynamic_Arena">Dynamic_Arena</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Dynamic arena allocator.</p>
<p>The dynamic arena allocator uses blocks of a specific size, allocated on-demand
using the block allocator. This allocator acts similarly to <code>Arena</code>. All
allocations in a block happen contiguously, from start to end. If an allocation
does not fit into the remaining space of the block and its size is smaller
than the specified out-band size, a new block is allocated using the
<code>block_allocator</code> and the allocation is performed from a newly-allocated block.</p>
<p>If an allocation is larger than the specified out-band size, a new block
is allocated such that the allocation fits into this new block. This is referred
to as an <i>out-band allocation</i>. The out-band blocks are kept separately from
normal blocks.</p>
<p>Just like <code>Arena</code>, the dynamic arena does not support freeing of individual
objects.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_arena_allocator_proc"><span><a class="doc-id-link" href="#dynamic_arena_allocator_proc">dynamic_arena_allocator_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2015"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_arena_allocator_proc :: <span class="keyword-type">proc</span>(
	allocator_data:  <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	mode:            runtime.<a class="code-typename" href="/base/runtime/#Allocator_Mode">Allocator_Mode</a>, 
	size, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	old_memory:      <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:        <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="dynamic_arena_destroy"><span><a class="doc-id-link" href="#dynamic_arena_destroy">dynamic_arena_destroy<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1729"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_arena_destroy :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Dynamic_Arena">Dynamic_Arena</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Destroy a dynamic arena.</p>
<p>This procedure frees all allocations made on a dynamic arena, including the
unused blocks, as well as the arrays for storing blocks.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_arena_free_all"><span><a class="doc-id-link" href="#dynamic_arena_free_all">dynamic_arena_free_all<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1882"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_arena_free_all :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Dynamic_Arena">Dynamic_Arena</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free all memory back to the dynamic arena allocator.</p>
<p>This procedure frees all the allocations owned by the dynamic arena, including
the unused blocks.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_arena_init"><span><a class="doc-id-link" href="#dynamic_arena_init">dynamic_arena_init<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1680"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_arena_init :: <span class="keyword-type">proc</span>(
	pool:            ^<a class="code-typename" href="/core/mem/#Dynamic_Arena">Dynamic_Arena</a>, 
	block_allocator := <a href="/base/runtime/#Context">context.allocator</a>, 
	array_allocator := <a href="/base/runtime/#Context">context.allocator</a>, 
	block_size:      <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DYNAMIC_ARENA_BLOCK_SIZE_DEFAULT, 
	out_band_size:   <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DYNAMIC_ARENA_OUT_OF_BAND_SIZE_DEFAULT, 
	alignment:       <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, 
) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initialize a dynamic arena.</p>
<p>This procedure initializes a dynamic arena. The specified <code>block_allocator</code>
will be used to allocate arena blocks, and <code>array_allocator</code> to allocate
arrays of blocks and out-band blocks. The blocks have the default size of
<code>block_size</code> and out-band threshold will be <code>out_band_size</code>. All allocations
will be aligned to a boundary specified by <code>alignment</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_arena_reset"><span><a class="doc-id-link" href="#dynamic_arena_reset">dynamic_arena_reset<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1858"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_arena_reset :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Dynamic_Arena">Dynamic_Arena</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reset a dynamic arena allocator.</p>
<p>This procedure frees all the allocations owned by the dynamic arena, excluding
the unused blocks.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_arena_resize"><span><a class="doc-id-link" href="#dynamic_arena_resize">dynamic_arena_resize<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1905"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_arena_resize :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Dynamic_Arena">Dynamic_Arena</a>, old_memory: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, old_size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by a dynamic arena allocator.</p>
<p>This procedure resizes a memory region defined by its location <code>old_memory</code>
and its size <code>old_size</code> to have a size <code>size</code> and alignment <code>alignment</code>. The
newly allocated memory, if any, is zero-initialized.</p>
<p>If <code>old_memory</code> is <code>nil</code>, this procedure acts just like <code>dynamic_arena_alloc()</code>,
allocating a memory region <code>size</code> bytes in size, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>This procedure returns the pointer to the resized memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_arena_resize_bytes"><span><a class="doc-id-link" href="#dynamic_arena_resize_bytes">dynamic_arena_resize_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1930"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_arena_resize_bytes :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Dynamic_Arena">Dynamic_Arena</a>, old_data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by a dynamic arena allocator.</p>
<p>This procedure resizes a memory region specified by <code>old_data</code> to have a size
<code>size</code> and alignment <code>alignment</code>. The newly allocated memory, if any, is
zero-initialized.</p>
<p>If <code>old_memory</code> is <code>nil</code>, this procedure acts just like <code>dynamic_arena_alloc()</code>,
allocating a memory region <code>size</code> bytes in size, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>This procedure returns the slice of the resized memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_arena_resize_bytes_non_zeroed"><span><a class="doc-id-link" href="#dynamic_arena_resize_bytes_non_zeroed">dynamic_arena_resize_bytes_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1990"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_arena_resize_bytes_non_zeroed :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Dynamic_Arena">Dynamic_Arena</a>, old_data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by a dynamic arena allocator, without zero-initialization.</p>
<p>This procedure resizes a memory region specified by <code>old_data</code> to have a size
<code>size</code> and alignment <code>alignment</code>. The newly allocated memory, if any, is not
explicitly zero-initialized.</p>
<p>If <code>old_memory</code> is <code>nil</code>, this procedure acts just like <code>dynamic_arena_alloc()</code>,
allocating a memory region <code>size</code> bytes in size, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>This procedure returns the slice of the resized memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_arena_resize_non_zeroed"><span><a class="doc-id-link" href="#dynamic_arena_resize_non_zeroed">dynamic_arena_resize_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1965"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_arena_resize_non_zeroed :: <span class="keyword-type">proc</span>(a: ^<a class="code-typename" href="/core/mem/#Dynamic_Arena">Dynamic_Arena</a>, old_memory: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, old_size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by a dynamic arena allocator, without zero-initialization.</p>
<p>This procedure resizes a memory region defined by its location <code>old_memory</code>
and its size <code>old_size</code> to have a size <code>size</code> and alignment <code>alignment</code>. The
newly allocated memory, if any, is not explicitly zero-initialized.</p>
<p>If <code>old_memory</code> is <code>nil</code>, this procedure acts just like <code>dynamic_arena_alloc()</code>,
allocating a memory region <code>size</code> bytes in size, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>This procedure returns the pointer to the resized memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_pool_alloc"><span><a class="doc-id-link" href="#dynamic_pool_alloc">dynamic_pool_alloc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1776"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_pool_alloc :: <a class="code-procedure" href="/core/mem/#dynamic_arena_alloc">dynamic_arena_alloc</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a dynamic arena.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned on a boundary specified
by <code>alignment</code> from a dynamic arena <code>a</code>. The allocated memory is
zero-initialized. This procedure returns a pointer to the newly allocated memory
region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_pool_alloc_bytes"><span><a class="doc-id-link" href="#dynamic_pool_alloc_bytes">dynamic_pool_alloc_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1790"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_pool_alloc_bytes :: <a class="code-procedure" href="/core/mem/#dynamic_arena_alloc_bytes">dynamic_arena_alloc_bytes</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a dynamic arena.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned on a boundary specified
by <code>alignment</code> from a dynamic arena <code>a</code>. The allocated memory is
zero-initialized. This procedure returns a slice of the newly allocated memory
region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_pool_allocator"><span><a class="doc-id-link" href="#dynamic_pool_allocator">dynamic_pool_allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1716"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_pool_allocator :: <a class="code-procedure" href="/core/mem/#dynamic_arena_allocator">dynamic_arena_allocator</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Dynamic arena allocator.</p>
<p>The dynamic arena allocator uses blocks of a specific size, allocated on-demand
using the block allocator. This allocator acts similarly to <code>Arena</code>. All
allocations in a block happen contiguously, from start to end. If an allocation
does not fit into the remaining space of the block and its size is smaller
than the specified out-band size, a new block is allocated using the
<code>block_allocator</code> and the allocation is performed from a newly-allocated block.</p>
<p>If an allocation is larger than the specified out-band size, a new block
is allocated such that the allocation fits into this new block. This is referred
to as an <i>out-band allocation</i>. The out-band blocks are kept separately from
normal blocks.</p>
<p>Just like <code>Arena</code>, the dynamic arena does not support freeing of individual
objects.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_pool_allocator_proc"><span><a class="doc-id-link" href="#dynamic_pool_allocator_proc">dynamic_pool_allocator_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L2015"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_pool_allocator_proc :: <a class="code-procedure" href="/core/mem/#dynamic_arena_allocator_proc">dynamic_arena_allocator_proc</a></pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="dynamic_pool_destroy"><span><a class="doc-id-link" href="#dynamic_pool_destroy">dynamic_pool_destroy<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1729"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_pool_destroy :: <a class="code-procedure" href="/core/mem/#dynamic_arena_destroy">dynamic_arena_destroy</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Destroy a dynamic arena.</p>
<p>This procedure frees all allocations made on a dynamic arena, including the
unused blocks, as well as the arrays for storing blocks.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_pool_free_all"><span><a class="doc-id-link" href="#dynamic_pool_free_all">dynamic_pool_free_all<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1882"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_pool_free_all :: <a class="code-procedure" href="/core/mem/#dynamic_arena_free_all">dynamic_arena_free_all</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free all memory back to the dynamic arena allocator.</p>
<p>This procedure frees all the allocations owned by the dynamic arena, including
the unused blocks.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_pool_init"><span><a class="doc-id-link" href="#dynamic_pool_init">dynamic_pool_init<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1680"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_pool_init :: <a class="code-procedure" href="/core/mem/#dynamic_arena_init">dynamic_arena_init</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initialize a dynamic arena.</p>
<p>This procedure initializes a dynamic arena. The specified <code>block_allocator</code>
will be used to allocate arena blocks, and <code>array_allocator</code> to allocate
arrays of blocks and out-band blocks. The blocks have the default size of
<code>block_size</code> and out-band threshold will be <code>out_band_size</code>. All allocations
will be aligned to a boundary specified by <code>alignment</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="dynamic_pool_reset"><span><a class="doc-id-link" href="#dynamic_pool_reset">dynamic_pool_reset<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1858"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">dynamic_pool_reset :: <a class="code-procedure" href="/core/mem/#dynamic_arena_reset">dynamic_arena_reset</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reset a dynamic arena allocator.</p>
<p>This procedure frees all the allocations owned by the dynamic arena, excluding
the unused blocks.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="end_arena_temp_memory"><span><a class="doc-id-link" href="#end_arena_temp_memory">end_arena_temp_memory<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L364"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">end_arena_temp_memory :: <span class="keyword-type">proc</span>(tmp: <a class="code-typename" href="/core/mem/#Arena_Temp_Memory">Arena_Temp_Memory</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>End a temporary memory region.</p>
<p>This procedure ends the temporary memory region for an arena. All of the
allocations <i>inside</i> the temporary memory region will be freed to the arena.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="free"><span><a class="doc-id-link" href="#free">free<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L390"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">free :: <span class="keyword-type">proc</span>(ptr: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free memory.</p>
<p>This procedure frees memory region located at the address, specified by <code>ptr</code>,
allocated from the allocator specified by <code>allocator</code>.</p>
<p><b>Inputs</b>:
<span class="doc-list"><code>ptr</code>: Pointer to the memory region to free.</span>
<span class="doc-list"><code>allocator</code>: The allocator to free to.</span></p>
<p><b>Returns</b>:
<span class="doc-list">The error, if freeing failed.</span></p>
<p><b>Errors</b>:
<span class="doc-list"><code>None</code>: When no error has occurred.</span>
<span class="doc-list"><code>Invalid_Pointer</code>: The specified pointer is not owned by the specified allocator,</span></p>
<pre>or does not point to a valid allocation.
</pre>
<p><span class="doc-list"><code>Mode_Not_Implemented</code>: If the specified allocator does not support the <code>.Free</code></span>
mode.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="free_all"><span><a class="doc-id-link" href="#free_all">free_all<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L475"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">free_all :: <span class="keyword-type">proc</span>(allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free all allocations.</p>
<p>This procedure frees all allocations made on the allocator specified by
<code>allocator</code> to that allocator, making it available for further allocations.</p>
<p><b>Inputs</b>:
<span class="doc-list"><code>allocator</code>: The allocator to free to.</span></p>
<p><b>Errors</b>:
<span class="doc-list"><code>None</code>: When no error has occurred.</span>
<span class="doc-list"><code>Mode_Not_Implemented</code>: If the specified allocator does not support the <code>.Free</code></span>
mode.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="free_bytes"><span><a class="doc-id-link" href="#free_bytes">free_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L453"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">free_bytes :: <span class="keyword-type">proc</span>(bytes: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free a memory region.</p>
<p>This procedure frees memory region, specified by <code>bytes</code>, allocated from the
allocator specified by <code>allocator</code>.</p>
<p>If the length of the specified slice is zero, the <code>.Invalid_Argument</code> error
is returned.</p>
<p><b>Inputs</b>:
<span class="doc-list"><code>bytes</code>: The memory region to free.</span>
<span class="doc-list"><code>allocator</code>: The allocator to free to.</span></p>
<p><b>Returns</b>:
<span class="doc-list">The error, if freeing failed.</span></p>
<p><b>Errors</b>:
<span class="doc-list"><code>None</code>: When no error has occurred.</span>
<span class="doc-list"><code>Invalid_Pointer</code>: The specified pointer is not owned by the specified allocator,</span></p>
<pre>or does not point to a valid allocation.
</pre>
<p><span class="doc-list"><code>Mode_Not_Implemented</code>: If the specified allocator does not support the <code>.Free</code></span>
mode.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="free_with_size"><span><a class="doc-id-link" href="#free_with_size">free_with_size<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L421"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">free_with_size :: <span class="keyword-type">proc</span>(ptr: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free a memory region.</p>
<p>This procedure frees <code>size</code> bytes of memory region located at the address,
specified by <code>ptr</code>, allocated from the allocator specified by <code>allocator</code>.</p>
<p>If the <code>size</code> parameter is <code>0</code>, this call is equivalent to <code>free()</code>.</p>
<p><b>Inputs</b>:
<span class="doc-list"><code>ptr</code>: Pointer to the memory region to free.</span>
<span class="doc-list"><code>size</code>: The size of the memory region to free.</span>
<span class="doc-list"><code>allocator</code>: The allocator to free to.</span></p>
<p><b>Returns</b>:
<span class="doc-list">The error, if freeing failed.</span></p>
<p><b>Errors</b>:
<span class="doc-list"><code>None</code>: When no error has occurred.</span>
<span class="doc-list"><code>Invalid_Pointer</code>: The specified pointer is not owned by the specified allocator,</span></p>
<pre>or does not point to a valid allocation.
</pre>
<p><span class="doc-list"><code>Mode_Not_Implemented</code>: If the specified allocator does not support the <code>.Free</code></span>
mode.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="is_aligned"><span><a class="doc-id-link" href="#is_aligned">is_aligned<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L486"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">is_aligned :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (x: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, align: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Check if a pointer is aligned.</p>
<p>This procedure checks whether a pointer <code>x</code> is aligned to a boundary specified
by <code>align</code>, and returns <code>true</code> if the pointer is aligned, and false otherwise.</p>
<p>The specified alignment must be a power of 2.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="is_power_of_two"><span><a class="doc-id-link" href="#is_power_of_two">is_power_of_two<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L471"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">is_power_of_two :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (x: <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Check whether a number is a power of two.</p>
<p>This procedure checks whether a given pointer-sized unsigned integer contains
a power-of-two value.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="make_aligned"><span><a class="doc-id-link" href="#make_aligned">make_aligned<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L881"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">make_aligned :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>/[]$E, <span class="keyword-type">#any_int</span> len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (slice: T, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate a new slice with alignment.</p>
<p>This procedure allocates a new slice of type <code>T</code> with length <code>len</code>, aligned
on a boundary specified by <code>alignment</code> from an allocator specified by
<code>allocator</code>, and returns the allocated slice.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="make_any"><span><a class="doc-id-link" href="#make_any">make_any<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin#L103"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">make_any :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (data: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, id: <a href="/base/builtin#typeid"><span class="doc-builtin">typeid</span></a>) -> <a href="/base/builtin#any"><span class="doc-builtin">any</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Create a value of the any type.</p>
<p>This procedure creates a value with type <code>any</code> that points to an object with
typeid <code>id</code> located at an address specified by <code>data</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="make_dynamic_array"><span><a class="doc-id-link" href="#make_dynamic_array">make_dynamic_array<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L942"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">make_dynamic_array :: <span class="keyword-type">proc</span>($T: [<span class="keyword">dynamic</span>]$E, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([<span class="keyword">dynamic</span>]$E, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate a dynamic array.</p>
<p>This procedure creates a dynamic array of type <code>T</code>, with <code>allocator</code> as its
backing allocator, and initial length and capacity of <code>0</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="make_dynamic_array_len"><span><a class="doc-id-link" href="#make_dynamic_array_len">make_dynamic_array_len<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L957"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">make_dynamic_array_len :: <span class="keyword-type">proc</span>($T: [<span class="keyword">dynamic</span>]$E, <span class="keyword-type">#any_int</span> len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([<span class="keyword">dynamic</span>]$E, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate a dynamic array with initial length.</p>
<p>This procedure creates a dynamic array of type <code>T</code>, with <code>allocator</code> as its
backing allocator, and initial capacity and length specified by <code>len</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="make_dynamic_array_len_cap"><span><a class="doc-id-link" href="#make_dynamic_array_len_cap">make_dynamic_array_len_cap<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L974"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">make_dynamic_array_len_cap :: <span class="keyword-type">proc</span>($T: [<span class="keyword">dynamic</span>]$E, <span class="keyword-type">#any_int</span> len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, <span class="keyword-type">#any_int</span> cap: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (array: [<span class="keyword">dynamic</span>]$E, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate a dynamic array with initial length and capacity.</p>
<p>This procedure creates a dynamic array of type <code>T</code>, with <code>allocator</code> as its
backing allocator, and initial capacity specified by <code>cap</code>, and initial length
specified by <code>len</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="make_fixed_byte_buffer"><span><a class="doc-id-link" href="#make_fixed_byte_buffer">make_fixed_byte_buffer<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L642"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">make_fixed_byte_buffer :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (backing: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>) -> <a class="code-typename" href="/core/mem/#Fixed_Byte_Buffer">Fixed_Byte_Buffer</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Create a fixed byte buffer from a slice.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="make_map"><span><a class="doc-id-link" href="#make_map">make_map<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L992"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">make_map :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>/<span class="keyword-type">map</span>[$K]$E, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (m: $/<span class="keyword-type">map</span>[$K]$E) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Create a map with no initial allocation.</p>
<p>This procedure creates a map of type <code>T</code> with no initial allocation, which will
use the allocator specified by <code>allocator</code> as its backing allocator when it
allocates.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="make_map_cap"><span><a class="doc-id-link" href="#make_map_cap">make_map_cap<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L1008"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">make_map_cap :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>/<span class="keyword-type">map</span>[$K]$E, <span class="keyword-type">#any_int</span> cap: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (m: $/<span class="keyword-type">map</span>[$K]$E, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate a map.</p>
<p>This procedure creates a map of type <code>T</code> with initial capacity specified by
<code>cap</code>, that is using an allocator specified by <code>allocator</code> as its backing
allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="make_multi_pointer"><span><a class="doc-id-link" href="#make_multi_pointer">make_multi_pointer<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L1024"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">make_multi_pointer :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>/[^]$E, <span class="keyword-type">#any_int</span> len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (mp: $/[^]$E, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate a multi pointer.</p>
<p>This procedure allocates a multipointer of type <code>T</code> pointing to <code>len</code> elements,
from an allocator specified by <code>allocator</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="make_over_aligned"><span><a class="doc-id-link" href="#make_over_aligned">make_over_aligned<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L903"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">make_over_aligned :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>/[]$E, <span class="keyword-type">#any_int</span> len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator: runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (slice: T, original_data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate a new slice with alignment for allocators that might not support the
specified alignment requirement.</p>
<p>This procedure allocates a new slice of type <code>T</code> with length <code>len</code>, aligned
on a boundary specified by <code>alignment</code> from an allocator specified by
<code>allocator</code>, and returns the allocated slice.</p>
<p>The user should <code>delete</code> the return <code>original_data</code> slice not the typed <code>slice</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="make_slice"><span><a class="doc-id-link" href="#make_slice">make_slice<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L926"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">make_slice :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>/[]$E, <span class="keyword-type">#any_int</span> len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (T, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate a new slice.</p>
<p>This procedure allocates a new slice of type <code>T</code> with length <code>len</code>, from an
allocator specified by <code>allocator</code>, and returns the allocated slice.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="make_soa_dynamic_array"><span><a class="doc-id-link" href="#make_soa_dynamic_array">make_soa_dynamic_array<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L1056"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">make_soa_dynamic_array :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>/<span class="directive">#soa</span>[<span class="keyword">dynamic</span>]$E, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (array: T, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate an SoA dynamic array.</p>
<p>This procedure creates an SoA dynamic array of type <code>T</code>, with <code>allocator</code> as
its backing allocator, and initial length and capacity of <code>0</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="make_soa_dynamic_array_len"><span><a class="doc-id-link" href="#make_soa_dynamic_array_len">make_soa_dynamic_array_len<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L1071"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">make_soa_dynamic_array_len :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>/<span class="directive">#soa</span>[<span class="keyword">dynamic</span>]$E, <span class="keyword-type">#any_int</span> len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (array: T, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate an SoA dynamic array with initial length.</p>
<p>This procedure creates an SoA dynamic array of type <code>T</code>, with <code>allocator</code> as its
backing allocator, and initial capacity and length specified by <code>len</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="make_soa_dynamic_array_len_cap"><span><a class="doc-id-link" href="#make_soa_dynamic_array_len_cap">make_soa_dynamic_array_len_cap<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L1088"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">make_soa_dynamic_array_len_cap :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>/<span class="directive">#soa</span>[<span class="keyword">dynamic</span>]$E, <span class="keyword-type">#any_int</span> len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, <span class="keyword-type">#any_int</span> cap: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (array: T, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate an SoA dynamic array with initial length and capacity.</p>
<p>This procedure creates an SoA dynamic array of type <code>T</code>, with <code>allocator</code> as its
backing allocator, and initial capacity specified by <code>cap</code>, and initial length
specified by <code>len</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="make_soa_slice"><span><a class="doc-id-link" href="#make_soa_slice">make_soa_slice<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L1040"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">make_soa_slice :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>/<span class="directive">#soa</span>[]$E, <span class="keyword-type">#any_int</span> len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (array: T, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate an SoA slice.</p>
<p>This procedure allocates an SoA slice of type <code>T</code> with length <code>len</code>, from an
allocator specified by <code>allocator</code>, and returns the allocated SoA slice.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="mutex_allocator"><span><a class="doc-id-link" href="#mutex_allocator">mutex_allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mutex_allocator.odin#L32"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">mutex_allocator :: <span class="keyword-type">proc</span>(m: ^<a class="code-typename" href="/core/mem/#Mutex_Allocator">Mutex_Allocator</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Mutex allocator.</p>
<p>The mutex allocator is a wrapper for allocators that is used to serialize all
allocator requests across multiple threads.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="mutex_allocator_init"><span><a class="doc-id-link" href="#mutex_allocator_init">mutex_allocator_init<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mutex_allocator.odin#L20"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">mutex_allocator_init :: <span class="keyword-type">proc</span>(m: ^<a class="code-typename" href="/core/mem/#Mutex_Allocator">Mutex_Allocator</a>, backing_allocator: runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initialize the mutex allocator.</p>
<p>This procedure initializes the mutex allocator using <code>backin_allocator</code> as the
allocator that will be used to pass all allocation requests through.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="mutex_allocator_proc"><span><a class="doc-id-link" href="#mutex_allocator_proc">mutex_allocator_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mutex_allocator.odin#L39"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">mutex_allocator_proc :: <span class="keyword-type">proc</span>(
	allocator_data:  <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	mode:            runtime.<a class="code-typename" href="/base/runtime/#Allocator_Mode">Allocator_Mode</a>, 
	size, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	old_memory:      <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:        <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> (result: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="new"><span><a class="doc-id-link" href="#new">new<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L830"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">new :: <span class="keyword-type">proc</span>($T: <a href="/base/builtin#typeid"><span class="doc-builtin">typeid</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (^<a href="/base/builtin#typeid"><span class="doc-builtin">typeid</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate a new object.</p>
<p>This procedure allocates a new object of type <code>T</code> using an allocator specified
by <code>allocator</code>, and returns a pointer to the allocated object, if allocated
successfully, or <code>nil</code> otherwise.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="new_aligned"><span><a class="doc-id-link" href="#new_aligned">new_aligned<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L847"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">new_aligned :: <span class="keyword-type">proc</span>($T: <a href="/base/builtin#typeid"><span class="doc-builtin">typeid</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (t: ^<a href="/base/builtin#typeid"><span class="doc-builtin">typeid</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate a new object with alignment.</p>
<p>This procedure allocates a new object of type <code>T</code> using an allocator specified
by <code>allocator</code>, and returns a pointer, aligned on a boundary specified by
<code>alignment</code>  to the allocated object, if allocated successfully, or <code>nil</code>
otherwise.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="new_clone"><span><a class="doc-id-link" href="#new_clone">new_clone<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L865"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">new_clone :: <span class="keyword-type">proc</span>(data: $T, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (t: ^$T, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate a new object and initialize it with a value.</p>
<p>This procedure allocates a new object of type <code>T</code> using an allocator specified
by <code>allocator</code>, and returns a pointer, aligned on a boundary specified by
<code>alignment</code>  to the allocated object, if allocated successfully, or <code>nil</code>
otherwise. The allocated object is initialized with <code>data</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="nil_allocator"><span><a class="doc-id-link" href="#nil_allocator">nil_allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L65"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">nil_allocator :: <span class="keyword-type">proc</span>() -> runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Nil allocator.</p>
<p>The <code>nil</code> allocator returns <code>nil</code> on every allocation attempt. This type of
allocator can be used in scenarios where memory doesn't need to be allocated,
but an attempt to allocate memory is not an error.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="nil_allocator_proc"><span><a class="doc-id-link" href="#nil_allocator_proc">nil_allocator_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L72"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">nil_allocator_proc :: <span class="keyword-type">proc</span>(
	allocator_data:  <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	mode:            runtime.<a class="code-typename" href="/base/runtime/#Allocator_Mode">Allocator_Mode</a>, 
	size, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	old_memory:      <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:        <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="panic_allocator"><span><a class="doc-id-link" href="#panic_allocator">panic_allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L92"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">panic_allocator :: <span class="keyword-type">proc</span>() -> runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Panic allocator.</p>
<p>The panic allocator is a type of allocator that panics on any allocation
attempt. This type of allocator can be used in scenarios where memory should
not be allocated, and an attempt to allocate memory is an error.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="panic_allocator_proc"><span><a class="doc-id-link" href="#panic_allocator_proc">panic_allocator_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L99"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">panic_allocator_proc :: <span class="keyword-type">proc</span>(
	allocator_data:  <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	mode:            runtime.<a class="code-typename" href="/base/runtime/#Allocator_Mode">Allocator_Mode</a>, 
	size, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	old_memory:      <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:        <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="ptr_offset"><span><a class="doc-id-link" href="#ptr_offset">ptr_offset<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">ptr_offset :: <a href="/base/intrinsics#ptr_offset">intrinsics</a>.ptr_offset</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Offset a given pointer by a given amount.</p>
<p>This procedure offsets the pointer <code>ptr</code> to an object of type <code>T</code>, by the amount
of bytes specified by <code>offset * size_of(T)</code>, and returns the pointer <code>ptr</code>.</p>
<p><b>Note</b>: Prefer to use multipointer types, if possible.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="ptr_sub"><span><a class="doc-id-link" href="#ptr_sub">ptr_sub<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">ptr_sub :: <a href="/base/intrinsics#ptr_sub">intrinsics</a>.ptr_sub</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Subtract two pointers of the same type, and return the number of <code>T</code> between them.</p>
<p>This procedure subtracts pointer <code>b</code> from pointer <code>a</code>, both of type <code>^T</code>,
and returns an integer count of the <code>T</code> between them.</p>
<p><b>Inputs</b>
<span class="doc-list"><code>a</code>: A pointer to a type T</span>
<span class="doc-list"><code>b</code>: A pointer to a type T</span></p>
<p><b>Returns</b>
<span class="doc-list"><code>b</code> - <code>a</code> in items of T as an <code>int</code>.</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:mem"
import "core:fmt"

ptr_sub_example :: proc() {
	arr: [2]int
	fmt.println(mem.ptr_sub(&arr[1], &arr[0]))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">1
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="ptr_to_bytes"><span><a class="doc-id-link" href="#ptr_to_bytes">ptr_to_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L382"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">ptr_to_bytes :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (ptr: ^$T, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = 1) -> []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Create a byte slice from pointer and length.</p>
<p>This procedure creates a byte slice, pointing to <code>len</code> objects, starting from
the address specified by <code>ptr</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="query_features"><span><a class="doc-id-link" href="#query_features">query_features<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L711"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">query_features :: <span class="keyword-type">proc</span>(allocator: runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (set: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Mode_Set">Allocator_Mode_Set</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Query allocator features.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="query_info"><span><a class="doc-id-link" href="#query_info">query_info<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L723"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">query_info :: <span class="keyword-type">proc</span>(pointer: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, allocator: runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (props: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Query_Info">Allocator_Query_Info</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Query allocator information.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="raw_data"><span><a class="doc-id-link" href="#raw_data">raw_data<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">raw_data :: <a href="/base/builtin#raw_data">builtin</a>.raw_data</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Obtain pointer to the data.</p>
<p>This procedure returns the pointer to the data of a slice, string, or a dynamic
array.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rb_alloc"><span><a class="doc-id-link" href="#rb_alloc">rb_alloc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L144"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rb_alloc :: <span class="keyword-type">proc</span>(stack: ^<a class="code-typename" href="/core/mem/#Rollback_Stack">Rollback_Stack</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory using the rollback stack allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rb_alloc_bytes"><span><a class="doc-id-link" href="#rb_alloc_bytes">rb_alloc_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L161"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rb_alloc_bytes :: <span class="keyword-type">proc</span>(stack: ^<a class="code-typename" href="/core/mem/#Rollback_Stack">Rollback_Stack</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory using the rollback stack allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rb_alloc_bytes_non_zeroed"><span><a class="doc-id-link" href="#rb_alloc_bytes_non_zeroed">rb_alloc_bytes_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L192"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rb_alloc_bytes_non_zeroed :: <span class="keyword-type">proc</span>(stack: ^<a class="code-typename" href="/core/mem/#Rollback_Stack">Rollback_Stack</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (result: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate non-initialized memory using the rollback stack allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rb_alloc_non_zeroed"><span><a class="doc-id-link" href="#rb_alloc_non_zeroed">rb_alloc_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L178"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rb_alloc_non_zeroed :: <span class="keyword-type">proc</span>(stack: ^<a class="code-typename" href="/core/mem/#Rollback_Stack">Rollback_Stack</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate non-initialized memory using the rollback stack allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rb_resize"><span><a class="doc-id-link" href="#rb_resize">rb_resize<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L254"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rb_resize :: <span class="keyword-type">proc</span>(
	stack:     ^<a class="code-typename" href="/core/mem/#Rollback_Stack">Rollback_Stack</a>, 
	old_ptr:   <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:  <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	size:      <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by rollback stack allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rb_resize_bytes"><span><a class="doc-id-link" href="#rb_resize_bytes">rb_resize_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L277"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rb_resize_bytes :: <span class="keyword-type">proc</span>(stack: ^<a class="code-typename" href="/core/mem/#Rollback_Stack">Rollback_Stack</a>, old_memory: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by rollback stack allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rb_resize_bytes_non_zeroed"><span><a class="doc-id-link" href="#rb_resize_bytes_non_zeroed">rb_resize_bytes_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L317"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rb_resize_bytes_non_zeroed :: <span class="keyword-type">proc</span>(stack: ^<a class="code-typename" href="/core/mem/#Rollback_Stack">Rollback_Stack</a>, old_memory: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (result: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by rollback stack allocator without explicit
zero-initialization.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rb_resize_non_zeroed"><span><a class="doc-id-link" href="#rb_resize_non_zeroed">rb_resize_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L300"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rb_resize_non_zeroed :: <span class="keyword-type">proc</span>(
	stack:     ^<a class="code-typename" href="/core/mem/#Rollback_Stack">Rollback_Stack</a>, 
	old_ptr:   <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:  <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	size:      <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by rollback stack allocator without explicit
zero-initialization.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="reinterpret_copy"><span><a class="doc-id-link" href="#reinterpret_copy">reinterpret_copy<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L624"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">reinterpret_copy :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> ($T: <a href="/base/builtin#typeid"><span class="doc-builtin">typeid</span></a>, ptr: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>) -> (value: <a href="/base/builtin#typeid"><span class="doc-builtin">typeid</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Copy the value from a pointer into a value.</p>
<p>This procedure copies the object of type <code>T</code> pointed to by the pointer <code>ptr</code>
into a new stack-allocated value and returns that value.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="resize"><span><a class="doc-id-link" href="#resize">resize<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L524"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">resize :: <span class="keyword-type">proc</span>(
	ptr:       <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:  <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	new_size:  <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, 
	allocator := <a href="/base/runtime/#Context">context.allocator</a>, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize a memory region.</p>
<p>This procedure resizes a memory region, <code>old_size</code> bytes in size, located at
the address specified by <code>ptr</code>, such that it has a new size, specified by
<code>new_size</code> and and is aligned on a boundary specified by <code>alignment</code>.</p>
<p>If the <code>ptr</code> parameter is <code>nil</code>, <code>resize()</code> acts just like <code>alloc()</code>, allocating
<code>new_size</code> bytes, aligned on a boundary specified by <code>alignment</code>.</p>
<p>If the <code>new_size</code> parameter is <code>0</code>, <code>resize()</code> acts just like <code>free()</code>, freeing
the memory region <code>old_size</code> bytes in length, located at the address specified
by <code>ptr</code>.</p>
<p>If the <code>old_memory</code> pointer is not aligned to the boundary specified by
<code>alignment</code>, the procedure relocates the buffer such that the reallocated
buffer is aligned to the boundary specified by <code>alignment</code>.</p>
<p><b>Inputs</b>:
<span class="doc-list"><code>ptr</code>: Pointer to the memory region to resize.</span>
<span class="doc-list"><code>old_size</code>: Size of the memory region to resize.</span>
<span class="doc-list"><code>new_size</code>: The desired size of the resized memory region.</span>
<span class="doc-list"><code>alignment</code>: The desired alignment of the resized memory region.</span>
<span class="doc-list"><code>allocator</code>: The owner of the memory region to resize.</span></p>
<p><b>Returns</b>:
1. The pointer to the resized memory region, if successfull, <code>nil</code> otherwise.
2. Error, if resize failed.</p>
<p><b>Errors</b>:
<span class="doc-list"><code>None</code>: No error.</span>
<span class="doc-list"><code>Out_Of_Memory</code>: When the allocator's backing buffer or it's backing</span></p>
<pre>allocator does not have enough space to fit in an allocation with the new
size, or an operating system failure occurs.
</pre>
<p><span class="doc-list"><code>Invalid_Pointer</code>: The pointer referring to a memory region does not belong</span></p>
<pre>to any of the allocators backing buffers or does not point to a valid start
of an allocation made in that allocator.
</pre>
<p><span class="doc-list"><code>Invalid_Argument</code>: When <code>size</code> is negative, alignment is not a power of two,</span></p>
<pre>or the `old_size` argument is incorrect.
</pre>
<p><span class="doc-list"><code>Mode_Not_Implemented</code>: The allocator does not support the <code>.Realloc</code> mode.</span></p>
<p><b>Note</b>: if <code>old_size</code> is <code>0</code> and <code>old_memory</code> is <code>nil</code>, this operation is a
no-op, and should not return errors.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="resize_bytes"><span><a class="doc-id-link" href="#resize_bytes">resize_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L640"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">resize_bytes :: <span class="keyword-type">proc</span>(old_data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, new_size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize a memory region.</p>
<p>This procedure resizes a memory region, specified by <code>old_data</code>, such that it
has a new size, specified by <code>new_size</code> and and is aligned on a boundary
specified by <code>alignment</code>.</p>
<p>If the <code>old_data</code> parameter is <code>nil</code>, <code>resize_bytes()</code> acts just like
<code>alloc_bytes()</code>, allocating <code>new_size</code> bytes, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>If the <code>new_size</code> parameter is <code>0</code>, <code>resize_bytes()</code> acts just like
<code>free_bytes()</code>, freeing the memory region specified by <code>old_data</code>.</p>
<p>If the <code>old_memory</code> pointer is not aligned to the boundary specified by
<code>alignment</code>, the procedure relocates the buffer such that the reallocated
buffer is aligned to the boundary specified by <code>alignment</code>.</p>
<p><b>Inputs</b>:
<span class="doc-list"><code>old_data</code>: Pointer to the memory region to resize.</span>
<span class="doc-list"><code>new_size</code>: The desired size of the resized memory region.</span>
<span class="doc-list"><code>alignment</code>: The desired alignment of the resized memory region.</span>
<span class="doc-list"><code>allocator</code>: The owner of the memory region to resize.</span></p>
<p><b>Returns</b>:
1. The resized memory region, if successfull, <code>nil</code> otherwise.
2. Error, if resize failed.</p>
<p><b>Errors</b>:
<span class="doc-list"><code>None</code>: No error.</span>
<span class="doc-list"><code>Out_Of_Memory</code>: When the allocator's backing buffer or it's backing</span></p>
<pre>allocator does not have enough space to fit in an allocation with the new
size, or an operating system failure occurs.
</pre>
<p><span class="doc-list"><code>Invalid_Pointer</code>: The pointer referring to a memory region does not belong</span></p>
<pre>to any of the allocators backing buffers or does not point to a valid start
of an allocation made in that allocator.
</pre>
<p><span class="doc-list"><code>Invalid_Argument</code>: When <code>size</code> is negative, alignment is not a power of two,</span></p>
<pre>or the `old_size` argument is incorrect.
</pre>
<p><span class="doc-list"><code>Mode_Not_Implemented</code>: The allocator does not support the <code>.Realloc</code> mode.</span></p>
<p><b>Note</b>: if <code>old_size</code> is <code>0</code> and <code>old_memory</code> is <code>nil</code>, this operation is a
no-op, and should not return errors.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="resize_bytes_non_zeroed"><span><a class="doc-id-link" href="#resize_bytes_non_zeroed">resize_bytes_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L697"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">resize_bytes_non_zeroed :: <span class="keyword-type">proc</span>(old_data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, new_size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize a memory region.</p>
<p>This procedure resizes a memory region, specified by <code>old_data</code>, such that it
has a new size, specified by <code>new_size</code> and and is aligned on a boundary
specified by <code>alignment</code>.</p>
<p>If the <code>old_data</code> parameter is <code>nil</code>, <code>resize_bytes()</code> acts just like
<code>alloc_bytes()</code>, allocating <code>new_size</code> bytes, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>If the <code>new_size</code> parameter is <code>0</code>, <code>resize_bytes()</code> acts just like
<code>free_bytes()</code>, freeing the memory region specified by <code>old_data</code>.</p>
<p>If the <code>old_memory</code> pointer is not aligned to the boundary specified by
<code>alignment</code>, the procedure relocates the buffer such that the reallocated
buffer is aligned to the boundary specified by <code>alignment</code>.</p>
<p>Unlike <code>resize_bytes()</code>, this procedure does not explicitly zero-initialize
any new memory.</p>
<p><b>Inputs</b>:
<span class="doc-list"><code>old_data</code>: Pointer to the memory region to resize.</span>
<span class="doc-list"><code>new_size</code>: The desired size of the resized memory region.</span>
<span class="doc-list"><code>alignment</code>: The desired alignment of the resized memory region.</span>
<span class="doc-list"><code>allocator</code>: The owner of the memory region to resize.</span></p>
<p><b>Returns</b>:
1. The resized memory region, if successfull, <code>nil</code> otherwise.
2. Error, if resize failed.</p>
<p><b>Errors</b>:
<span class="doc-list"><code>None</code>: No error.</span>
<span class="doc-list"><code>Out_Of_Memory</code>: When the allocator's backing buffer or it's backing</span></p>
<pre>allocator does not have enough space to fit in an allocation with the new
size, or an operating system failure occurs.
</pre>
<p><span class="doc-list"><code>Invalid_Pointer</code>: The pointer referring to a memory region does not belong</span></p>
<pre>to any of the allocators backing buffers or does not point to a valid start
of an allocation made in that allocator.
</pre>
<p><span class="doc-list"><code>Invalid_Argument</code>: When <code>size</code> is negative, alignment is not a power of two,</span></p>
<pre>or the `old_size` argument is incorrect.
</pre>
<p><span class="doc-list"><code>Mode_Not_Implemented</code>: The allocator does not support the <code>.Realloc</code> mode.</span></p>
<p><b>Note</b>: if <code>old_size</code> is <code>0</code> and <code>old_memory</code> is <code>nil</code>, this operation is a
no-op, and should not return errors.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="resize_non_zeroed"><span><a class="doc-id-link" href="#resize_non_zeroed">resize_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L584"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">resize_non_zeroed :: <span class="keyword-type">proc</span>(
	ptr:       <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:  <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	new_size:  <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, 
	allocator := <a href="/base/runtime/#Context">context.allocator</a>, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize a memory region without zero-initialization.</p>
<p>This procedure resizes a memory region, <code>old_size</code> bytes in size, located at
the address specified by <code>ptr</code>, such that it has a new size, specified by
<code>new_size</code> and and is aligned on a boundary specified by <code>alignment</code>.</p>
<p>If the <code>ptr</code> parameter is <code>nil</code>, <code>resize()</code> acts just like <code>alloc()</code>, allocating
<code>new_size</code> bytes, aligned on a boundary specified by <code>alignment</code>.</p>
<p>If the <code>new_size</code> parameter is <code>0</code>, <code>resize()</code> acts just like <code>free()</code>, freeing
the memory region <code>old_size</code> bytes in length, located at the address specified
by <code>ptr</code>.</p>
<p>If the <code>old_memory</code> pointer is not aligned to the boundary specified by
<code>alignment</code>, the procedure relocates the buffer such that the reallocated
buffer is aligned to the boundary specified by <code>alignment</code>.</p>
<p>Unlike <code>resize()</code>, this procedure does not explicitly zero-initialize any new
memory.</p>
<p><b>Inputs</b>:
<span class="doc-list"><code>ptr</code>: Pointer to the memory region to resize.</span>
<span class="doc-list"><code>old_size</code>: Size of the memory region to resize.</span>
<span class="doc-list"><code>new_size</code>: The desired size of the resized memory region.</span>
<span class="doc-list"><code>alignment</code>: The desired alignment of the resized memory region.</span>
<span class="doc-list"><code>allocator</code>: The owner of the memory region to resize.</span></p>
<p><b>Returns</b>:
1. The pointer to the resized memory region, if successfull, <code>nil</code> otherwise.
2. Error, if resize failed.</p>
<p><b>Errors</b>:
<span class="doc-list"><code>None</code>: No error.</span>
<span class="doc-list"><code>Out_Of_Memory</code>: When the allocator's backing buffer or it's backing</span></p>
<pre>allocator does not have enough space to fit in an allocation with the new
size, or an operating system failure occurs.
</pre>
<p><span class="doc-list"><code>Invalid_Pointer</code>: The pointer referring to a memory region does not belong</span></p>
<pre>to any of the allocators backing buffers or does not point to a valid start
of an allocation made in that allocator.
</pre>
<p><span class="doc-list"><code>Invalid_Argument</code>: When <code>size</code> is negative, alignment is not a power of two,</span></p>
<pre>or the `old_size` argument is incorrect.
</pre>
<p><span class="doc-list"><code>Mode_Not_Implemented</code>: The allocator does not support the <code>.Realloc</code> mode.</span></p>
<p><b>Note</b>: if <code>old_size</code> is <code>0</code> and <code>old_memory</code> is <code>nil</code>, this operation is a
no-op, and should not return errors.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rollback_stack_allocator"><span><a class="doc-id-link" href="#rollback_stack_allocator">rollback_stack_allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L451"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rollback_stack_allocator :: <span class="keyword-type">proc</span>(stack: ^<a class="code-typename" href="/core/mem/#Rollback_Stack">Rollback_Stack</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Rollback stack allocator.</p>
<p>The Rollback Stack Allocator was designed for the test runner to be fast,
able to grow, and respect the Tracking Allocator's requirement for
individual frees. It is not overly concerned with fragmentation, however.</p>
<p>It has support for expansion when configured with a block allocator and
limited support for out-of-order frees.</p>
<p>Allocation has constant-time best and usual case performance.
At worst, it is linear according to the number of memory blocks.</p>
<p>Allocation follows a first-fit strategy when there are multiple memory
blocks.</p>
<p>Freeing has constant-time best and usual case performance.
At worst, it is linear according to the number of memory blocks and number
of freed items preceding the last item in a block.</p>
<p>Resizing has constant-time performance, if it's the last item in a block, or
the new size is smaller. Naturally, this becomes linear-time if there are
multiple blocks to search for the pointer's owning block. Otherwise, the
allocator defaults to a combined alloc & free operation internally.</p>
<p>Out-of-order freeing is accomplished by collapsing a run of freed items
from the last allocation backwards.</p>
<p>Each allocation has an overhead of 8 bytes and any extra bytes to satisfy
the requested alignment.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rollback_stack_allocator_proc"><span><a class="doc-id-link" href="#rollback_stack_allocator_proc">rollback_stack_allocator_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L459"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rollback_stack_allocator_proc :: <span class="keyword-type">proc</span>(
	allocator_data:  <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	mode:            runtime.<a class="code-typename" href="/base/runtime/#Allocator_Mode">Allocator_Mode</a>, 
	size, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	old_memory:      <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:        <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> (result: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="rollback_stack_destroy"><span><a class="doc-id-link" href="#rollback_stack_destroy">rollback_stack_destroy<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L411"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rollback_stack_destroy :: <span class="keyword-type">proc</span>(stack: ^<a class="code-typename" href="/core/mem/#Rollback_Stack">Rollback_Stack</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Destroy a rollback stack.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rollback_stack_init_buffered"><span><a class="doc-id-link" href="#rollback_stack_init_buffered">rollback_stack_init_buffered<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L364"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rollback_stack_init_buffered :: <span class="keyword-type">proc</span>(stack: ^<a class="code-typename" href="/core/mem/#Rollback_Stack">Rollback_Stack</a>, buffer: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, location := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initialize the rollback stack allocator using a fixed backing buffer.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rollback_stack_init_dynamic"><span><a class="doc-id-link" href="#rollback_stack_init_dynamic">rollback_stack_init_dynamic<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L379"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rollback_stack_init_dynamic :: <span class="keyword-type">proc</span>(stack: ^<a class="code-typename" href="/core/mem/#Rollback_Stack">Rollback_Stack</a>, block_size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = ROLLBACK_STACK_DEFAULT_BLOCK_SIZE, block_allocator := <a href="/base/runtime/#Context">context.allocator</a>, location := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initialize the rollback stack alocator using a backing block allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="scratch_alloc"><span><a class="doc-id-link" href="#scratch_alloc">scratch_alloc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L462"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scratch_alloc :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Scratch">Scratch</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a scratch allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned on a boundary specified
by <code>alignment</code>. The allocated memory region is zero-initialized. This procedure
returns a pointer to the allocated memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="scratch_alloc_bytes"><span><a class="doc-id-link" href="#scratch_alloc_bytes">scratch_alloc_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L480"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scratch_alloc_bytes :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Scratch">Scratch</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a scratch allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned on a boundary specified
by <code>alignment</code>. The allocated memory region is zero-initialized. This procedure
returns a slice of the allocated memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="scratch_alloc_bytes_non_zeroed"><span><a class="doc-id-link" href="#scratch_alloc_bytes_non_zeroed">scratch_alloc_bytes_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L519"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scratch_alloc_bytes_non_zeroed :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Scratch">Scratch</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate non-initialized memory from a scratch allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned on a boundary specified
by <code>alignment</code>. The allocated memory region is not explicitly zero-initialized.
This procedure returns a slice of the allocated memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="scratch_alloc_non_zeroed"><span><a class="doc-id-link" href="#scratch_alloc_non_zeroed">scratch_alloc_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L501"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scratch_alloc_non_zeroed :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Scratch">Scratch</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate non-initialized memory from a scratch allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned on a boundary specified
by <code>alignment</code>. The allocated memory region is not explicitly zero-initialized.
This procedure returns a pointer to the allocated memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="scratch_allocator"><span><a class="doc-id-link" href="#scratch_allocator">scratch_allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L414"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scratch_allocator :: <span class="keyword-type">proc</span>(allocator: ^<a class="code-typename" href="/core/mem/#Scratch">Scratch</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Scratch allocator.</p>
<p>The scratch allocator works in a similar way to the <code>Arena</code> allocator. The
scratch allocator has a backing buffer that is allocated in contiguous regions,
from start to end.</p>
<p>Each subsequent allocation will be the next adjacent region of memory in the
backing buffer. If the allocation doesn't fit into the remaining space of the
backing buffer, this allocation is put at the start of the buffer, and all
previous allocations will become invalidated.</p>
<p>If the allocation doesn't fit into the backing buffer as a whole, it will be
allocated using a backing allocator, and the pointer to the allocated memory
region will be put into the <code>leaked_allocations</code> array. A <code>Warning</code>-level log
message will be sent as well.</p>
<p>Allocations which are resized will be resized in-place if they were the last
allocation. Otherwise, they are re-allocated to avoid overwriting previous
allocations.</p>
<p>The <code>leaked_allocations</code> array is managed by the <code>context</code> allocator if no
<code>backup_allocator</code> is specified in <code>scratch_init</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="scratch_allocator_destroy"><span><a class="doc-id-link" href="#scratch_allocator_destroy">scratch_allocator_destroy<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L441"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scratch_allocator_destroy :: <a class="code-procedure" href="/core/mem/#scratch_destroy">scratch_destroy</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free all data associated with a scratch allocator.</p>
<p>This is distinct from <code>scratch_free_all</code> in that it deallocates all memory used
to setup the allocator, as opposed to all allocations made from that space.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="scratch_allocator_init"><span><a class="doc-id-link" href="#scratch_allocator_init">scratch_allocator_init<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L424"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scratch_allocator_init :: <a class="code-procedure" href="/core/mem/#scratch_init">scratch_init</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initialize a scratch allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="scratch_allocator_proc"><span><a class="doc-id-link" href="#scratch_allocator_proc">scratch_allocator_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L781"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scratch_allocator_proc :: <span class="keyword-type">proc</span>(
	allocator_data:  <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	mode:            runtime.<a class="code-typename" href="/base/runtime/#Allocator_Mode">Allocator_Mode</a>, 
	size, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	old_memory:      <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:        <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="scratch_destroy"><span><a class="doc-id-link" href="#scratch_destroy">scratch_destroy<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L441"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scratch_destroy :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Scratch">Scratch</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free all data associated with a scratch allocator.</p>
<p>This is distinct from <code>scratch_free_all</code> in that it deallocates all memory used
to setup the allocator, as opposed to all allocations made from that space.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="scratch_free"><span><a class="doc-id-link" href="#scratch_free">scratch_free<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L587"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scratch_free :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Scratch">Scratch</a>, ptr: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free memory back to the scratch allocator.</p>
<p>This procedure frees the memory region allocated at pointer <code>ptr</code>.</p>
<p>If <code>ptr</code> is not the latest allocation and is not a leaked allocation, this
operation is a no-op.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="scratch_free_all"><span><a class="doc-id-link" href="#scratch_free_all">scratch_free_all<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L624"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scratch_free_all :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Scratch">Scratch</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free all memory back to the scratch allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="scratch_init"><span><a class="doc-id-link" href="#scratch_init">scratch_init<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L424"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scratch_init :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Scratch">Scratch</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, backup_allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initialize a scratch allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="scratch_resize"><span><a class="doc-id-link" href="#scratch_resize">scratch_resize<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L651"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scratch_resize :: <span class="keyword-type">proc</span>(
	s:          ^<a class="code-typename" href="/core/mem/#Scratch">Scratch</a>, 
	old_memory: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:   <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	size:       <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	alignment:  <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by a scratch allocator.</p>
<p>This procedure resizes a memory region defined by its location <code>old_memory</code>
and its size <code>old_size</code> to have a size <code>size</code> and alignment <code>alignment</code>. The
newly allocated memory, if any, is zero-initialized.</p>
<p>If <code>old_memory</code> is <code>nil</code>, this procedure acts just like <code>scratch_alloc()</code>,
allocating a memory region <code>size</code> bytes in size, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>If <code>size</code> is 0, this procedure acts just like <code>scratch_free()</code>, freeing the
memory region located at an address specified by <code>old_memory</code>.</p>
<p>This procedure returns the pointer to the resized memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="scratch_resize_bytes"><span><a class="doc-id-link" href="#scratch_resize_bytes">scratch_resize_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L680"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scratch_resize_bytes :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Scratch">Scratch</a>, old_data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by a scratch allocator.</p>
<p>This procedure resizes a memory region specified by <code>old_data</code> to have a size
<code>size</code> and alignment <code>alignment</code>. The newly allocated memory, if any, is
zero-initialized.</p>
<p>If <code>old_memory</code> is <code>nil</code>, this procedure acts just like <code>scratch_alloc()</code>,
allocating a memory region <code>size</code> bytes in size, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>If <code>size</code> is 0, this procedure acts just like <code>scratch_free()</code>, freeing the
memory region located at an address specified by <code>old_memory</code>.</p>
<p>This procedure returns the slice of the resized memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="scratch_resize_bytes_non_zeroed"><span><a class="doc-id-link" href="#scratch_resize_bytes_non_zeroed">scratch_resize_bytes_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L740"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scratch_resize_bytes_non_zeroed :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Scratch">Scratch</a>, old_data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by a scratch allocator.</p>
<p>This procedure resizes a memory region specified by <code>old_data</code> to have a size
<code>size</code> and alignment <code>alignment</code>. The newly allocated memory, if any, is not
explicitly zero-initialized.</p>
<p>If <code>old_memory</code> is <code>nil</code>, this procedure acts just like <code>scratch_alloc()</code>,
allocating a memory region <code>size</code> bytes in size, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>If <code>size</code> is 0, this procedure acts just like <code>scratch_free()</code>, freeing the
memory region located at an address specified by <code>old_memory</code>.</p>
<p>This procedure returns the slice of the resized memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="scratch_resize_non_zeroed"><span><a class="doc-id-link" href="#scratch_resize_non_zeroed">scratch_resize_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L711"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scratch_resize_non_zeroed :: <span class="keyword-type">proc</span>(
	s:          ^<a class="code-typename" href="/core/mem/#Scratch">Scratch</a>, 
	old_memory: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:   <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	size:       <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	alignment:  <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by a scratch allocator, without zero-initialization.</p>
<p>This procedure resizes a memory region defined by its location <code>old_memory</code>
and its size <code>old_size</code> to have a size <code>size</code> and alignment <code>alignment</code>. The
newly allocated memory, if any, is not explicitly zero-initialized.</p>
<p>If <code>old_memory</code> is <code>nil</code>, this procedure acts just like <code>scratch_alloc()</code>,
allocating a memory region <code>size</code> bytes in size, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>If <code>size</code> is 0, this procedure acts just like <code>scratch_free()</code>, freeing the
memory region located at an address specified by <code>old_memory</code>.</p>
<p>This procedure returns the pointer to the resized memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="set"><span><a class="doc-id-link" href="#set">set<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L69"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">set :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (data: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, value: <a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Set each byte of a memory range to a specific value.</p>
<p>This procedure copies value specified by the <code>value</code> parameter into each of the
<code>len</code> bytes of a memory range, located at address <code>data</code>.</p>
<p>This procedure returns the pointer to <code>data</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simple_equal"><span><a class="doc-id-link" href="#simple_equal">simple_equal<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L254"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">simple_equal :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (a, b: $T) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Check whether two objects are equal on binary level.</p>
<p>This procedure checks whether the memory ranges occupied by objects <code>a</code> and
<code>b</code> are equal. See <code>compare_byte_ptrs()</code> for how this comparison is done.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="slice_data_cast"><span><a class="doc-id-link" href="#slice_data_cast">slice_data_cast<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L422"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">slice_data_cast :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> ($T: <span class="keyword-type">typeid</span>/[]$A, slice: $S/[]$B) -> $/[]$A {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Transmute slice to a different type.</p>
<p>This procedure performs an operation similar to transmute, returning a slice of
type <code>T</code> that points to the same bytes as the slice specified by <code>slice</code>
parameter. Unlike plain transmute operation, this procedure adjusts the length
of the resulting slice, such that the resulting slice points to the correct
amount of objects to cover the memory region pointed to by <code>slice</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="slice_ptr"><span><a class="doc-id-link" href="#slice_ptr">slice_ptr<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L360"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">slice_ptr :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (ptr: ^$T, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> []$T {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Construct a slice from pointer and length.</p>
<p>This procedure creates a slice, that points to <code>len</code> amount of objects located
at an address, specified by <code>ptr</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="slice_to_bytes"><span><a class="doc-id-link" href="#slice_to_bytes">slice_to_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L406"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">slice_to_bytes :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (slice: []$T) -> []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Obtain a byte slice from any slice.</p>
<p>This procedure returns a slice, that points to the same bytes as the slice,
specified by <code>slice</code> and returns the resulting byte slice.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="slice_to_components"><span><a class="doc-id-link" href="#slice_to_components">slice_to_components<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L439"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">slice_to_components :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (slice: []$T) -> (data: ^$T, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Obtain data and length of a slice.</p>
<p>This procedure returns the pointer to the start of the memory region pointed to
by slice <code>slice</code> and the length of the slice.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="small_stack_alloc"><span><a class="doc-id-link" href="#small_stack_alloc">small_stack_alloc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1299"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">small_stack_alloc :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Small_Stack">Small_Stack</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a small stack allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned to a boundary specified
by <code>alignment</code>. The allocated memory is zero-initialized. This procedure
returns a pointer to the allocated memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="small_stack_alloc_bytes"><span><a class="doc-id-link" href="#small_stack_alloc_bytes">small_stack_alloc_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1317"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">small_stack_alloc_bytes :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Small_Stack">Small_Stack</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a small stack allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned to a boundary specified
by <code>alignment</code>. The allocated memory is zero-initialized. This procedure
returns a slice of the allocated memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="small_stack_alloc_bytes_non_zeroed"><span><a class="doc-id-link" href="#small_stack_alloc_bytes_non_zeroed">small_stack_alloc_bytes_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1356"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">small_stack_alloc_bytes_non_zeroed :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Small_Stack">Small_Stack</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a small stack allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned to a boundary specified
by <code>alignment</code>. The allocated memory is not explicitly zero-initialized. This
procedure returns a slice of the allocated memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="small_stack_alloc_non_zeroed"><span><a class="doc-id-link" href="#small_stack_alloc_non_zeroed">small_stack_alloc_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1338"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">small_stack_alloc_non_zeroed :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Small_Stack">Small_Stack</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a small stack allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned to a boundary specified
by <code>alignment</code>. The allocated memory is not explicitly zero-initialized. This
procedure returns a pointer to the allocated memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="small_stack_allocator"><span><a class="doc-id-link" href="#small_stack_allocator">small_stack_allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1284"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">small_stack_allocator :: <span class="keyword-type">proc</span>(stack: ^<a class="code-typename" href="/core/mem/#Small_Stack">Small_Stack</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Small stack allocator.</p>
<p>The small stack allocator is just like a <code>Stack</code> allocator, with the only
difference being an extremely small header size. Unlike the stack allocator,
the small stack allows out-of order freeing of memory, with the stipulation
that all allocations made after the freed allocation will become invalidated
upon following allocations as they will begin to overwrite the memory formerly
used by the freed allocation.</p>
<p>The memory is allocated in the backing buffer linearly, from start to end.
Each subsequent allocation will get the next adjacent memory region.</p>
<p>The metadata is stored in the allocation headers, that are located before the
start of each allocated memory region. Each header contains the amount of
padding bytes between that header and end of the previous allocation.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="small_stack_allocator_proc"><span><a class="doc-id-link" href="#small_stack_allocator_proc">small_stack_allocator_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1594"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">small_stack_allocator_proc :: <span class="keyword-type">proc</span>(
	allocator_data:  <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	mode:            runtime.<a class="code-typename" href="/base/runtime/#Allocator_Mode">Allocator_Mode</a>, 
	size, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	old_memory:      <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:        <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="small_stack_free"><span><a class="doc-id-link" href="#small_stack_free">small_stack_free<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1395"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">small_stack_free :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Small_Stack">Small_Stack</a>, old_memory: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a small stack allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory aligned to a boundary specified
by <code>alignment</code>. The allocated memory is not explicitly zero-initialized. This
procedure returns a slice of the allocated memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="small_stack_free_all"><span><a class="doc-id-link" href="#small_stack_free_all">small_stack_free_all<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1426"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">small_stack_free_all :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Small_Stack">Small_Stack</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free all memory back to the small stack allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="small_stack_init"><span><a class="doc-id-link" href="#small_stack_init">small_stack_init<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1259"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">small_stack_init :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Small_Stack">Small_Stack</a>, data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initialize a small stack allocator.</p>
<p>This procedure initializes the small stack allocator with <code>data</code> as its backing
buffer.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="small_stack_resize"><span><a class="doc-id-link" href="#small_stack_resize">small_stack_resize<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1448"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">small_stack_resize :: <span class="keyword-type">proc</span>(
	s:          ^<a class="code-typename" href="/core/mem/#Small_Stack">Small_Stack</a>, 
	old_memory: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:   <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	size:       <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	alignment:  <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by a small stack allocator.</p>
<p>This procedure resizes a memory region defined by its location <code>old_memory</code>
and its size <code>old_size</code> to have a size <code>size</code> and alignment <code>alignment</code>. The
newly allocated memory, if any, is zero-initialized.</p>
<p>If <code>old_memory</code> is <code>nil</code>, this procedure acts just like <code>small_stack_alloc()</code>,
allocating a memory region <code>size</code> bytes in size, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>If <code>size</code> is 0, this procedure acts just like <code>small_stack_free()</code>, freeing the
memory region located at an address specified by <code>old_memory</code>.</p>
<p>This procedure returns the pointer to the resized memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="small_stack_resize_bytes"><span><a class="doc-id-link" href="#small_stack_resize_bytes">small_stack_resize_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1477"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">small_stack_resize_bytes :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Small_Stack">Small_Stack</a>, old_data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by a small stack allocator.</p>
<p>This procedure resizes a memory region specified by <code>old_data</code> to have a size
<code>size</code> and alignment <code>alignment</code>. The newly allocated memory, if any, is
zero-initialized.</p>
<p>If <code>old_memory</code> is <code>nil</code>, this procedure acts just like <code>small_stack_alloc()</code>,
allocating a memory region <code>size</code> bytes in size, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>If <code>size</code> is 0, this procedure acts just like <code>small_stack_free()</code>, freeing the
memory region located at an address specified by <code>old_memory</code>.</p>
<p>This procedure returns the slice of the resized memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="small_stack_resize_bytes_non_zeroed"><span><a class="doc-id-link" href="#small_stack_resize_bytes_non_zeroed">small_stack_resize_bytes_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1541"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">small_stack_resize_bytes_non_zeroed :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Small_Stack">Small_Stack</a>, old_data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by a small stack allocator, without zero-initialization.</p>
<p>This procedure resizes a memory region specified by <code>old_data</code> to have a size
<code>size</code> and alignment <code>alignment</code>. The newly allocated memory, if any, is not
explicitly zero-initialized.</p>
<p>If <code>old_memory</code> is <code>nil</code>, this procedure acts just like <code>small_stack_alloc()</code>,
allocating a memory region <code>size</code> bytes in size, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>If <code>size</code> is 0, this procedure acts just like <code>small_stack_free()</code>, freeing the
memory region located at an address specified by <code>old_memory</code>.</p>
<p>This procedure returns the slice of the resized memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="small_stack_resize_non_zeroed"><span><a class="doc-id-link" href="#small_stack_resize_non_zeroed">small_stack_resize_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1512"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">small_stack_resize_non_zeroed :: <span class="keyword-type">proc</span>(
	s:          ^<a class="code-typename" href="/core/mem/#Small_Stack">Small_Stack</a>, 
	old_memory: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:   <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	size:       <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	alignment:  <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by a small stack allocator, without zero-initialization.</p>
<p>This procedure resizes a memory region defined by its location <code>old_memory</code>
and its size <code>old_size</code> to have a size <code>size</code> and alignment <code>alignment</code>. The
newly allocated memory, if any, is not explicitly zero-initialized.</p>
<p>If <code>old_memory</code> is <code>nil</code>, this procedure acts just like <code>small_stack_alloc()</code>,
allocating a memory region <code>size</code> bytes in size, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>If <code>size</code> is 0, this procedure acts just like <code>small_stack_free()</code>, freeing the
memory region located at an address specified by <code>old_memory</code>.</p>
<p>This procedure returns the pointer to the resized memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="stack_alloc"><span><a class="doc-id-link" href="#stack_alloc">stack_alloc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L882"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">stack_alloc :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Stack">Stack</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a stack allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory, aligned to the boundary
specified by <code>alignment</code>. The allocated memory is zero-initialized. This
procedure returns the pointer to the allocated memory.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="stack_alloc_bytes"><span><a class="doc-id-link" href="#stack_alloc_bytes">stack_alloc_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L900"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">stack_alloc_bytes :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Stack">Stack</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a stack allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory, aligned to the boundary
specified by <code>alignment</code>. The allocated memory is zero-initialized. This
procedure returns the slice of the allocated memory.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="stack_alloc_bytes_non_zeroed"><span><a class="doc-id-link" href="#stack_alloc_bytes_non_zeroed">stack_alloc_bytes_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L939"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">stack_alloc_bytes_non_zeroed :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Stack">Stack</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a stack allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory, aligned to the boundary
specified by <code>alignment</code>. The allocated memory is not explicitly
zero-initialized. This procedure returns the slice of the allocated memory.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="stack_alloc_non_zeroed"><span><a class="doc-id-link" href="#stack_alloc_non_zeroed">stack_alloc_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L921"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">stack_alloc_non_zeroed :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Stack">Stack</a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate memory from a stack allocator.</p>
<p>This procedure allocates <code>size</code> bytes of memory, aligned to the boundary
specified by <code>alignment</code>. The allocated memory is not explicitly
zero-initialized. This procedure returns the pointer to the allocated memory.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="stack_allocator"><span><a class="doc-id-link" href="#stack_allocator">stack_allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L853"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">stack_allocator :: <span class="keyword-type">proc</span>(stack: ^<a class="code-typename" href="/core/mem/#Stack">Stack</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Stack allocator.</p>
<p>The stack allocator is an allocator that allocates data in the backing buffer
linearly, from start to end. Each subsequent allocation will get the next
adjacent memory region.</p>
<p>Unlike arena allocator, the stack allocator saves allocation metadata and has
a strict freeing order. Only the last allocated element can be freed. After the
last allocated element is freed, the next previous allocated element becomes
available for freeing.</p>
<p>The metadata is stored in the allocation headers, that are located before the
start of each allocated memory region. Each header points to the start of the
previous allocation header.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="stack_allocator_proc"><span><a class="doc-id-link" href="#stack_allocator_proc">stack_allocator_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1198"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">stack_allocator_proc :: <span class="keyword-type">proc</span>(
	allocator_data:  <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	mode:            runtime.<a class="code-typename" href="/base/runtime/#Allocator_Mode">Allocator_Mode</a>, 
	size, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	old_memory:      <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:        <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="stack_free"><span><a class="doc-id-link" href="#stack_free">stack_free<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L979"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">stack_free :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Stack">Stack</a>, old_memory: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free memory back to the stack allocator.</p>
<p>This procedure frees the memory region starting at <code>old_memory</code> to the stack.
If the freeing is an out of order freeing, the <code>.Invalid_Pointer</code> error
is returned.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="stack_free_all"><span><a class="doc-id-link" href="#stack_free_all">stack_free_all<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1016"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">stack_free_all :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Stack">Stack</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free all memory back to the stack allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="stack_init"><span><a class="doc-id-link" href="#stack_init">stack_init<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L866"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">stack_init :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Stack">Stack</a>, data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initialize a stack allocator.</p>
<p>This procedure initializes the stack allocator with a backing buffer specified
by <code>data</code> parameter.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="stack_resize"><span><a class="doc-id-link" href="#stack_resize">stack_resize<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1039"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">stack_resize :: <span class="keyword-type">proc</span>(
	s:          ^<a class="code-typename" href="/core/mem/#Stack">Stack</a>, 
	old_memory: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:   <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	size:       <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	alignment:  <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by a stack allocator.</p>
<p>This procedure resizes a memory region defined by its location <code>old_memory</code>
and its size <code>old_size</code> to have a size <code>size</code> and alignment <code>alignment</code>. The
newly allocated memory, if any, is zero-initialized.</p>
<p>If <code>old_memory</code> is <code>nil</code>, this procedure acts just like <code>stack_alloc()</code>,
allocating a memory region <code>size</code> bytes in size, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>If <code>size</code> is 0, this procedure acts just like <code>stack_free()</code>, freeing the
memory region located at an address specified by <code>old_memory</code>.</p>
<p>This procedure returns the pointer to the resized memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="stack_resize_bytes"><span><a class="doc-id-link" href="#stack_resize_bytes">stack_resize_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1068"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">stack_resize_bytes :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Stack">Stack</a>, old_data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by a stack allocator.</p>
<p>This procedure resizes a memory region specified by <code>old_data</code> to have a size
<code>size</code> and alignment <code>alignment</code>. The newly allocated memory, if any, is
zero-initialized.</p>
<p>If <code>old_memory</code> is <code>nil</code>, this procedure acts just like <code>stack_alloc()</code>,
allocating a memory region <code>size</code> bytes in size, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>If <code>size</code> is 0, this procedure acts just like <code>stack_free()</code>, freeing the
memory region located at an address specified by <code>old_memory</code>.</p>
<p>This procedure returns the slice of the resized memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="stack_resize_bytes_non_zeroed"><span><a class="doc-id-link" href="#stack_resize_bytes_non_zeroed">stack_resize_bytes_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1132"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">stack_resize_bytes_non_zeroed :: <span class="keyword-type">proc</span>(s: ^<a class="code-typename" href="/core/mem/#Stack">Stack</a>, old_data: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> ([]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by a stack allocator, without zero-initialization.</p>
<p>This procedure resizes a memory region specified by <code>old_data</code> to have a size
<code>size</code> and alignment <code>alignment</code>. The newly allocated memory, if any, is not
explicitly zero-initialized.</p>
<p>If <code>old_memory</code> is <code>nil</code>, this procedure acts just like <code>stack_alloc()</code>,
allocating a memory region <code>size</code> bytes in size, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>If <code>size</code> is 0, this procedure acts just like <code>stack_free()</code>, freeing the
memory region located at an address specified by <code>old_memory</code>.</p>
<p>This procedure returns the slice of the resized memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="stack_resize_non_zeroed"><span><a class="doc-id-link" href="#stack_resize_non_zeroed">stack_resize_non_zeroed<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin#L1103"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">stack_resize_non_zeroed :: <span class="keyword-type">proc</span>(
	s:          ^<a class="code-typename" href="/core/mem/#Stack">Stack</a>, 
	old_memory: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:   <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	size:       <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	alignment:  <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = DEFAULT_ALIGNMENT, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Resize an allocation owned by a stack allocator, without zero-initialization.</p>
<p>This procedure resizes a memory region defined by its location <code>old_memory</code>
and its size <code>old_size</code> to have a size <code>size</code> and alignment <code>alignment</code>. The
newly allocated memory, if any, is not explicitly zero-initialized.</p>
<p>If <code>old_memory</code> is <code>nil</code>, this procedure acts just like <code>stack_alloc()</code>,
allocating a memory region <code>size</code> bytes in size, aligned on a boundary specified
by <code>alignment</code>.</p>
<p>If <code>size</code> is 0, this procedure acts just like <code>stack_free()</code>, freeing the
memory region located at an address specified by <code>old_memory</code>.</p>
<p>This procedure returns the pointer to the resized memory region.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="tracking_allocator"><span><a class="doc-id-link" href="#tracking_allocator">tracking_allocator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/tracking_allocator.odin#L185"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">tracking_allocator :: <span class="keyword-type">proc</span>(data: ^<a class="code-typename" href="/core/mem/#Tracking_Allocator">Tracking_Allocator</a>) -> runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Tracking allocator.</p>
<p>The tracking allocator is an allocator wrapper that tracks memory allocations.
This allocator stores all the allocations in a map. Whenever a pointer that's
not inside of the map is freed, the <code>bad_free_array</code> entry is added.</p>
<p>Here follows an example of how to use the <code>Tracking_Allocator</code> to track
subsequent allocations in your program and report leaks. By default, the
tracking allocator will crash on bad frees. You can override that behavior by
overriding <code>track.bad_free_callback</code>.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">package foo

import "core:mem"
import "core:fmt"

main :: proc() {
	track: mem.Tracking_Allocator
	mem.tracking_allocator_init(&track, context.allocator)
	defer mem.tracking_allocator_destroy(&track)
	context.allocator = mem.tracking_allocator(&track)

	do_stuff()

	for _, leak in track.allocation_map {
		fmt.printf("%v leaked %m\n", leak.location, leak.size)
	}
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="tracking_allocator_bad_free_callback_add_to_array"><span><a class="doc-id-link" href="#tracking_allocator_bad_free_callback_add_to_array">tracking_allocator_bad_free_callback_add_to_array<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/tracking_allocator.odin#L145"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">tracking_allocator_bad_free_callback_add_to_array :: <span class="keyword-type">proc</span>(t: ^<a class="code-typename" href="/core/mem/#Tracking_Allocator">Tracking_Allocator</a>, memory: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, location: runtime.<a class="code-typename" href="/base/runtime/#Source_Code_Location">Source_Code_Location</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Alternative behavior for a bad free: Store in <code>bad_free_array</code>. If you use this,
then you must make sure to check Tracking_Allocator.bad_free_array at some point.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="tracking_allocator_bad_free_callback_panic"><span><a class="doc-id-link" href="#tracking_allocator_bad_free_callback_panic">tracking_allocator_bad_free_callback_panic<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/tracking_allocator.odin#L132"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">tracking_allocator_bad_free_callback_panic :: <span class="keyword-type">proc</span>(t: ^<a class="code-typename" href="/core/mem/#Tracking_Allocator">Tracking_Allocator</a>, memory: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, location: runtime.<a class="code-typename" href="/base/runtime/#Source_Code_Location">Source_Code_Location</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Default behavior for a bad free: Crash with error message that says where the
bad free happened.</p>
<p>Override Tracking_Allocator.bad_free_callback to have something else happen. For
example, you can use tracking_allocator_bad_free_callback_add_to_array to return
the tracking allocator to the old behavior, where the bad_free_array was used.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="tracking_allocator_clear"><span><a class="doc-id-link" href="#tracking_allocator_clear">tracking_allocator_clear<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/tracking_allocator.odin#L96"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">tracking_allocator_clear :: <span class="keyword-type">proc</span>(t: ^<a class="code-typename" href="/core/mem/#Tracking_Allocator">Tracking_Allocator</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Clear the tracking allocator.</p>
<p>This procedure clears the tracked data from a tracking allocator.</p>
<p><b>Note</b>: This procedure clears only the current allocation data while keeping
the totals intact.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="tracking_allocator_destroy"><span><a class="doc-id-link" href="#tracking_allocator_destroy">tracking_allocator_destroy<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/tracking_allocator.odin#L82"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">tracking_allocator_destroy :: <span class="keyword-type">proc</span>(t: ^<a class="code-typename" href="/core/mem/#Tracking_Allocator">Tracking_Allocator</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Destroy the tracking allocator.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="tracking_allocator_init"><span><a class="doc-id-link" href="#tracking_allocator_init">tracking_allocator_init<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/tracking_allocator.odin#L68"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">tracking_allocator_init :: <span class="keyword-type">proc</span>(t: ^<a class="code-typename" href="/core/mem/#Tracking_Allocator">Tracking_Allocator</a>, backing_allocator: runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a>, internals_allocator := <a href="/base/runtime/#Context">context.allocator</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initialize the tracking allocator.</p>
<p>This procedure initializes the tracking allocator <code>t</code> with a backing allocator
specified with <code>backing_allocator</code>. The <code>internals_allocator</code> will used to
allocate the tracked data.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="tracking_allocator_proc"><span><a class="doc-id-link" href="#tracking_allocator_proc">tracking_allocator_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/tracking_allocator.odin#L193"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">tracking_allocator_proc :: <span class="keyword-type">proc</span>(
	allocator_data:  <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	mode:            runtime.<a class="code-typename" href="/base/runtime/#Allocator_Mode">Allocator_Mode</a>, 
	size, alignment: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	old_memory:      <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, 
	old_size:        <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> (result: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="tracking_allocator_reset"><span><a class="doc-id-link" href="#tracking_allocator_reset">tracking_allocator_reset<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/tracking_allocator.odin#L110"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">tracking_allocator_reset :: <span class="keyword-type">proc</span>(t: ^<a class="code-typename" href="/core/mem/#Tracking_Allocator">Tracking_Allocator</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reset the tracking allocator.</p>
<p>Reset all of a Tracking Allocator's allocation data back to zero.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="zero"><span><a class="doc-id-link" href="#zero">zero<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L81"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">zero :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (data: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Set each byte of a memory range to zero.</p>
<p>This procedure copies the value <code>0</code> into the <code>len</code> bytes of a memory range,
starting at address <code>data</code>.</p>
<p>This procedure returns the pointer to <code>data</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="zero_explicit"><span><a class="doc-id-link" href="#zero_explicit">zero_explicit<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L99"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">zero_explicit :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (data: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Set each byte of a memory range to zero.</p>
<p>This procedure copies the value <code>0</code> into the <code>len</code> bytes of a memory range,
starting at address <code>data</code>.</p>
<p>This procedure returns the pointer to <code>data</code>.</p>
<p>Unlike the <code>zero()</code> procedure, which can be optimized away or reordered by the
compiler under certain circumstances, <code>zero_explicit()</code> procedure can not be
optimized away or reordered with other memory access operations, and the
compiler assumes volatile semantics of the memory.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="zero_item"><span><a class="doc-id-link" href="#zero_item">zero_item<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L115"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">zero_item :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (item: ^$T) -> ^$T {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Zero-fill the memory of an object.</p>
<p>This procedure sets each byte of the object pointed to by the pointer <code>item</code>
to zero, and returns the pointer to <code>item</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="zero_slice"><span><a class="doc-id-link" href="#zero_slice">zero_slice<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin#L126"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">zero_slice :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (data: $T/[]$E) -> $T/[]$E {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Zero-fill the memory of the slice.</p>
<p>This procedure sets each byte of the slice pointed to by the slice <code>data</code>
to zero, and returns the slice <code>data</code>.</p>
</details>
</div>
<h2 id="pkg-Procedure Groups" class="pkg-header">Procedure Groups</h2>
<div class="pkg-entity">
<h3 id="delete"><span><a class="doc-id-link" href="#delete">delete<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L812"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">delete :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/mem/#delete_string">delete_string</a>,
	<a class="code-procedure" href="/core/mem/#delete_cstring">delete_cstring</a>,
	<a class="code-procedure" href="/core/mem/#delete_dynamic_array">delete_dynamic_array</a>,
	<a class="code-procedure" href="/core/mem/#delete_slice">delete_slice</a>,
	<a class="code-procedure" href="/core/mem/#delete_map">delete_map</a>,
	<a class="code-procedure" href="/core/mem/#delete_soa_slice">delete_soa_slice</a>,
	<a class="code-procedure" href="/core/mem/#delete_soa_dynamic_array">delete_soa_dynamic_array</a>,
}
</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Free.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="make"><span><a class="doc-id-link" href="#make">make<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin#L1101"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">make :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/mem/#make_slice">make_slice</a>,
	<a class="code-procedure" href="/core/mem/#make_dynamic_array">make_dynamic_array</a>,
	<a class="code-procedure" href="/core/mem/#make_dynamic_array_len">make_dynamic_array_len</a>,
	<a class="code-procedure" href="/core/mem/#make_dynamic_array_len_cap">make_dynamic_array_len_cap</a>,
	<a class="code-procedure" href="/core/mem/#make_map">make_map</a>,
	<a class="code-procedure" href="/core/mem/#make_map_cap">make_map_cap</a>,
	<a class="code-procedure" href="/core/mem/#make_multi_pointer">make_multi_pointer</a>,
	<a class="code-procedure" href="/core/mem/#make_soa_slice">make_soa_slice</a>,
	<a class="code-procedure" href="/core/mem/#make_soa_dynamic_array">make_soa_dynamic_array</a>,
	<a class="code-procedure" href="/core/mem/#make_soa_dynamic_array_len">make_soa_dynamic_array_len</a>,
	<a class="code-procedure" href="/core/mem/#make_soa_dynamic_array_len_cap">make_soa_dynamic_array_len_cap</a>,
}
</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Allocate.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rollback_stack_init"><span><a class="doc-id-link" href="#rollback_stack_init">rollback_stack_init<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin#L402"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rollback_stack_init :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/mem/#rollback_stack_init_buffered">rollback_stack_init_buffered</a>,
	<a class="code-procedure" href="/core/mem/#rollback_stack_init_dynamic">rollback_stack_init_dynamic</a>,
}
</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initialize the rollback stack.</p>
</details>
</div>
</section>
<h2 id="pkg-source-files">Source Files</h2>
<ul>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/alloc.odin">alloc.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/allocators.odin">allocators.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/doc.odin">doc.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mem.odin">mem.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/mutex_allocator.odin">mutex_allocator.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/raw.odin">raw.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/rollback_stack_allocator.odin">rollback_stack_allocator.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/mem/tracking_allocator.odin">tracking_allocator.odin</a></li>
</ul>
<h2 id="pkg-generation-information">Generation Information</h2>
<p>Generated with <code>odin version dev-2025-10 (vendor "odin") Windows_amd64 @ 2025-10-10 12:59:08.782874000 +0000 UTC</code></p>
</article>
<div class="col-lg-2 odin-toc-border navbar-light"><div class="sticky-top odin-below-navbar py-3">
<nav id="TableOfContents">
<ul>
<li><a href="#pkg-overview">Overview</a><li><a href="#pkg-Types">Types</a><ul>
<li><a href="#Allocator">Allocator</a></li>
<li><a href="#Allocator_Error">Allocator_Error</a></li>
<li><a href="#Allocator_Mode">Allocator_Mode</a></li>
<li><a href="#Allocator_Mode_Set">Allocator_Mode_Set</a></li>
<li><a href="#Allocator_Proc">Allocator_Proc</a></li>
<li><a href="#Allocator_Query_Info">Allocator_Query_Info</a></li>
<li><a href="#Arena">Arena</a></li>
<li><a href="#Arena_Temp_Memory">Arena_Temp_Memory</a></li>
<li><a href="#Buddy_Allocator">Buddy_Allocator</a></li>
<li><a href="#Buddy_Block">Buddy_Block</a></li>
<li><a href="#Compat_Allocator">Compat_Allocator</a></li>
<li><a href="#Dynamic_Arena">Dynamic_Arena</a></li>
<li><a href="#Dynamic_Pool">Dynamic_Pool</a></li>
<li><a href="#Fixed_Byte_Buffer">Fixed_Byte_Buffer</a></li>
<li><a href="#Mutex_Allocator">Mutex_Allocator</a></li>
<li><a href="#Raw_Any">Raw_Any</a></li>
<li><a href="#Raw_Complex128">Raw_Complex128</a></li>
<li><a href="#Raw_Complex32">Raw_Complex32</a></li>
<li><a href="#Raw_Complex64">Raw_Complex64</a></li>
<li><a href="#Raw_Cstring">Raw_Cstring</a></li>
<li><a href="#Raw_Cstring16">Raw_Cstring16</a></li>
<li><a href="#Raw_Dynamic_Array">Raw_Dynamic_Array</a></li>
<li><a href="#Raw_Map">Raw_Map</a></li>
<li><a href="#Raw_Quaternion128">Raw_Quaternion128</a></li>
<li><a href="#Raw_Quaternion128_Vector_Scalar">Raw_Quaternion128_Vector_Scalar</a></li>
<li><a href="#Raw_Quaternion256">Raw_Quaternion256</a></li>
<li><a href="#Raw_Quaternion256_Vector_Scalar">Raw_Quaternion256_Vector_Scalar</a></li>
<li><a href="#Raw_Quaternion64">Raw_Quaternion64</a></li>
<li><a href="#Raw_Quaternion64_Vector_Scalar">Raw_Quaternion64_Vector_Scalar</a></li>
<li><a href="#Raw_Slice">Raw_Slice</a></li>
<li><a href="#Raw_Soa_Pointer">Raw_Soa_Pointer</a></li>
<li><a href="#Raw_String">Raw_String</a></li>
<li><a href="#Raw_String16">Raw_String16</a></li>
<li><a href="#Rollback_Stack">Rollback_Stack</a></li>
<li><a href="#Rollback_Stack_Block">Rollback_Stack_Block</a></li>
<li><a href="#Rollback_Stack_Header">Rollback_Stack_Header</a></li>
<li><a href="#Scratch">Scratch</a></li>
<li><a href="#Scratch_Allocator">Scratch_Allocator</a></li>
<li><a href="#Small_Stack">Small_Stack</a></li>
<li><a href="#Small_Stack_Allocation_Header">Small_Stack_Allocation_Header</a></li>
<li><a href="#Stack">Stack</a></li>
<li><a href="#Stack_Allocation_Header">Stack_Allocation_Header</a></li>
<li><a href="#Tracking_Allocator">Tracking_Allocator</a></li>
<li><a href="#Tracking_Allocator_Bad_Free_Callback">Tracking_Allocator_Bad_Free_Callback</a></li>
<li><a href="#Tracking_Allocator_Bad_Free_Entry">Tracking_Allocator_Bad_Free_Entry</a></li>
<li><a href="#Tracking_Allocator_Entry">Tracking_Allocator_Entry</a></li>
</ul>
</li>
<li><a href="#pkg-Constants">Constants</a><ul>
<li><a href="#Byte">Byte</a></li>
<li><a href="#DEFAULT_ALIGNMENT">DEFAULT_ALIGNMENT</a></li>
<li><a href="#DEFAULT_PAGE_SIZE">DEFAULT_PAGE_SIZE</a></li>
<li><a href="#DYNAMIC_ARENA_BLOCK_SIZE_DEFAULT">DYNAMIC_ARENA_BLOCK_SIZE_DEFAULT</a></li>
<li><a href="#DYNAMIC_ARENA_OUT_OF_BAND_SIZE_DEFAULT">DYNAMIC_ARENA_OUT_OF_BAND_SIZE_DEFAULT</a></li>
<li><a href="#DYNAMIC_POOL_BLOCK_SIZE_DEFAULT">DYNAMIC_POOL_BLOCK_SIZE_DEFAULT</a></li>
<li><a href="#DYNAMIC_POOL_OUT_OF_BAND_SIZE_DEFAULT">DYNAMIC_POOL_OUT_OF_BAND_SIZE_DEFAULT</a></li>
<li><a href="#Exabyte">Exabyte</a></li>
<li><a href="#Gigabyte">Gigabyte</a></li>
<li><a href="#Kilobyte">Kilobyte</a></li>
<li><a href="#Megabyte">Megabyte</a></li>
<li><a href="#Petabyte">Petabyte</a></li>
<li><a href="#ROLLBACK_STACK_DEFAULT_BLOCK_SIZE">ROLLBACK_STACK_DEFAULT_BLOCK_SIZE</a></li>
<li><a href="#ROLLBACK_STACK_MAX_HEAD_BLOCK_SIZE">ROLLBACK_STACK_MAX_HEAD_BLOCK_SIZE</a></li>
<li><a href="#Terabyte">Terabyte</a></li>
</ul>
</li>
<li><a href="#pkg-Procedures">Procedures</a><ul>
<li><a href="#align_backward">align_backward</a></li>
<li><a href="#align_backward_int">align_backward_int</a></li>
<li><a href="#align_backward_uint">align_backward_uint</a></li>
<li><a href="#align_backward_uintptr">align_backward_uintptr</a></li>
<li><a href="#align_formula">align_formula</a></li>
<li><a href="#align_forward">align_forward</a></li>
<li><a href="#align_forward_int">align_forward_int</a></li>
<li><a href="#align_forward_uint">align_forward_uint</a></li>
<li><a href="#align_forward_uintptr">align_forward_uintptr</a></li>
<li><a href="#alloc">alloc</a></li>
<li><a href="#alloc_bytes">alloc_bytes</a></li>
<li><a href="#alloc_bytes_non_zeroed">alloc_bytes_non_zeroed</a></li>
<li><a href="#any_to_bytes">any_to_bytes</a></li>
<li><a href="#arena_alloc">arena_alloc</a></li>
<li><a href="#arena_alloc_bytes">arena_alloc_bytes</a></li>
<li><a href="#arena_alloc_bytes_non_zeroed">arena_alloc_bytes_non_zeroed</a></li>
<li><a href="#arena_alloc_non_zeroed">arena_alloc_non_zeroed</a></li>
<li><a href="#arena_allocator">arena_allocator</a></li>
<li><a href="#arena_allocator_proc">arena_allocator_proc</a></li>
<li><a href="#arena_free_all">arena_free_all</a></li>
<li><a href="#arena_init">arena_init</a></li>
<li><a href="#begin_arena_temp_memory">begin_arena_temp_memory</a></li>
<li><a href="#buddy_allocator">buddy_allocator</a></li>
<li><a href="#buddy_allocator_alloc">buddy_allocator_alloc</a></li>
<li><a href="#buddy_allocator_alloc_bytes">buddy_allocator_alloc_bytes</a></li>
<li><a href="#buddy_allocator_alloc_bytes_non_zeroed">buddy_allocator_alloc_bytes_non_zeroed</a></li>
<li><a href="#buddy_allocator_alloc_non_zeroed">buddy_allocator_alloc_non_zeroed</a></li>
<li><a href="#buddy_allocator_free">buddy_allocator_free</a></li>
<li><a href="#buddy_allocator_free_all">buddy_allocator_free_all</a></li>
<li><a href="#buddy_allocator_init">buddy_allocator_init</a></li>
<li><a href="#buddy_allocator_proc">buddy_allocator_proc</a></li>
<li><a href="#buddy_block_coalescence">buddy_block_coalescence</a></li>
<li><a href="#buddy_block_find_best">buddy_block_find_best</a></li>
<li><a href="#buddy_block_next">buddy_block_next</a></li>
<li><a href="#buddy_block_size_required">buddy_block_size_required</a></li>
<li><a href="#buddy_block_split">buddy_block_split</a></li>
<li><a href="#buffer_from_slice">buffer_from_slice</a></li>
<li><a href="#byte_slice">byte_slice</a></li>
<li><a href="#calc_padding_with_header">calc_padding_with_header</a></li>
<li><a href="#check_zero">check_zero</a></li>
<li><a href="#check_zero_ptr">check_zero_ptr</a></li>
<li><a href="#compare">compare</a></li>
<li><a href="#compare_byte_ptrs">compare_byte_ptrs</a></li>
<li><a href="#compare_ptrs">compare_ptrs</a></li>
<li><a href="#compat_allocator">compat_allocator</a></li>
<li><a href="#compat_allocator_init">compat_allocator_init</a></li>
<li><a href="#compat_allocator_proc">compat_allocator_proc</a></li>
<li><a href="#context_from_allocator">context_from_allocator</a></li>
<li><a href="#copy">copy</a></li>
<li><a href="#copy_non_overlapping">copy_non_overlapping</a></li>
<li><a href="#default_resize_align">default_resize_align</a></li>
<li><a href="#default_resize_bytes_align">default_resize_bytes_align</a></li>
<li><a href="#default_resize_bytes_align_non_zeroed">default_resize_bytes_align_non_zeroed</a></li>
<li><a href="#delete_cstring">delete_cstring</a></li>
<li><a href="#delete_dynamic_array">delete_dynamic_array</a></li>
<li><a href="#delete_map">delete_map</a></li>
<li><a href="#delete_slice">delete_slice</a></li>
<li><a href="#delete_soa_dynamic_array">delete_soa_dynamic_array</a></li>
<li><a href="#delete_soa_slice">delete_soa_slice</a></li>
<li><a href="#delete_string">delete_string</a></li>
<li><a href="#dynamic_arena_alloc">dynamic_arena_alloc</a></li>
<li><a href="#dynamic_arena_alloc_bytes">dynamic_arena_alloc_bytes</a></li>
<li><a href="#dynamic_arena_alloc_bytes_non_zeroed">dynamic_arena_alloc_bytes_non_zeroed</a></li>
<li><a href="#dynamic_arena_alloc_non_zeroed">dynamic_arena_alloc_non_zeroed</a></li>
<li><a href="#dynamic_arena_allocator">dynamic_arena_allocator</a></li>
<li><a href="#dynamic_arena_allocator_proc">dynamic_arena_allocator_proc</a></li>
<li><a href="#dynamic_arena_destroy">dynamic_arena_destroy</a></li>
<li><a href="#dynamic_arena_free_all">dynamic_arena_free_all</a></li>
<li><a href="#dynamic_arena_init">dynamic_arena_init</a></li>
<li><a href="#dynamic_arena_reset">dynamic_arena_reset</a></li>
<li><a href="#dynamic_arena_resize">dynamic_arena_resize</a></li>
<li><a href="#dynamic_arena_resize_bytes">dynamic_arena_resize_bytes</a></li>
<li><a href="#dynamic_arena_resize_bytes_non_zeroed">dynamic_arena_resize_bytes_non_zeroed</a></li>
<li><a href="#dynamic_arena_resize_non_zeroed">dynamic_arena_resize_non_zeroed</a></li>
<li><a href="#dynamic_pool_alloc">dynamic_pool_alloc</a></li>
<li><a href="#dynamic_pool_alloc_bytes">dynamic_pool_alloc_bytes</a></li>
<li><a href="#dynamic_pool_allocator">dynamic_pool_allocator</a></li>
<li><a href="#dynamic_pool_allocator_proc">dynamic_pool_allocator_proc</a></li>
<li><a href="#dynamic_pool_destroy">dynamic_pool_destroy</a></li>
<li><a href="#dynamic_pool_free_all">dynamic_pool_free_all</a></li>
<li><a href="#dynamic_pool_init">dynamic_pool_init</a></li>
<li><a href="#dynamic_pool_reset">dynamic_pool_reset</a></li>
<li><a href="#end_arena_temp_memory">end_arena_temp_memory</a></li>
<li><a href="#free">free</a></li>
<li><a href="#free_all">free_all</a></li>
<li><a href="#free_bytes">free_bytes</a></li>
<li><a href="#free_with_size">free_with_size</a></li>
<li><a href="#is_aligned">is_aligned</a></li>
<li><a href="#is_power_of_two">is_power_of_two</a></li>
<li><a href="#make_aligned">make_aligned</a></li>
<li><a href="#make_any">make_any</a></li>
<li><a href="#make_dynamic_array">make_dynamic_array</a></li>
<li><a href="#make_dynamic_array_len">make_dynamic_array_len</a></li>
<li><a href="#make_dynamic_array_len_cap">make_dynamic_array_len_cap</a></li>
<li><a href="#make_fixed_byte_buffer">make_fixed_byte_buffer</a></li>
<li><a href="#make_map">make_map</a></li>
<li><a href="#make_map_cap">make_map_cap</a></li>
<li><a href="#make_multi_pointer">make_multi_pointer</a></li>
<li><a href="#make_over_aligned">make_over_aligned</a></li>
<li><a href="#make_slice">make_slice</a></li>
<li><a href="#make_soa_dynamic_array">make_soa_dynamic_array</a></li>
<li><a href="#make_soa_dynamic_array_len">make_soa_dynamic_array_len</a></li>
<li><a href="#make_soa_dynamic_array_len_cap">make_soa_dynamic_array_len_cap</a></li>
<li><a href="#make_soa_slice">make_soa_slice</a></li>
<li><a href="#mutex_allocator">mutex_allocator</a></li>
<li><a href="#mutex_allocator_init">mutex_allocator_init</a></li>
<li><a href="#mutex_allocator_proc">mutex_allocator_proc</a></li>
<li><a href="#new">new</a></li>
<li><a href="#new_aligned">new_aligned</a></li>
<li><a href="#new_clone">new_clone</a></li>
<li><a href="#nil_allocator">nil_allocator</a></li>
<li><a href="#nil_allocator_proc">nil_allocator_proc</a></li>
<li><a href="#panic_allocator">panic_allocator</a></li>
<li><a href="#panic_allocator_proc">panic_allocator_proc</a></li>
<li><a href="#ptr_offset">ptr_offset</a></li>
<li><a href="#ptr_sub">ptr_sub</a></li>
<li><a href="#ptr_to_bytes">ptr_to_bytes</a></li>
<li><a href="#query_features">query_features</a></li>
<li><a href="#query_info">query_info</a></li>
<li><a href="#raw_data">raw_data</a></li>
<li><a href="#rb_alloc">rb_alloc</a></li>
<li><a href="#rb_alloc_bytes">rb_alloc_bytes</a></li>
<li><a href="#rb_alloc_bytes_non_zeroed">rb_alloc_bytes_non_zeroed</a></li>
<li><a href="#rb_alloc_non_zeroed">rb_alloc_non_zeroed</a></li>
<li><a href="#rb_resize">rb_resize</a></li>
<li><a href="#rb_resize_bytes">rb_resize_bytes</a></li>
<li><a href="#rb_resize_bytes_non_zeroed">rb_resize_bytes_non_zeroed</a></li>
<li><a href="#rb_resize_non_zeroed">rb_resize_non_zeroed</a></li>
<li><a href="#reinterpret_copy">reinterpret_copy</a></li>
<li><a href="#resize">resize</a></li>
<li><a href="#resize_bytes">resize_bytes</a></li>
<li><a href="#resize_bytes_non_zeroed">resize_bytes_non_zeroed</a></li>
<li><a href="#resize_non_zeroed">resize_non_zeroed</a></li>
<li><a href="#rollback_stack_allocator">rollback_stack_allocator</a></li>
<li><a href="#rollback_stack_allocator_proc">rollback_stack_allocator_proc</a></li>
<li><a href="#rollback_stack_destroy">rollback_stack_destroy</a></li>
<li><a href="#rollback_stack_init_buffered">rollback_stack_init_buffered</a></li>
<li><a href="#rollback_stack_init_dynamic">rollback_stack_init_dynamic</a></li>
<li><a href="#scratch_alloc">scratch_alloc</a></li>
<li><a href="#scratch_alloc_bytes">scratch_alloc_bytes</a></li>
<li><a href="#scratch_alloc_bytes_non_zeroed">scratch_alloc_bytes_non_zeroed</a></li>
<li><a href="#scratch_alloc_non_zeroed">scratch_alloc_non_zeroed</a></li>
<li><a href="#scratch_allocator">scratch_allocator</a></li>
<li><a href="#scratch_allocator_destroy">scratch_allocator_destroy</a></li>
<li><a href="#scratch_allocator_init">scratch_allocator_init</a></li>
<li><a href="#scratch_allocator_proc">scratch_allocator_proc</a></li>
<li><a href="#scratch_destroy">scratch_destroy</a></li>
<li><a href="#scratch_free">scratch_free</a></li>
<li><a href="#scratch_free_all">scratch_free_all</a></li>
<li><a href="#scratch_init">scratch_init</a></li>
<li><a href="#scratch_resize">scratch_resize</a></li>
<li><a href="#scratch_resize_bytes">scratch_resize_bytes</a></li>
<li><a href="#scratch_resize_bytes_non_zeroed">scratch_resize_bytes_non_zeroed</a></li>
<li><a href="#scratch_resize_non_zeroed">scratch_resize_non_zeroed</a></li>
<li><a href="#set">set</a></li>
<li><a href="#simple_equal">simple_equal</a></li>
<li><a href="#slice_data_cast">slice_data_cast</a></li>
<li><a href="#slice_ptr">slice_ptr</a></li>
<li><a href="#slice_to_bytes">slice_to_bytes</a></li>
<li><a href="#slice_to_components">slice_to_components</a></li>
<li><a href="#small_stack_alloc">small_stack_alloc</a></li>
<li><a href="#small_stack_alloc_bytes">small_stack_alloc_bytes</a></li>
<li><a href="#small_stack_alloc_bytes_non_zeroed">small_stack_alloc_bytes_non_zeroed</a></li>
<li><a href="#small_stack_alloc_non_zeroed">small_stack_alloc_non_zeroed</a></li>
<li><a href="#small_stack_allocator">small_stack_allocator</a></li>
<li><a href="#small_stack_allocator_proc">small_stack_allocator_proc</a></li>
<li><a href="#small_stack_free">small_stack_free</a></li>
<li><a href="#small_stack_free_all">small_stack_free_all</a></li>
<li><a href="#small_stack_init">small_stack_init</a></li>
<li><a href="#small_stack_resize">small_stack_resize</a></li>
<li><a href="#small_stack_resize_bytes">small_stack_resize_bytes</a></li>
<li><a href="#small_stack_resize_bytes_non_zeroed">small_stack_resize_bytes_non_zeroed</a></li>
<li><a href="#small_stack_resize_non_zeroed">small_stack_resize_non_zeroed</a></li>
<li><a href="#stack_alloc">stack_alloc</a></li>
<li><a href="#stack_alloc_bytes">stack_alloc_bytes</a></li>
<li><a href="#stack_alloc_bytes_non_zeroed">stack_alloc_bytes_non_zeroed</a></li>
<li><a href="#stack_alloc_non_zeroed">stack_alloc_non_zeroed</a></li>
<li><a href="#stack_allocator">stack_allocator</a></li>
<li><a href="#stack_allocator_proc">stack_allocator_proc</a></li>
<li><a href="#stack_free">stack_free</a></li>
<li><a href="#stack_free_all">stack_free_all</a></li>
<li><a href="#stack_init">stack_init</a></li>
<li><a href="#stack_resize">stack_resize</a></li>
<li><a href="#stack_resize_bytes">stack_resize_bytes</a></li>
<li><a href="#stack_resize_bytes_non_zeroed">stack_resize_bytes_non_zeroed</a></li>
<li><a href="#stack_resize_non_zeroed">stack_resize_non_zeroed</a></li>
<li><a href="#tracking_allocator">tracking_allocator</a></li>
<li><a href="#tracking_allocator_bad_free_callback_add_to_array">tracking_allocator_bad_free_callback_add_to_array</a></li>
<li><a href="#tracking_allocator_bad_free_callback_panic">tracking_allocator_bad_free_callback_panic</a></li>
<li><a href="#tracking_allocator_clear">tracking_allocator_clear</a></li>
<li><a href="#tracking_allocator_destroy">tracking_allocator_destroy</a></li>
<li><a href="#tracking_allocator_init">tracking_allocator_init</a></li>
<li><a href="#tracking_allocator_proc">tracking_allocator_proc</a></li>
<li><a href="#tracking_allocator_reset">tracking_allocator_reset</a></li>
<li><a href="#zero">zero</a></li>
<li><a href="#zero_explicit">zero_explicit</a></li>
<li><a href="#zero_item">zero_item</a></li>
<li><a href="#zero_slice">zero_slice</a></li>
</ul>
</li>
<li><a href="#pkg-Procedure Groups">Procedure Groups</a><ul>
<li><a href="#delete">delete</a></li>
<li><a href="#make">make</a></li>
<li><a href="#rollback_stack_init">rollback_stack_init</a></li>
</ul>
</li>
<li><a href="#pkg-source-files">Source Files</a></ul>
</nav>
</div></div>
<script type="text/javascript">var odin_pkg_name = "mem";</script>
</div>

</div>
</main>

<footer class="odin-footer">
	<div class="container pb-5 pt-5">
		<div class="row g-4">
		<div class="col">
		<a class="navbar-brand" href="https://odin-lang.org">
		<img class="mb-3" src="https://odin-lang.org/logo.svg" height="30" alt="Odin"></a>
		<p>
		The Data-Oriented Language for Sane Software Development.
		</p>
		</div>
		<nav class="col-md-auto">
			<h4 class="fw-normal">Resources</h4>
			<ul class="list-unstyled">
			<li><a href="https://odin-lang.org/docs" class="link-light">Docs</a></li>
			<li><a href="https://pkg.odin-lang.org/" class="link-light">Packages</a></li>
			<li><a href="https://odin-lang.org/news" class="link-light">News</a></li>
			</ul>
		</nav>
		<nav class="col-md-auto">
			<h4 class="fw-normal">Community</h4>
			<ul class="list-unstyled">
			<li><a href="https://github.com/odin-lang/Odin" target="_blank" class="link-light">GitHub</a></li>
			<li><a href="https://forum.odin-lang.org" target="_blank" class="link-light">Forum</a></li>
			<li><a href="https://discord.com/invite/sVBPHEv" target="_blank" class="link-light">Discord</a></li>
			<li><a href="https://www.twitch.tv/ginger_bill" target="_blank" class="link-light">Twitch</a></li>
			<li><a href="https://www.youtube.com/channel/UCUSck1dOH7VKmG4lRW7tZXg" target="_blank" class="link-light">YouTube</a></li>
			<li><a href="https://odin-lang.org/showcase" target="_blank" class="link-light">Showcase</a></li>
			</ul>
		</nav>
		<nav class="col-md-auto">
			<h4 class="fw-normal">Contribute</h4>
			<ul class="list-unstyled">
			<li><a href="https://github.com/odin-lang/Odin/issues" target="_blank" class="link-light">Issues</a></li>
			<li><a href="https://www.patreon.com/gingerbill" target="_blank" class="link-light">Donate</a></li>
			</ul>
			</nav>
		</div>
		<div class="mt-4 text-muted">© 2016–2023 Ginger Bill</div>
	</div>
</footer>

<script src="https://odin-lang.org/lib/bootstrap/js/bootstrap.min.js"></script>
<script src="https://odin-lang.org/js/script.js"></script>
<script src="/pkg-data.js"></script>
<script src="/search.js"></script>
</body>
</html>
