<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>package strings - pkg.odin-lang.org</title>	<link rel="icon" href="/favicon.svg">
	<link rel="stylesheet" type="text/css" href="https://odin-lang.org/scss/custom.min.css">
	<link rel=stylesheet href="//odin-lang.org/lib/highlight/styles/github-dark.min.css">
	<script src="//odin-lang.org/lib/highlight/highlight.min.js"></script>

	<script>hljs.registerLanguage("odin",function(a){return{aliases:["odin","odinlang","odin-lang"],keywords:{keyword:"auto_cast bit_set break case cast context continue defer distinct do dynamic else enum fallthrough for foreign if import in map not_in or_else or_return package proc return struct switch transmute type_of typeid union using when where",literal:"true false nil",built_in:"abs align_of cap clamp complex conj expand_to_tuple imag jmag kmag len max min offset_of quaternion real size_of soa_unzip soa_zip swizzle type_info_of type_of typeid_of"},illegal:"</",contains:[a.C_LINE_COMMENT_MODE,a.C_BLOCK_COMMENT_MODE,{className:"string",variants:[a.QUOTE_STRING_MODE,{begin:"'",end:"[^\\\\]'"},{begin:"`",end:"`"}]},{className:"number",variants:[{begin:a.C_NUMBER_RE+"[ijk]",relevance:1},a.C_NUMBER_MODE]}]}})</script>
	<script>hljs.highlightAll()</script>
	<script>
		function OSDarkModeQuery() {
			return window.matchMedia?.("(prefers-color-scheme: dark)");
		}
		function setDarkMode() {
			document.body.classList.add("dark-mode");
			window.localStorage.setItem("theme", "dark");
		}
		function removeDarkMode() {
			document.body.classList.remove("dark-mode");
			window.localStorage.setItem("theme", "light");
		}
		function toggleDarkMode() {
			if (document.body.classList.contains("dark-mode")) removeDarkMode()
			else setDarkMode()
		}
		function syncThemeToOS() {
			if (OSDarkModeQuery().matches) setDarkMode()
			else removeDarkMode()
		}
		document.addEventListener("DOMContentLoaded", () => {
			OSDarkModeQuery().addEventListener("change", syncThemeToOS);
		});
	</script>
	<link rel="stylesheet" type="text/css" href="https://odin-lang.org/css/style.css">

	<link rel="stylesheet" type="text/css" href="/style.css">

	</style>
</head>
<body>
<script>
	const themeSet = window.localStorage.getItem("theme");
	if (themeSet === null) {
		syncThemeToOS();
	} else if (themeSet === "dark") {
		setDarkMode();
	} else if (themeSet === "light") {
		removeDarkMode();
	}
</script>
<header class="sticky-top">
	<nav class="navbar navbar-expand-lg navbar-dark bg-primary odin-menu">
		<div class="container">
			<a class="navbar-brand" href="https://odin-lang.org/">
			<img src="https://odin-lang.org/logo.svg" height="30" alt="Odin"></a>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#odin-navbar-content" aria-controls="odin-navbar-content" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
			<div class="collapse navbar-collapse" id="odin-navbar-content">
			<ul class="navbar-nav ms-md-auto">
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/">Home</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/docs">Docs</a></li>
				<li class="nav-item"><a class="nav-link active" href="/">Packages</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/news">News</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/showcase">Showcase</a></li>
				<li class="nav-item"><a class="nav-link" href="https://forum.odin-lang.org">Forum</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/community">Community</a></li>
				<li class="nav-item"><a class="nav-link" href="https://github.com/odin-lang/Odin" target="_blank">GitHub</a></li>
				<li class="nav-item">
					<a
						class="nav-link btn-dark-mode"
						onclick="toggleDarkMode();"
						title="Toggle Light/Dark Mode"
					>
						<span class="dark-mode-appearance">Appearance:</span>
						<svg fill="white" id="dark-mode-icon" viewBox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"/></svg>
						<svg fill="white" id="light-mode-icon" viewBox="0 0 16 16">
						  <path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8M8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0m0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13m8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5M3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8m10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0m-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0m9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707M4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708"/>
						</svg>
					</button>
					</a>
				</li>
			</ul>
		</div>
		</div>
	</nav>
</header>
<main>
<div class="container full-width">
<div class="row odin-main my-4" id="pkg">
<nav id="pkg-sidebar" class="col-lg-2 odin-sidebar-border navbar-light sticky-top odin-below-navbar">
<div class="py-3">
<h4><a style="text-transform: capitalize; color: inherit;" href="/core">core Library</a></h4>
<ul>
<li class="nav-item"><a href="/core/bufio">bufio</a></li>
<li class="nav-item"><a href="/core/bytes">bytes</a></li>
<li class="nav-item"><a href="/core/c">c</a><ul>
<li><a href="/core/c/libc">libc</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/compress">compress</a><ul>
<li><a href="/core/compress/gzip">gzip</a></li>
<li><a href="/core/compress/shoco">shoco</a></li>
<li><a href="/core/compress/zlib">zlib</a></li>
</ul>

</li>
<li class="nav-item">container<ul>
<li><a href="/core/container/avl">avl</a></li>
<li><a href="/core/container/bit_array">bit_array</a></li>
<li><a href="/core/container/intrusive/list">intrusive/list</a></li>
<li><a href="/core/container/lru">lru</a></li>
<li><a href="/core/container/priority_queue">priority_queue</a></li>
<li><a href="/core/container/queue">queue</a></li>
<li><a href="/core/container/rbtree">rbtree</a></li>
<li><a href="/core/container/small_array">small_array</a></li>
<li><a href="/core/container/topological_sort">topological_sort</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/crypto">crypto</a><ul>
<li><a href="/core/crypto/aead">aead</a></li>
<li><a href="/core/crypto/aegis">aegis</a></li>
<li><a href="/core/crypto/aes">aes</a></li>
<li><a href="/core/crypto/blake2b">blake2b</a></li>
<li><a href="/core/crypto/blake2s">blake2s</a></li>
<li><a href="/core/crypto/chacha20">chacha20</a></li>
<li><a href="/core/crypto/chacha20poly1305">chacha20poly1305</a></li>
<li><a href="/core/crypto/deoxysii">deoxysii</a></li>
<li><a href="/core/crypto/ed25519">ed25519</a></li>
<li><a href="/core/crypto/hash">hash</a></li>
<li><a href="/core/crypto/hkdf">hkdf</a></li>
<li><a href="/core/crypto/hmac">hmac</a></li>
<li><a href="/core/crypto/kmac">kmac</a></li>
<li><a href="/core/crypto/legacy/keccak">legacy/keccak</a></li>
<li><a href="/core/crypto/legacy/md5">legacy/md5</a></li>
<li><a href="/core/crypto/legacy/sha1">legacy/sha1</a></li>
<li><a href="/core/crypto/pbkdf2">pbkdf2</a></li>
<li><a href="/core/crypto/poly1305">poly1305</a></li>
<li><a href="/core/crypto/ristretto255">ristretto255</a></li>
<li><a href="/core/crypto/sha2">sha2</a></li>
<li><a href="/core/crypto/sha3">sha3</a></li>
<li><a href="/core/crypto/shake">shake</a></li>
<li><a href="/core/crypto/sm3">sm3</a></li>
<li><a href="/core/crypto/tuplehash">tuplehash</a></li>
<li><a href="/core/crypto/x25519">x25519</a></li>
<li><a href="/core/crypto/x448">x448</a></li>
</ul>

</li>
<li class="nav-item">debug<ul>
<li><a href="/core/debug/pe">pe</a></li>
<li><a href="/core/debug/trace">trace</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/dynlib">dynlib</a></li>
<li class="nav-item">encoding<ul>
<li><a href="/core/encoding/base32">base32</a></li>
<li><a href="/core/encoding/base64">base64</a></li>
<li><a href="/core/encoding/cbor">cbor</a></li>
<li><a href="/core/encoding/csv">csv</a></li>
<li><a href="/core/encoding/endian">endian</a></li>
<li><a href="/core/encoding/entity">entity</a></li>
<li><a href="/core/encoding/hex">hex</a></li>
<li><a href="/core/encoding/hxa">hxa</a></li>
<li><a href="/core/encoding/ini">ini</a></li>
<li><a href="/core/encoding/json">json</a></li>
<li><a href="/core/encoding/uuid">uuid</a></li>
<li><a href="/core/encoding/uuid/legacy">uuid/legacy</a></li>
<li><a href="/core/encoding/varint">varint</a></li>
<li><a href="/core/encoding/xml">xml</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/flags">flags</a></li>
<li class="nav-item"><a href="/core/fmt">fmt</a></li>
<li class="nav-item"><a href="/core/hash">hash</a><ul>
<li><a href="/core/hash/xxhash">xxhash</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/image">image</a><ul>
<li><a href="/core/image/bmp">bmp</a></li>
<li><a href="/core/image/netpbm">netpbm</a></li>
<li><a href="/core/image/png">png</a></li>
<li><a href="/core/image/qoi">qoi</a></li>
<li><a href="/core/image/tga">tga</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/io">io</a></li>
<li class="nav-item"><a href="/core/log">log</a></li>
<li class="nav-item"><a href="/core/math">math</a><ul>
<li><a href="/core/math/big">big</a></li>
<li><a href="/core/math/bits">bits</a></li>
<li><a href="/core/math/cmplx">cmplx</a></li>
<li><a href="/core/math/ease">ease</a></li>
<li><a href="/core/math/fixed">fixed</a></li>
<li><a href="/core/math/linalg">linalg</a></li>
<li><a href="/core/math/linalg/glsl">linalg/glsl</a></li>
<li><a href="/core/math/linalg/hlsl">linalg/hlsl</a></li>
<li><a href="/core/math/noise">noise</a></li>
<li><a href="/core/math/rand">rand</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/mem">mem</a><ul>
<li><a href="/core/mem/tlsf">tlsf</a></li>
<li><a href="/core/mem/virtual">virtual</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/net">net</a></li>
<li class="nav-item">odin<ul>
<li><a href="/core/odin/ast">ast</a></li>
<li><a href="/core/odin/doc-format">doc-format</a></li>
<li><a href="/core/odin/parser">parser</a></li>
<li><a href="/core/odin/tokenizer">tokenizer</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/os">os</a></li>
<li class="nav-item">path<ul>
<li><a href="/core/path/filepath">filepath</a></li>
<li><a href="/core/path/slashpath">slashpath</a></li>
</ul>

</li>
<li class="nav-item">prof<ul>
<li><a href="/core/prof/spall">spall</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/reflect">reflect</a></li>
<li class="nav-item"><a href="/core/relative">relative</a></li>
<li class="nav-item"><a href="/core/simd">simd</a><ul>
<li><a href="/core/simd/x86">x86</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/slice">slice</a><ul>
<li><a href="/core/slice/heap">heap</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/sort">sort</a></li>
<li class="nav-item"><a href="/core/strconv">strconv</a><ul>
<li><a href="/core/strconv/decimal">decimal</a></li>
</ul>

</li>
<li class="nav-item"><a class="active" href="/core/strings">strings</a></li>
<li class="nav-item"><a href="/core/sync">sync</a><ul>
<li><a href="/core/sync/chan">chan</a></li>
</ul>

</li>
<li class="nav-item">sys<ul>
<li><a href="/core/sys/darwin">darwin</a></li>
<li><a href="/core/sys/darwin/CoreFoundation">darwin/CoreFoundation</a></li>
<li><a href="/core/sys/darwin/Foundation">darwin/Foundation</a></li>
<li><a href="/core/sys/darwin/Security">darwin/Security</a></li>
<li><a href="/core/sys/freebsd">freebsd</a></li>
<li><a href="/core/sys/haiku">haiku</a></li>
<li><a href="/core/sys/info">info</a></li>
<li><a href="/core/sys/kqueue">kqueue</a></li>
<li><a href="/core/sys/linux">linux</a></li>
<li><a href="/core/sys/orca">orca</a></li>
<li><a href="/core/sys/posix">posix</a></li>
<li><a href="/core/sys/unix">unix</a></li>
<li><a href="/core/sys/valgrind">valgrind</a></li>
<li><a href="/core/sys/windows">windows</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/terminal">terminal</a><ul>
<li><a href="/core/terminal/ansi">ansi</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/testing">testing</a></li>
<li class="nav-item">text<ul>
<li><a href="/core/text/edit">edit</a></li>
<li><a href="/core/text/i18n">i18n</a></li>
<li><a href="/core/text/match">match</a></li>
<li><a href="/core/text/regex">regex</a></li>
<li><a href="/core/text/regex/common">regex/common</a></li>
<li><a href="/core/text/regex/compiler">regex/compiler</a></li>
<li><a href="/core/text/regex/optimizer">regex/optimizer</a></li>
<li><a href="/core/text/regex/parser">regex/parser</a></li>
<li><a href="/core/text/regex/tokenizer">regex/tokenizer</a></li>
<li><a href="/core/text/regex/virtual_machine">regex/virtual_machine</a></li>
<li><a href="/core/text/scanner">scanner</a></li>
<li><a href="/core/text/table">table</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/thread">thread</a></li>
<li class="nav-item"><a href="/core/time">time</a><ul>
<li><a href="/core/time/datetime">datetime</a></li>
<li><a href="/core/time/timezone">timezone</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/unicode">unicode</a><ul>
<li><a href="/core/unicode/utf16">utf16</a></li>
<li><a href="/core/unicode/utf8">utf8</a></li>
<li><a href="/core/unicode/utf8/utf8string">utf8/utf8string</a></li>
</ul>

</li>
</ul>
</div>
</nav>
<article class="col-lg-8 p-4 documentation odin-article">
<nav class="pkg-breadcrumb" aria-label="breadcrumb">
<ol class="breadcrumb">
<li class="breadcrumb-item"><a href="/core">core</a></li>
<li class="breadcrumb-item active" aria-current="page"><a href="/core/strings">strings</a></li>
</ol>
</nav>
<h1>package core:strings<div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings"><em>Source</em></a></div></h1>

		<div class="odin-search-wrapper">
			<input type="search" id="odin-search" class="odin-search-package" autocomplete="off" spellcheck="false" placeholder="Fuzzy Search...">
			<div class="odin-search-shortcut">
				<div class="odin-search-key key-macos">⌘K</div>
				<div class="odin-search-key key-windows">Ctrl+K</div>
				<span class="odin-search-or">or</span>
				<div class="odin-search-key">/</div>
			</div>
		</div>
	
<div id="odin-search-info">
<div id="odin-search-time"></div>

		<div id="odin-search-options">
			<input type="checkbox" id="odin-search-filter" name="odin-search-filter">
			<label for="odin-search-filter">Filter Results</label>
		</div>
</div>
<ul id="odin-search-results"></ul>
<div id="pkg-top">
<h2>Overview</h2>
<div id="pkg-overview">
<p>Procedures to manipulate UTF-8 encoded strings</p>
</div>
<div id="pkg-index">
<h2>Index</h2>
<div>
<details class="doc-index" id="doc-index-Types" aria-labelledby="#doc-index-Types-header">
<summary id="#doc-index-Types-header">
Types (6)</summary>
<ul>
<li><a href="#Ascii_Set">Ascii_Set</a></li>
<li><a href="#Builder">Builder</a></li>
<li><a href="#Builder_Flush_Proc">Builder_Flush_Proc</a></li>
<li><a href="#Intern">Intern</a></li>
<li><a href="#Intern_Entry">Intern_Entry</a></li>
<li><a href="#Reader">Reader</a></li>
</ul>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Constants" aria-labelledby="#doc-index-Constants-header">
<summary id="#doc-index-Constants-header">
Constants (0)</summary>
<p class="pkg-empty-section">This section is empty.</p>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Variables" aria-labelledby="#doc-index-Variables-header">
<summary id="#doc-index-Variables-header">
Variables (0)</summary>
<p class="pkg-empty-section">This section is empty.</p>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Procedures" aria-labelledby="#doc-index-Procedures-header">
<summary id="#doc-index-Procedures-header">
Procedures (169)</summary>
<ul>
<li><a href="#ascii_set_contains">ascii_set_contains</a></li>
<li><a href="#ascii_set_make">ascii_set_make</a></li>
<li><a href="#builder_cap">builder_cap</a></li>
<li><a href="#builder_destroy">builder_destroy</a></li>
<li><a href="#builder_from_bytes">builder_from_bytes</a></li>
<li><a href="#builder_from_slice">builder_from_slice</a></li>
<li><a href="#builder_grow">builder_grow</a></li>
<li><a href="#builder_init_len">builder_init_len</a></li>
<li><a href="#builder_init_len_cap">builder_init_len_cap</a></li>
<li><a href="#builder_init_none">builder_init_none</a></li>
<li><a href="#builder_len">builder_len</a></li>
<li><a href="#builder_make_len">builder_make_len</a></li>
<li><a href="#builder_make_len_cap">builder_make_len_cap</a></li>
<li><a href="#builder_make_none">builder_make_none</a></li>
<li><a href="#builder_reset">builder_reset</a></li>
<li><a href="#builder_space">builder_space</a></li>
<li><a href="#center_justify">center_justify</a></li>
<li><a href="#centre_justify">centre_justify</a></li>
<li><a href="#clone">clone</a></li>
<li><a href="#clone_from_bytes">clone_from_bytes</a></li>
<li><a href="#clone_from_cstring">clone_from_cstring</a></li>
<li><a href="#clone_from_cstring_bounded">clone_from_cstring_bounded</a></li>
<li><a href="#clone_from_ptr">clone_from_ptr</a></li>
<li><a href="#clone_to_cstring">clone_to_cstring</a></li>
<li><a href="#common_prefix">common_prefix</a></li>
<li><a href="#compare">compare</a></li>
<li><a href="#concatenate">concatenate</a></li>
<li><a href="#contains">contains</a></li>
<li><a href="#contains_any">contains_any</a></li>
<li><a href="#contains_rune">contains_rune</a></li>
<li><a href="#contains_space">contains_space</a></li>
<li><a href="#count">count</a></li>
<li><a href="#cut">cut</a></li>
<li><a href="#cut_clone">cut_clone</a></li>
<li><a href="#ends_with">ends_with</a></li>
<li><a href="#equal_fold">equal_fold</a></li>
<li><a href="#expand_tabs">expand_tabs</a></li>
<li><a href="#fields">fields</a></li>
<li><a href="#fields_iterator">fields_iterator</a></li>
<li><a href="#fields_proc">fields_proc</a></li>
<li><a href="#has_prefix">has_prefix</a></li>
<li><a href="#has_suffix">has_suffix</a></li>
<li><a href="#index">index</a></li>
<li><a href="#index_any">index_any</a></li>
<li><a href="#index_byte">index_byte</a></li>
<li><a href="#index_multi">index_multi</a></li>
<li><a href="#index_proc">index_proc</a></li>
<li><a href="#index_proc_with_state">index_proc_with_state</a></li>
<li><a href="#index_rune">index_rune</a></li>
<li><a href="#intern_destroy">intern_destroy</a></li>
<li><a href="#intern_get">intern_get</a></li>
<li><a href="#intern_get_cstring">intern_get_cstring</a></li>
<li><a href="#intern_init">intern_init</a></li>
<li><a href="#is_ascii_space">is_ascii_space</a></li>
<li><a href="#is_delimiter">is_delimiter</a></li>
<li><a href="#is_in_cutset">is_in_cutset</a></li>
<li><a href="#is_null">is_null</a></li>
<li><a href="#is_separator">is_separator</a></li>
<li><a href="#is_space">is_space</a></li>
<li><a href="#join">join</a></li>
<li><a href="#last_index">last_index</a></li>
<li><a href="#last_index_any">last_index_any</a></li>
<li><a href="#last_index_byte">last_index_byte</a></li>
<li><a href="#last_index_proc">last_index_proc</a></li>
<li><a href="#last_index_proc_with_state">last_index_proc_with_state</a></li>
<li><a href="#left_justify">left_justify</a></li>
<li><a href="#levenshtein_distance">levenshtein_distance</a></li>
<li><a href="#partition">partition</a></li>
<li><a href="#pop_byte">pop_byte</a></li>
<li><a href="#pop_rune">pop_rune</a></li>
<li><a href="#prefix_length">prefix_length</a></li>
<li><a href="#reader_init">reader_init</a></li>
<li><a href="#reader_length">reader_length</a></li>
<li><a href="#reader_read">reader_read</a></li>
<li><a href="#reader_read_at">reader_read_at</a></li>
<li><a href="#reader_read_byte">reader_read_byte</a></li>
<li><a href="#reader_read_rune">reader_read_rune</a></li>
<li><a href="#reader_seek">reader_seek</a></li>
<li><a href="#reader_size">reader_size</a></li>
<li><a href="#reader_to_stream">reader_to_stream</a></li>
<li><a href="#reader_unread_byte">reader_unread_byte</a></li>
<li><a href="#reader_unread_rune">reader_unread_rune</a></li>
<li><a href="#reader_write_to">reader_write_to</a></li>
<li><a href="#remove">remove</a></li>
<li><a href="#remove_all">remove_all</a></li>
<li><a href="#repeat">repeat</a></li>
<li><a href="#replace">replace</a></li>
<li><a href="#replace_all">replace_all</a></li>
<li><a href="#reverse">reverse</a></li>
<li><a href="#right_justify">right_justify</a></li>
<li><a href="#rune_count">rune_count</a></li>
<li><a href="#scrub">scrub</a></li>
<li><a href="#split">split</a></li>
<li><a href="#split_after">split_after</a></li>
<li><a href="#split_after_iterator">split_after_iterator</a></li>
<li><a href="#split_after_n">split_after_n</a></li>
<li><a href="#split_by_byte_iterator">split_by_byte_iterator</a></li>
<li><a href="#split_iterator">split_iterator</a></li>
<li><a href="#split_lines">split_lines</a></li>
<li><a href="#split_lines_after">split_lines_after</a></li>
<li><a href="#split_lines_after_iterator">split_lines_after_iterator</a></li>
<li><a href="#split_lines_after_n">split_lines_after_n</a></li>
<li><a href="#split_lines_iterator">split_lines_iterator</a></li>
<li><a href="#split_lines_n">split_lines_n</a></li>
<li><a href="#split_multi">split_multi</a></li>
<li><a href="#split_multi_iterate">split_multi_iterate</a></li>
<li><a href="#split_n">split_n</a></li>
<li><a href="#starts_with">starts_with</a></li>
<li><a href="#string_case_iterator">string_case_iterator</a></li>
<li><a href="#string_from_null_terminated_ptr">string_from_null_terminated_ptr</a></li>
<li><a href="#string_from_ptr">string_from_ptr</a></li>
<li><a href="#substring">substring</a></li>
<li><a href="#substring_from">substring_from</a></li>
<li><a href="#substring_to">substring_to</a></li>
<li><a href="#to_ada_case">to_ada_case</a></li>
<li><a href="#to_camel_case">to_camel_case</a></li>
<li><a href="#to_cstring">to_cstring</a></li>
<li><a href="#to_delimiter_case">to_delimiter_case</a></li>
<li><a href="#to_kebab_case">to_kebab_case</a></li>
<li><a href="#to_lower">to_lower</a></li>
<li><a href="#to_lower_camel_case">to_lower_camel_case</a></li>
<li><a href="#to_pascal_case">to_pascal_case</a></li>
<li><a href="#to_reader">to_reader</a></li>
<li><a href="#to_reader_at">to_reader_at</a></li>
<li><a href="#to_screaming_snake_case">to_screaming_snake_case</a></li>
<li><a href="#to_snake_case">to_snake_case</a></li>
<li><a href="#to_stream">to_stream</a></li>
<li><a href="#to_string">to_string</a></li>
<li><a href="#to_upper">to_upper</a></li>
<li><a href="#to_upper_camel_case">to_upper_camel_case</a></li>
<li><a href="#to_upper_kebab_case">to_upper_kebab_case</a></li>
<li><a href="#to_upper_snake_case">to_upper_snake_case</a></li>
<li><a href="#to_valid_utf8">to_valid_utf8</a></li>
<li><a href="#to_writer">to_writer</a></li>
<li><a href="#trim">trim</a></li>
<li><a href="#trim_left">trim_left</a></li>
<li><a href="#trim_left_null">trim_left_null</a></li>
<li><a href="#trim_left_proc">trim_left_proc</a></li>
<li><a href="#trim_left_proc_with_state">trim_left_proc_with_state</a></li>
<li><a href="#trim_left_space">trim_left_space</a></li>
<li><a href="#trim_null">trim_null</a></li>
<li><a href="#trim_prefix">trim_prefix</a></li>
<li><a href="#trim_right">trim_right</a></li>
<li><a href="#trim_right_null">trim_right_null</a></li>
<li><a href="#trim_right_proc">trim_right_proc</a></li>
<li><a href="#trim_right_proc_with_state">trim_right_proc_with_state</a></li>
<li><a href="#trim_right_space">trim_right_space</a></li>
<li><a href="#trim_space">trim_space</a></li>
<li><a href="#trim_suffix">trim_suffix</a></li>
<li><a href="#truncate_to_byte">truncate_to_byte</a></li>
<li><a href="#truncate_to_rune">truncate_to_rune</a></li>
<li><a href="#unsafe_string_to_cstring">unsafe_string_to_cstring</a></li>
<li><a href="#unsafe_to_cstring">unsafe_to_cstring</a></li>
<li><a href="#write_byte">write_byte</a></li>
<li><a href="#write_bytes">write_bytes</a></li>
<li><a href="#write_encoded_rune">write_encoded_rune</a></li>
<li><a href="#write_escaped_rune">write_escaped_rune</a></li>
<li><a href="#write_f16">write_f16</a></li>
<li><a href="#write_f32">write_f32</a></li>
<li><a href="#write_f64">write_f64</a></li>
<li><a href="#write_float">write_float</a></li>
<li><a href="#write_i64">write_i64</a></li>
<li><a href="#write_int">write_int</a></li>
<li><a href="#write_quoted_rune">write_quoted_rune</a></li>
<li><a href="#write_quoted_string">write_quoted_string</a></li>
<li><a href="#write_rune">write_rune</a></li>
<li><a href="#write_string">write_string</a></li>
<li><a href="#write_u64">write_u64</a></li>
<li><a href="#write_uint">write_uint</a></li>
</ul>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Procedure Groups" aria-labelledby="#doc-index-Procedure Groups-header">
<summary id="#doc-index-Procedure Groups-header">
Procedure Groups (3)</summary>
<ul>
<li><a href="#builder_init">builder_init</a></li>
<li><a href="#builder_make">builder_make</a></li>
<li><a href="#clone_from">clone_from</a></li>
</ul>
</details>
</div>
</div>
</div>
<section class="documentation">
<h2 id="pkg-Types" class="pkg-header">Types</h2>
<div class="pkg-entity">
<h3 id="Ascii_Set"><span><a class="doc-id-link" href="#Ascii_Set">Ascii_Set<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/ascii_set.odin#L10"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Ascii_Set :: <span class="keyword-type">distinct</span> [8]<a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Ascii_Set is designed to store ASCII characters efficiently as a bit-array
Each bit in the array corresponds to a specific ASCII character, where the value of the bit (0 or 1) 
indicates if the character is present in the set or not.</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/strings/#ascii_set_contains">ascii_set_contains</a></li>
</ul>
<h5>Related Procedures With Returns</h5>
<ul>
<li><a href="/core/strings/#ascii_set_make">ascii_set_make</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Builder"><span><a class="doc-id-link" href="#Builder">Builder<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L23"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Builder :: <span class="keyword-type">struct</span> {
	buf: [<span class="keyword">dynamic</span>]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>A dynamic byte buffer / string builder with helper procedures
The dynamic array is wrapped inside the struct to be more opaque
You can use <code>fmt.sbprint*</code> procedures with a <code>^strings.Builder</code> directly</p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/strings/#builder_cap">builder_cap</a></li>
<li><a href="/core/strings/#builder_destroy">builder_destroy</a></li>
<li><a href="/core/strings/#builder_grow">builder_grow</a></li>
<li><a href="/core/strings/#builder_init_len">builder_init_len</a></li>
<li><a href="/core/strings/#builder_init_len_cap">builder_init_len_cap</a></li>
<li><a href="/core/strings/#builder_init_none">builder_init_none</a></li>
<li><a href="/core/strings/#builder_len">builder_len</a></li>
<li><a href="/core/strings/#builder_reset">builder_reset</a></li>
<li><a href="/core/strings/#builder_space">builder_space</a></li>
<li><a href="/core/strings/#pop_byte">pop_byte</a></li>
<li><a href="/core/strings/#pop_rune">pop_rune</a></li>
<li><a href="/core/strings/#to_cstring">to_cstring</a></li>
<li><a href="/core/strings/#to_stream">to_stream</a></li>
<li><a href="/core/strings/#to_string">to_string</a></li>
<li><a href="/core/strings/#to_writer">to_writer</a></li>
<li><a href="/core/strings/#unsafe_to_cstring">unsafe_to_cstring</a></li>
<li><a href="/core/strings/#write_byte">write_byte</a></li>
<li><a href="/core/strings/#write_bytes">write_bytes</a></li>
<li><a href="/core/strings/#write_encoded_rune">write_encoded_rune</a></li>
<li><a href="/core/strings/#write_escaped_rune">write_escaped_rune</a></li>
<li><a href="/core/strings/#write_f16">write_f16</a></li>
<li><a href="/core/strings/#write_f32">write_f32</a></li>
<li><a href="/core/strings/#write_f64">write_f64</a></li>
<li><a href="/core/strings/#write_float">write_float</a></li>
<li><a href="/core/strings/#write_i64">write_i64</a></li>
<li><a href="/core/strings/#write_int">write_int</a></li>
<li><a href="/core/strings/#write_quoted_rune">write_quoted_rune</a></li>
<li><a href="/core/strings/#write_quoted_string">write_quoted_string</a></li>
<li><a href="/core/strings/#write_rune">write_rune</a></li>
<li><a href="/core/strings/#write_string">write_string</a></li>
<li><a href="/core/strings/#write_u64">write_u64</a></li>
<li><a href="/core/strings/#write_uint">write_uint</a></li>
<li><a href="/core/strings/#builder_init">builder_init</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
<h5>Related Procedures With Returns</h5>
<ul>
<li><a href="/core/strings/#builder_from_bytes">builder_from_bytes</a></li>
<li><a href="/core/strings/#builder_make_len">builder_make_len</a></li>
<li><a href="/core/strings/#builder_make_len_cap">builder_make_len_cap</a></li>
<li><a href="/core/strings/#builder_make_none">builder_make_none</a></li>
<li><a href="/core/strings/#builder_make">builder_make</a>&nbsp;<em>(procedure groups)</em></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Builder_Flush_Proc"><span><a class="doc-id-link" href="#Builder_Flush_Proc">Builder_Flush_Proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L17"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Builder_Flush_Proc :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>) -> (do_reset: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>)</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Type definition for a procedure that flushes a Builder</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span></p>
<p><b>Returns:</b><br>A boolean indicating whether the Builder should be reset</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Intern"><span><a class="doc-id-link" href="#Intern">Intern<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/intern.odin#L20"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Intern :: <span class="keyword-type">struct</span> {
	allocator: runtime.<a class="code-typename" href="/base/runtime/#Allocator">Allocator</a>,
	entries:   <span class="keyword-type">map</span>[<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>]^<a class="code-typename" href="/core/strings/#Intern_Entry">Intern_Entry</a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Intern is a more memory efficient string map</p>
<p>Uses Specified Allocator for <code>Intern_Entry</code> strings</p>
<p>Fields:
<span class="doc-list">allocator: The allocator used for the Intern_Entry strings</span>
<span class="doc-list">entries: A map of strings to interned string entries</span></p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/strings/#intern_destroy">intern_destroy</a></li>
<li><a href="/core/strings/#intern_get">intern_get</a></li>
<li><a href="/core/strings/#intern_get_cstring">intern_get_cstring</a></li>
<li><a href="/core/strings/#intern_init">intern_init</a></li>
</ul>
</div>
<div class="pkg-entity">
<h3 id="Intern_Entry"><span><a class="doc-id-link" href="#Intern_Entry">Intern_Entry<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/intern.odin#L7"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Intern_Entry :: <span class="keyword-type">struct</span> {
	len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
	str: [1]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Custom string entry struct</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="Reader"><span><a class="doc-id-link" href="#Reader">Reader<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/reader.odin#L11"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">Reader :: <span class="keyword-type">struct</span> {
	s:         <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>,
	<span class="comment">// read-only buffer</span>
	i:         <a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a>,
	<span class="comment">// current reading index</span>
	prev_rune: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>io stream data for a string reader that can read based on bytes or runes
implements the vtable when using the <code>io.Reader</code> variants
"read" calls advance the current reading offset <code>i</code></p>
</details>
<h5>Related Procedures With Parameters</h5>
<ul>
<li><a href="/core/strings/#reader_init">reader_init</a></li>
<li><a href="/core/strings/#reader_length">reader_length</a></li>
<li><a href="/core/strings/#reader_read">reader_read</a></li>
<li><a href="/core/strings/#reader_read_at">reader_read_at</a></li>
<li><a href="/core/strings/#reader_read_byte">reader_read_byte</a></li>
<li><a href="/core/strings/#reader_read_rune">reader_read_rune</a></li>
<li><a href="/core/strings/#reader_seek">reader_seek</a></li>
<li><a href="/core/strings/#reader_size">reader_size</a></li>
<li><a href="/core/strings/#reader_to_stream">reader_to_stream</a></li>
<li><a href="/core/strings/#reader_unread_byte">reader_unread_byte</a></li>
<li><a href="/core/strings/#reader_unread_rune">reader_unread_rune</a></li>
<li><a href="/core/strings/#reader_write_to">reader_write_to</a></li>
<li><a href="/core/strings/#to_reader">to_reader</a></li>
<li><a href="/core/strings/#to_reader_at">to_reader_at</a></li>
</ul>
</div>
<h2 id="pkg-Constants" class="pkg-header">Constants</h2>
<p class="pkg-empty-section">This section is empty.</p>
<h2 id="pkg-Variables" class="pkg-header">Variables</h2>
<p class="pkg-empty-section">This section is empty.</p>
<h2 id="pkg-Procedures" class="pkg-header">Procedures</h2>
<div class="pkg-entity">
<h3 id="ascii_set_contains"><span><a class="doc-id-link" href="#ascii_set_contains">ascii_set_contains<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/ascii_set.odin#L42"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">ascii_set_contains :: <span class="keyword-type">proc</span>(as: <a class="code-typename" href="/core/strings/#Ascii_Set">Ascii_Set</a>, c: <a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>) -> (res: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Determines if a given char is contained within an Ascii_Set.</p>
<p><b>Inputs:</b><br><span class="doc-list">as: The Ascii_Set to search.</span>
<span class="doc-list">c: The char to check for in the Ascii_Set.</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: A boolean indicating if the byte is contained in the Ascii_Set (true) or not (false).</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="ascii_set_make"><span><a class="doc-id-link" href="#ascii_set_make">ascii_set_make<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/ascii_set.odin#L21"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">ascii_set_make :: <span class="keyword-type">proc</span>(chars: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (as: <a class="code-typename" href="/core/strings/#Ascii_Set">Ascii_Set</a>, ok: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Creates an Ascii_Set with unique characters from the input string.</p>
<p><b>Inputs:</b><br><span class="doc-list">chars: A string containing characters to include in the Ascii_Set.</span></p>
<p><b>Returns:</b><br><span class="doc-list">as: An Ascii_Set with unique characters from the input string.</span>
<span class="doc-list">ok: false if any character in the input string is not a valid ASCII character.</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="builder_cap"><span><a class="doc-id-link" href="#builder_cap">builder_cap<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L346"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">builder_cap :: <span class="keyword-type">proc</span>(b: <a class="code-typename" href="/core/strings/#Builder">Builder</a>) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the capacity of the Builder's buffer, in bytes</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A Builder</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The capacity of the Builder's buffer</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="builder_destroy"><span><a class="doc-id-link" href="#builder_destroy">builder_destroy<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L218"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">builder_destroy :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Deletes the Builder byte buffer content</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="builder_from_bytes"><span><a class="doc-id-link" href="#builder_from_bytes">builder_from_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L271"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">builder_from_bytes :: <span class="keyword-type">proc</span>(backing: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>) -> (res: <a class="code-typename" href="/core/strings/#Builder">Builder</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Creates a Builder from a slice of bytes with the same slice length as its capacity. Used in fmt.bprint*</p>
<p><i>Uses Nil Allocator - Does NOT allocate</i></p>
<p><b>Inputs:</b><br><span class="doc-list">backing: A slice of bytes to be used as the backing buffer</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The new Builder</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"
builder_from_bytes_example :: proc() {
	bytes: [8]byte // &lt;-- gets filled
	builder := strings.builder_from_bytes(bytes[:])
	strings.write_byte(&builder, 'a')
	fmt.println(strings.to_string(builder)) // -&gt; "a"
	strings.write_byte(&builder, 'b')
	fmt.println(strings.to_string(builder)) // -&gt; "ab"
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">a
ab
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="builder_from_slice"><span><a class="doc-id-link" href="#builder_from_slice">builder_from_slice<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L271"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">builder_from_slice :: <a class="code-procedure" href="/core/strings/#builder_from_bytes">builder_from_bytes</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Creates a Builder from a slice of bytes with the same slice length as its capacity. Used in fmt.bprint*</p>
<p><i>Uses Nil Allocator - Does NOT allocate</i></p>
<p><b>Inputs:</b><br><span class="doc-list">backing: A slice of bytes to be used as the backing buffer</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The new Builder</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"
builder_from_bytes_example :: proc() {
	bytes: [8]byte // &lt;-- gets filled
	builder := strings.builder_from_bytes(bytes[:])
	strings.write_byte(&builder, 'a')
	fmt.println(strings.to_string(builder)) // -&gt; "a"
	strings.write_byte(&builder, 'b')
	fmt.println(strings.to_string(builder)) // -&gt; "ab"
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">a
ab
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="builder_grow"><span><a class="doc-id-link" href="#builder_grow">builder_grow<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L229"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">builder_grow :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, cap: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reserves the Builder byte buffer to a specific capacity, when it's higher than before</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">cap: The desired capacity for the Builder's buffer</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="builder_init_len"><span><a class="doc-id-link" href="#builder_init_len">builder_init_len<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L138"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">builder_init_len :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initializes a Builder with specified length and capacity <code>len</code>.
It replaces the existing <code>buf</code></p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">len: The desired length of the Builder's buffer</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: A pointer to the initialized Builder</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="builder_init_len_cap"><span><a class="doc-id-link" href="#builder_init_len_cap">builder_init_len_cap<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L156"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">builder_init_len_cap :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, len, cap: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initializes a Builder with specified length <code>len</code> and capacity <code>cap</code>.
It replaces the existing <code>buf</code></p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">len: The desired length of the Builder's buffer</span>
<span class="doc-list">cap: The desired capacity of the Builder's buffer, actual max(len,cap)</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: A pointer to the initialized Builder</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="builder_init_none"><span><a class="doc-id-link" href="#builder_init_none">builder_init_none<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L119"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">builder_init_none :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initializes an empty Builder
It replaces the existing <code>buf</code></p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: A pointer to the initialized Builder</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="builder_len"><span><a class="doc-id-link" href="#builder_len">builder_len<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L334"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">builder_len :: <span class="keyword-type">proc</span>(b: <a class="code-typename" href="/core/strings/#Builder">Builder</a>) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the length of the Builder's buffer, in bytes</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A Builder</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The length of the Builder's buffer</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="builder_make_len"><span><a class="doc-id-link" href="#builder_make_len">builder_make_len<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L54"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">builder_make_len :: <span class="keyword-type">proc</span>(len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: <a class="code-typename" href="/core/strings/#Builder">Builder</a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Produces a Builder with specified length and capacity <code>len</code>.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">len: The desired length of the Builder's buffer</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The new Builder</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="builder_make_len_cap"><span><a class="doc-id-link" href="#builder_make_len_cap">builder_make_len_cap<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L71"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">builder_make_len_cap :: <span class="keyword-type">proc</span>(len, cap: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: <a class="code-typename" href="/core/strings/#Builder">Builder</a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Produces a Builder with specified length <code>len</code> and capacity <code>cap</code>.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">len: The desired length of the Builder's buffer</span>
<span class="doc-list">cap: The desired capacity of the Builder's buffer, cap is max(cap, len)</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The new Builder</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="builder_make_none"><span><a class="doc-id-link" href="#builder_make_none">builder_make_none<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L38"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">builder_make_none :: <span class="keyword-type">proc</span>(allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: <a class="code-typename" href="/core/strings/#Builder">Builder</a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Produces an empty Builder</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The new Builder</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="builder_reset"><span><a class="doc-id-link" href="#builder_reset">builder_reset<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L238"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">builder_reset :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Clears the Builder byte buffer content (sets len to zero)</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="builder_space"><span><a class="doc-id-link" href="#builder_space">builder_space<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L358"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">builder_space :: <span class="keyword-type">proc</span>(b: <a class="code-typename" href="/core/strings/#Builder">Builder</a>) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>The free space left in the Builder's buffer, in bytes</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A Builder</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The available space left in the Builder's buffer</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="center_justify"><span><a class="doc-id-link" href="#center_justify">center_justify<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L3042"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">center_justify :: <a class="code-procedure" href="/core/strings/#centre_justify">centre_justify</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Centers the input string within a field of specified length by adding pad string on both sides, if its length is less than the target length.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">str: The input string</span>
<span class="doc-list">length: The desired length of the centered string, in runes</span>
<span class="doc-list">pad: The string used for padding on both sides</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: A new string centered within a field of the specified length</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="centre_justify"><span><a class="doc-id-link" href="#centre_justify">centre_justify<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L3042"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">centre_justify :: <span class="keyword-type">proc</span>(str: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, length: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, pad: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Centers the input string within a field of specified length by adding pad string on both sides, if its length is less than the target length.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">str: The input string</span>
<span class="doc-list">length: The desired length of the centered string, in runes</span>
<span class="doc-list">pad: The string used for padding on both sides</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: A new string centered within a field of the specified length</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="clone"><span><a class="doc-id-link" href="#clone">clone<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L26"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">clone :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Clones a string</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The string to be cloned</span>
<span class="doc-list">allocator: (default: context.allocator)</span>
<span class="doc-list">loc: The caller location for debugging purposes (default: #caller_location)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The cloned string</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="clone_from_bytes"><span><a class="doc-id-link" href="#clone_from_bytes">clone_from_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L156"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">clone_from_bytes :: <span class="keyword-type">proc</span>(s: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Clones a byte array <code>s</code> and appends a null-byte</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The byte array to be cloned</span>
<span class="doc-list">allocator: (default: context.allocator)</span>
<span class="doc-list">loc: The caller location for debugging purposes (default: <code>#caller_location</code>)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The cloned string from the byte array with a null-byte</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="clone_from_cstring"><span><a class="doc-id-link" href="#clone_from_cstring">clone_from_cstring<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L177"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">clone_from_cstring :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#cstring"><span class="doc-builtin">cstring</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Clones a cstring <code>s</code> as a string</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The cstring to be cloned</span>
<span class="doc-list">allocator: (default: context.allocator)</span>
<span class="doc-list">loc: The caller location for debugging purposes (default: <code>#caller_location</code>)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The cloned string from the cstring</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="clone_from_cstring_bounded"><span><a class="doc-id-link" href="#clone_from_cstring_bounded">clone_from_cstring_bounded<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L228"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">clone_from_cstring_bounded :: <span class="keyword-type">proc</span>(ptr: <a href="/base/builtin#cstring"><span class="doc-builtin">cstring</span></a>, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Clones a string from a null-terminated cstring <code>ptr</code> and a byte length <code>len</code></p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">ptr: A pointer to the start of the null-terminated cstring</span>
<span class="doc-list">len: The byte length of the cstring</span>
<span class="doc-list">allocator: (default: context.allocator)</span>
<span class="doc-list">loc: The caller location for debugging purposes (default: <code>#caller_location</code>)</span></p>
<p>NOTE: Truncates at the first null-byte encountered or the byte length.</p>
<p><b>Returns:</b><br><span class="doc-list">res: The cloned string from the null-terminated cstring and byte length</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="clone_from_ptr"><span><a class="doc-id-link" href="#clone_from_ptr">clone_from_ptr<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L198"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">clone_from_ptr :: <span class="keyword-type">proc</span>(ptr: ^<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Clones a string from a byte pointer <code>ptr</code> and a byte length <code>len</code></p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">ptr: A pointer to the start of the byte sequence</span>
<span class="doc-list">len: The length of the byte sequence</span>
<span class="doc-list">allocator: (default: context.allocator)</span>
<span class="doc-list">loc: The caller location for debugging purposes (default: <code>#caller_location</code>)</span></p>
<p>NOTE: Same as <code>string_from_ptr</code>, but perform an additional <code>clone</code> operation</p>
<p><b>Returns:</b><br><span class="doc-list">res: The cloned string from the byte pointer and length</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="clone_to_cstring"><span><a class="doc-id-link" href="#clone_to_cstring">clone_to_cstring<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L46"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">clone_to_cstring :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: <a href="/base/builtin#cstring"><span class="doc-builtin">cstring</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Clones a string and appends a null-byte to make it a cstring</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The string to be cloned</span>
<span class="doc-list">allocator: (default: context.allocator)</span>
<span class="doc-list">loc: The caller location for debugging purposes (default: #caller_location)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: A cloned cstring with an appended null-byte</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="common_prefix"><span><a class="doc-id-link" href="#common_prefix">common_prefix<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L525"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">common_prefix :: <span class="keyword-type">proc</span>(a, b: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> <a href="/base/builtin#string"><span class="doc-builtin">string</span></a> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the common prefix between strings <code>a</code> and <code>b</code></p>
<p><b>Inputs:</b><br><span class="doc-list">a: The first input string</span>
<span class="doc-list">b: The second input string</span></p>
<p><b>Returns:</b><br><span class="doc-list">n: The string prefix common between strings <code>a</code> and <code>b</code></span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

common_prefix_example :: proc() {
	fmt.println(strings.common_prefix("testing", "test"))
	fmt.println(strings.common_prefix("testing", "te"))
	fmt.println(strings.common_prefix("telephone", "te"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">test
te
te
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="compare"><span><a class="doc-id-link" href="#compare">compare<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L245"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">compare :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (lhs, rhs: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (result: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Compares two strings, returning a value representing which one comes first lexicographically.
-1 for <code>lhs</code>; 1 for <code>rhs</code>, or 0 if they are equal.</p>
<p><b>Inputs:</b><br><span class="doc-list">lhs: First string for comparison</span>
<span class="doc-list">rhs: Second string for comparison</span></p>
<p><b>Returns:</b><br><span class="doc-list">result: <code>-1</code> if <code>lhs</code> comes first, <code>1</code> if <code>rhs</code> comes first, or <code>0</code> if they are equal</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="concatenate"><span><a class="doc-id-link" href="#concatenate">concatenate<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L679"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">concatenate :: <span class="keyword-type">proc</span>(a: []<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns a combined string from the slice of strings <code>a</code> without a separator</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">a: A slice of strings to concatenate</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The concatenated string</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

concatenate_example :: proc() {
	a := [?]string { "a", "b", "c" }
	fmt.println(strings.concatenate(a[:]))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">abc
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="contains"><span><a class="doc-id-link" href="#contains">contains<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L296"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">contains :: <span class="keyword-type">proc</span>(s, substr: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true when the string <code>substr</code> is contained inside the string <code>s</code></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">substr: The substring to search for</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: <code>true</code> if <code>substr</code> is contained inside the string <code>s</code>, <code>false</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

contains_example :: proc() {
	fmt.println(strings.contains("testing", "test"))
	fmt.println(strings.contains("testing", "ing"))
	fmt.println(strings.contains("testing", "text"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">true
true
false
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="contains_any"><span><a class="doc-id-link" href="#contains_any">contains_any<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L330"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">contains_any :: <span class="keyword-type">proc</span>(s, chars: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns <code>true</code> when the string <code>s</code> contains any of the characters inside the string <code>chars</code></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">chars: The characters to search for</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: <code>true</code> if the string <code>s</code> contains any of the characters in <code>chars</code>, <code>false</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

contains_any_example :: proc() {
	fmt.println(strings.contains_any("test", "test"))
	fmt.println(strings.contains_any("test", "ts"))
	fmt.println(strings.contains_any("test", "et"))
	fmt.println(strings.contains_any("test", "a"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">true
true
true
false
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="contains_rune"><span><a class="doc-id-link" href="#contains_rune">contains_rune<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L259"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">contains_rune :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, r: untyped rune) -> (result: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Checks if rune <code>r</code> in the string <code>s</code></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">r: The rune to search for</span></p>
<p><b>Returns:</b><br><span class="doc-list">result: <code>true</code> if the rune <code>r</code> in the string <code>s</code>, <code>false</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="contains_space"><span><a class="doc-id-link" href="#contains_space">contains_space<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L335"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">contains_space :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="count"><span><a class="doc-id-link" href="#count">count<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1930"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">count :: <span class="keyword-type">proc</span>(s, substr: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Counts the number of non-overlapping occurrences of <code>substr</code> in <code>s</code></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The string to search in</span>
<span class="doc-list">substr: The substring to count</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The number of occurrences of <code>substr</code> in <code>s</code>, returns the rune_count + 1 of the string <code>s</code> on empty <code>substr</code></span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

count_example :: proc() {
	fmt.println(strings.count("abbccc", "a"))
	fmt.println(strings.count("abbccc", "b"))
	fmt.println(strings.count("abbccc", "c"))
	fmt.println(strings.count("abbccc", "ab"))
	fmt.println(strings.count("abbccc", " "))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">1
2
3
1
0
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="cut"><span><a class="doc-id-link" href="#cut">cut<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L725"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">cut :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, rune_offset: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = int(0), rune_length: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = int(0)) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns a substring of the input string <code>s</code> with the specified rune offset and length</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to cut</span>
<span class="doc-list">rune_offset: The starting rune index (default is 0). In runes, not bytes.</span>
<span class="doc-list">rune_length: The number of runes to include in the substring (default is 0, which returns the remainder of the string).  In runes, not bytes.</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The substring</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

cut_example :: proc() {
	fmt.println(strings.cut("some example text", 0, 4)) // -&gt; "some"
	fmt.println(strings.cut("some example text", 2, 2)) // -&gt; "me"
	fmt.println(strings.cut("some example text", 5, 7)) // -&gt; "example"
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">some
me
example
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="cut_clone"><span><a class="doc-id-link" href="#cut_clone">cut_clone<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L785"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">cut_clone :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, rune_offset: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = int(0), rune_length: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = int(0), allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns a substring of the input string <code>s</code> with the specified rune offset and length</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to cut</span>
<span class="doc-list">rune_offset: The starting rune index (default is 0). In runes, not bytes.</span>
<span class="doc-list">rune_length: The number of runes to include in the substring (default is 0, which returns the remainder of the string).  In runes, not bytes.</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The substring</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

cut_clone_example :: proc() {
	fmt.println(strings.cut_clone("some example text", 0, 4)) // -&gt; "some"
	fmt.println(strings.cut_clone("some example text", 2, 2)) // -&gt; "me"
	fmt.println(strings.cut_clone("some example text", 5, 7)) // -&gt; "example"
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">some
me
example
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="ends_with"><span><a class="doc-id-link" href="#ends_with">ends_with<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L593"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">ends_with :: <a class="code-procedure" href="/core/strings/#has_suffix">has_suffix</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Determines if a string <code>s</code> ends with a given <code>suffix</code></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The string to check for the <code>suffix</code></span>
<span class="doc-list">suffix: The suffix to look for</span></p>
<p><b>Returns:</b><br><span class="doc-list">result: <code>true</code> if the string <code>s</code> ends with the <code>suffix</code>, otherwise <code>false</code></span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

has_suffix_example :: proc() {
	fmt.println(strings.has_suffix("todo.txt", ".txt"))
	fmt.println(strings.has_suffix("todo.doc", ".txt"))
	fmt.println(strings.has_suffix("todo.doc.txt", ".txt"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">true
false
true
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="equal_fold"><span><a class="doc-id-link" href="#equal_fold">equal_fold<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L404"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">equal_fold :: <span class="keyword-type">proc</span>(u, v: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns whether the strings <code>u</code> and <code>v</code> are the same alpha characters, ignoring different casings
Works with UTF-8 string content</p>
<p><b>Inputs:</b><br><span class="doc-list">u: The first string for comparison</span>
<span class="doc-list">v: The second string for comparison</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: <code>true</code> if the strings <code>u</code> and <code>v</code> are the same alpha characters (ignoring case)</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

equal_fold_example :: proc() {
	fmt.println(strings.equal_fold("test", "test"))
	fmt.println(strings.equal_fold("Test", "test"))
	fmt.println(strings.equal_fold("Test", "tEsT"))
	fmt.println(strings.equal_fold("test", "tes"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">true
true
true
false
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="expand_tabs"><span><a class="doc-id-link" href="#expand_tabs">expand_tabs<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2931"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">expand_tabs :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, tab_size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="fields"><span><a class="doc-id-link" href="#fields">fields<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L3173"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">fields :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: []<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits a string into a slice of substrings at each instance of one or more consecutive white space characters, as defined by <code>unicode.is_space</code></p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: A slice of substrings of the input string, or an empty slice if the input string only contains white space</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="fields_iterator"><span><a class="doc-id-link" href="#fields_iterator">fields_iterator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L3275"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">fields_iterator :: <span class="keyword-type">proc</span>(s: ^<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (field: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, ok: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Retrieves the first non-space substring from a mutable string reference and advances the reference. <code>s</code> is advanced from any space after the substring, or be an empty string if the substring was the remaining characters</p>
<p><b>Inputs:</b><br><span class="doc-list">s: A mutable string reference to be iterated</span></p>
<p><b>Returns:</b><br><span class="doc-list">field: The first non-space substring found</span>
<span class="doc-list">ok: A boolean indicating if a non-space substring was found</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="fields_proc"><span><a class="doc-id-link" href="#fields_proc">fields_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L3238"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">fields_proc :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, f: <span class="keyword-type">proc</span>(untyped rune) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: []<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits a string into a slice of substrings at each run of unicode code points <code>r</code> satisfying the predicate <code>f(r)</code></p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">f: A predicate function to determine the split points</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p>NOTE: fields_proc makes no guarantee about the order in which it calls <code>f(r)</code>, it assumes that <code>f</code> always returns the same value for a given <code>r</code></p>
<p><b>Returns:</b><br><span class="doc-list">res: A slice of substrings of the input string, or an empty slice if all code points in the input string satisfy the predicate or if the input string is empty</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="has_prefix"><span><a class="doc-id-link" href="#has_prefix">has_prefix<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L559"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">has_prefix :: <span class="keyword-type">proc</span>(s, prefix: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (result: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Determines if a string <code>s</code> starts with a given <code>prefix</code></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The string to check for the <code>prefix</code></span>
<span class="doc-list">prefix: The prefix to look for</span></p>
<p><b>Returns:</b><br><span class="doc-list">result: <code>true</code> if the string <code>s</code> starts with the <code>prefix</code>, otherwise <code>false</code></span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

has_prefix_example :: proc() {
	fmt.println(strings.has_prefix("testing", "test"))
	fmt.println(strings.has_prefix("testing", "te"))
	fmt.println(strings.has_prefix("telephone", "te"))
	fmt.println(strings.has_prefix("testing", "est"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">true
true
true
false
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="has_suffix"><span><a class="doc-id-link" href="#has_suffix">has_suffix<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L593"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">has_suffix :: <span class="keyword-type">proc</span>(s, suffix: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (result: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Determines if a string <code>s</code> ends with a given <code>suffix</code></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The string to check for the <code>suffix</code></span>
<span class="doc-list">suffix: The suffix to look for</span></p>
<p><b>Returns:</b><br><span class="doc-list">result: <code>true</code> if the string <code>s</code> ends with the <code>suffix</code>, otherwise <code>false</code></span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

has_suffix_example :: proc() {
	fmt.println(strings.has_suffix("todo.txt", ".txt"))
	fmt.println(strings.has_suffix("todo.doc", ".txt"))
	fmt.println(strings.has_suffix("todo.doc.txt", ".txt"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">true
false
true
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="index"><span><a class="doc-id-link" href="#index">index<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1582"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">index :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (s, substr: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the byte offset of the string <code>substr</code> in the string <code>s</code>, -1 when not found.</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to search in.</span>
<span class="doc-list">substr: The substring to search for.</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The byte offset of the first occurrence of <code>substr</code> in <code>s</code>, or -1 if not found.</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

index_example :: proc() {
	fmt.println(strings.index("test", "t"))
	fmt.println(strings.index("test", "te"))
	fmt.println(strings.index("test", "st"))
	fmt.println(strings.index("test", "tt"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">0
0
2
-1
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="index_any"><span><a class="doc-id-link" href="#index_any">index_any<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1742"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">index_any :: <span class="keyword-type">proc</span>(s, chars: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the index of any first char of <code>chars</code> found in <code>s</code>, -1 if not found.</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to search in.</span>
<span class="doc-list">chars: The characters to look for</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The index of the first character of <code>chars</code> found in <code>s</code>, or -1 if not found.</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

index_any_example :: proc() {
	fmt.println(strings.index_any("test", "s"))
	fmt.println(strings.index_any("test", "se"))
	fmt.println(strings.index_any("test", "et"))
	fmt.println(strings.index_any("test", "set"))
	fmt.println(strings.index_any("test", "x"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">2
1
0
0
-1
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="index_byte"><span><a class="doc-id-link" href="#index_byte">index_byte<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1451"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">index_byte :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, c: <a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the byte offset of the first byte <code>c</code> in the string s it finds, -1 when not found.
NOTE: Can't find UTF-8 based runes.</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to search in.</span>
<span class="doc-list">c: The byte to search for.</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The byte offset of the first occurrence of <code>c</code> in <code>s</code>, or -1 if not found.</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

index_byte_example :: proc() {
	fmt.println(strings.index_byte("test", 't'))
	fmt.println(strings.index_byte("test", 'e'))
	fmt.println(strings.index_byte("test", 'x'))
	fmt.println(strings.index_byte("teäst", 'ä'))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">0
1
-1
-1
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="index_multi"><span><a class="doc-id-link" href="#index_multi">index_multi<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1867"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">index_multi :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, substrs: []<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (idx: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, width: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Finds the first occurrence of any substring in <code>substrs</code> within <code>s</code></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The string to search in</span>
<span class="doc-list">substrs: The substrings to look for</span></p>
<p><b>Returns:</b><br><span class="doc-list">idx: the index of the first matching substring</span>
<span class="doc-list">width: the length of the found substring</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="index_proc"><span><a class="doc-id-link" href="#index_proc">index_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2298"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">index_proc :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, p: <span class="keyword-type">proc</span>(untyped rune) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>, truth: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> = true) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Find the index of the first rune <code>r</code> in string <code>s</code> for which procedure <code>p</code> returns the same as truth, or -1 if no such rune appears.</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">p: A procedure that takes a rune and returns a boolean</span>
<span class="doc-list">truth: The boolean value to be matched (default: <code>true</code>)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The index of the first matching rune, or -1 if no match was found</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

index_proc_example :: proc() {
	call :: proc(r: rune) -&gt; bool {
		return r == 'a'
	}
	fmt.println(strings.index_proc("abcabc", call))
	fmt.println(strings.index_proc("cbacba", call))
	fmt.println(strings.index_proc("cbacba", call, false))
	fmt.println(strings.index_proc("abcabc", call, false))
	fmt.println(strings.index_proc("xyz", call))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">0
2
0
1
-1
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="index_proc_with_state"><span><a class="doc-id-link" href="#index_proc_with_state">index_proc_with_state<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2308"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">index_proc_with_state :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, p: <span class="keyword-type">proc</span>(<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, untyped rune) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>, state: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, truth: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> = true) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Same as <code>index_proc</code>, but the procedure p takes a raw pointer for state</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="index_rune"><span><a class="doc-id-link" href="#index_rune">index_rune<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1530"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">index_rune :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, r: untyped rune) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the byte offset of the first rune <code>r</code> in the string <code>s</code> it finds, -1 when not found.
Invalid runes return -1</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to search in.</span>
<span class="doc-list">r: The rune to search for.</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The byte offset of the first occurrence of <code>r</code> in <code>s</code>, or -1 if not found.</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

index_rune_example :: proc() {
	fmt.println(strings.index_rune("abcädef", 'x'))
	fmt.println(strings.index_rune("abcädef", 'a'))
	fmt.println(strings.index_rune("abcädef", 'b'))
	fmt.println(strings.index_rune("abcädef", 'c'))
	fmt.println(strings.index_rune("abcädef", 'ä'))
	fmt.println(strings.index_rune("abcädef", 'd'))
	fmt.println(strings.index_rune("abcädef", 'e'))
	fmt.println(strings.index_rune("abcädef", 'f'))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">-1
0
1
2
3
5
6
7
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="intern_destroy"><span><a class="doc-id-link" href="#intern_destroy">intern_destroy<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/intern.odin#L48"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">intern_destroy :: <span class="keyword-type">proc</span>(m: ^<a class="code-typename" href="/core/strings/#Intern">Intern</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Frees the map and all its content allocated using the <code>.allocator</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list">m: A pointer to the Intern struct to be destroyed</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="intern_get"><span><a class="doc-id-link" href="#intern_get">intern_get<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/intern.odin#L69"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">intern_get :: <span class="keyword-type">proc</span>(m: ^<a class="code-typename" href="/core/strings/#Intern">Intern</a>, text: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (str: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns an interned copy of the given text, adding it to the map if not already present.</p>
<p><i>Allocate using the Intern's Allocator (First time string is seen only)</i></p>
<p><b>Inputs:</b><br><span class="doc-list">m: A pointer to the Intern struct</span>
<span class="doc-list">text: The string to be interned</span></p>
<p>NOTE: The returned string lives as long as the map entry lives.</p>
<p><b>Returns:</b><br><span class="doc-list">str: The interned string</span>
<span class="doc-list">err: An allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="intern_get_cstring"><span><a class="doc-id-link" href="#intern_get_cstring">intern_get_cstring<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/intern.odin#L88"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">intern_get_cstring :: <span class="keyword-type">proc</span>(m: ^<a class="code-typename" href="/core/strings/#Intern">Intern</a>, text: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (str: <a href="/base/builtin#cstring"><span class="doc-builtin">cstring</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns an interned copy of the given text as a cstring, adding it to the map if not already present.</p>
<p><i>Allocate using the Intern's Allocator  (First time string is seen only)</i></p>
<p><b>Inputs:</b><br><span class="doc-list">m: A pointer to the Intern struct</span>
<span class="doc-list">text: The string to be interned</span></p>
<p>NOTE: The returned cstring lives as long as the map entry lives</p>
<p><b>Returns:</b><br><span class="doc-list">str: The interned cstring</span>
<span class="doc-list">err: An allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="intern_init"><span><a class="doc-id-link" href="#intern_init">intern_init<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/intern.odin#L37"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">intern_init :: <span class="keyword-type">proc</span>(m: ^<a class="code-typename" href="/core/strings/#Intern">Intern</a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, map_allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initializes the entries map and sets the allocator for the string entries</p>
<p><i>Allocates Using Provided Allocators</i></p>
<p><b>Inputs:</b><br><span class="doc-list">m: A pointer to the Intern struct to be initialized</span>
<span class="doc-list">allocator: The allocator for the Intern_Entry strings (Default: context.allocator)</span>
<span class="doc-list">map_allocator: The allocator for the map of entries (Default: context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">err: An allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="is_ascii_space"><span><a class="doc-id-link" href="#is_ascii_space">is_ascii_space<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2215"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">is_ascii_space :: <span class="keyword-type">proc</span>(r: untyped rune) -> (res: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true when the <code>r</code> rune is an ASCII whitespace character.</p>
<p><b>Inputs:</b><br><span class="doc-list">r: the rune to test</span></p>
<p><b>Returns:</b><br>-res: <code>true</code> if <code>r</code> is a whitespace character, <code>false</code> if otherwise</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="is_delimiter"><span><a class="doc-id-link" href="#is_delimiter">is_delimiter<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L156"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">is_delimiter :: <span class="keyword-type">proc</span>(r: untyped rune) -> (res: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Checks if the rune <code>r</code> is a delimiter (' ', '-', or '_').</p>
<p><b>Inputs:</b><br><span class="doc-list">r: Rune to check for delimiter status.</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: True if <code>r</code> is a delimiter, false otherwise.</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="is_in_cutset"><span><a class="doc-id-link" href="#is_in_cutset">is_in_cutset<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2458"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">is_in_cutset :: <span class="keyword-type">proc</span>(state: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, r: untyped rune) -> (res: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Procedure for <code>trim_*_proc</code> variants, which has a string rawptr cast + rune comparison</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="is_null"><span><a class="doc-id-link" href="#is_null">is_null<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2258"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">is_null :: <span class="keyword-type">proc</span>(r: untyped rune) -> (res: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true when the <code>r</code> rune is <code>0x0</code></p>
<p><b>Inputs:</b><br><span class="doc-list">r: the rune to test</span></p>
<p><b>Returns:</b><br>-res: <code>true</code> if <code>r</code> is <code>0x0</code>, <code>false</code> if otherwise</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="is_separator"><span><a class="doc-id-link" href="#is_separator">is_separator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L168"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">is_separator :: <span class="keyword-type">proc</span>(r: untyped rune) -> (res: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Checks if the rune <code>r</code> is a non-alphanumeric or space character.</p>
<p><b>Inputs:</b><br><span class="doc-list">r: Rune to check for separator status.</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: True if <code>r</code> is a non-alpha or <code>unicode.is_space</code> rune.</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="is_space"><span><a class="doc-id-link" href="#is_space">is_space<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2231"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">is_space :: <span class="keyword-type">proc</span>(r: untyped rune) -> (res: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true when the <code>r</code> rune is an ASCII or UTF-8 whitespace character.</p>
<p><b>Inputs:</b><br><span class="doc-list">r: the rune to test</span></p>
<p><b>Returns:</b><br>-res: <code>true</code> if <code>r</code> is a whitespace character, <code>false</code> if otherwise</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="join"><span><a class="doc-id-link" href="#join">join<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L632"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">join :: <span class="keyword-type">proc</span>(a: []<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, sep: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Joins a slice of strings <code>a</code> with a <code>sep</code> string</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">a: A slice of strings to join</span>
<span class="doc-list">sep: The separator string</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: A combined string from the slice of strings <code>a</code> separated with the <code>sep</code> string</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

join_example :: proc() {
	a := [?]string { "a", "b", "c" }
	fmt.println(strings.join(a[:], " "))
	fmt.println(strings.join(a[:], "-"))
	fmt.println(strings.join(a[:], "..."))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">a b c
a-b-c
a...b...c
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="last_index"><span><a class="doc-id-link" href="#last_index">last_index<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1662"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">last_index :: <span class="keyword-type">proc</span>(s, substr: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the last byte offset of the string <code>substr</code> in the string <code>s</code>, -1 when not found.</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to search in.</span>
<span class="doc-list">substr: The substring to search for.</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The byte offset of the last occurrence of <code>substr</code> in <code>s</code>, or -1 if not found.</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

last_index_example :: proc() {
	fmt.println(strings.last_index("test", "t"))
	fmt.println(strings.last_index("test", "te"))
	fmt.println(strings.last_index("test", "st"))
	fmt.println(strings.last_index("test", "tt"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">3
0
2
-1
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="last_index_any"><span><a class="doc-id-link" href="#last_index_any">last_index_any<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1806"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">last_index_any :: <span class="keyword-type">proc</span>(s, chars: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Finds the last occurrence of any character in <code>chars</code> within <code>s</code>. Iterates in reverse.</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The string to search in</span>
<span class="doc-list">chars: The characters to look for</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The index of the last matching character, or -1 if not found</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

last_index_any_example :: proc() {
	fmt.println(strings.last_index_any("test", "s"))
	fmt.println(strings.last_index_any("test", "se"))
	fmt.println(strings.last_index_any("test", "et"))
	fmt.println(strings.last_index_any("test", "set"))
	fmt.println(strings.last_index_any("test", "x"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">2
2
3
3
-1
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="last_index_byte"><span><a class="doc-id-link" href="#last_index_byte">last_index_byte<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1487"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">last_index_byte :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, c: <a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the byte offset of the last byte <code>c</code> in the string <code>s</code>, -1 when not found.</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to search in.</span>
<span class="doc-list">c: The byte to search for.</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The byte offset of the last occurrence of <code>c</code> in <code>s</code>, or -1 if not found.</span></p>
<p>NOTE: Can't find UTF-8 based runes.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

last_index_byte_example :: proc() {
	fmt.println(strings.last_index_byte("test", 't'))
	fmt.println(strings.last_index_byte("test", 'e'))
	fmt.println(strings.last_index_byte("test", 'x'))
	fmt.println(strings.last_index_byte("teäst", 'ä'))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">3
1
-1
-1
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="last_index_proc"><span><a class="doc-id-link" href="#last_index_proc">last_index_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2318"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">last_index_proc :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, p: <span class="keyword-type">proc</span>(untyped rune) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>, truth: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> = true) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Finds the index of the <i>last</i> rune in the string s for which the procedure p returns the same value as truth</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="last_index_proc_with_state"><span><a class="doc-id-link" href="#last_index_proc_with_state">last_index_proc_with_state<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2331"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">last_index_proc_with_state :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, p: <span class="keyword-type">proc</span>(<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, untyped rune) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>, state: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, truth: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> = true) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Same as <code>index_proc_with_state</code>, runs through the string in reverse</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="left_justify"><span><a class="doc-id-link" href="#left_justify">left_justify<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L3078"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">left_justify :: <span class="keyword-type">proc</span>(str: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, length: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, pad: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Left-justifies the input string within a field of specified length by adding pad string on the right side, if its length is less than the target length.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">str: The input string</span>
<span class="doc-list">length: The desired length of the left-justified string</span>
<span class="doc-list">pad: The string used for padding on the right side</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: A new string left-justified within a field of the specified length</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="levenshtein_distance"><span><a class="doc-id-link" href="#levenshtein_distance">levenshtein_distance<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L3321"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">levenshtein_distance :: <span class="keyword-type">proc</span>(a, b: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Computes the Levenshtein edit distance between two strings</p>
<p><i>Allocates Using Provided Allocator (deletion occurs internal to proc)</i></p>
<p>NOTE: Does not perform internal allocation if length of string <code>b</code>, in runes, is smaller than 64</p>
<p><b>Inputs:</b><br><span class="doc-list">a, b: The two strings to compare</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The Levenshtein edit distance between the two strings</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<p>NOTE: This implementation is a single-row-version of the Wagner–Fischer algorithm, based on C code by Martin Ettl.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="partition"><span><a class="doc-id-link" href="#partition">partition<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L3011"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">partition :: <span class="keyword-type">proc</span>(str, sep: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (head, match, tail: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits the input string <code>str</code> by the separator <code>sep</code> string and returns 3 parts. The values are slices of the original string.</p>
<p><b>Inputs:</b><br><span class="doc-list">str: The input string</span>
<span class="doc-list">sep: The separator string</span></p>
<p><b>Returns:</b><br><span class="doc-list">head: the string before the split</span>
<span class="doc-list">match: the seperator string</span>
<span class="doc-list">tail: the string after the split</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

partition_example :: proc() {
	text := "testing this out"
	head, match, tail := strings.partition(text, " this ") // -&gt; head: "testing", match: " this ", tail: "out"
	fmt.println(head, match, tail)
	head, match, tail = strings.partition(text, "hi") // -&gt; head: "testing t", match: "hi", tail: "s out"
	fmt.println(head, match, tail)
	head, match, tail = strings.partition(text, "xyz")    // -&gt; head: "testing this out", match: "", tail: ""
	fmt.println(head)
	fmt.println(match == "")
	fmt.println(tail == "")
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">testing  this  out
testing t hi s out
testing this out
true
true
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="pop_byte"><span><a class="doc-id-link" href="#pop_byte">pop_byte<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L536"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">pop_byte :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>) -> (r: <a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Pops and returns the last byte in the Builder or 0 when the Builder is empty</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span></p>
<p><b>Returns:</b><br><span class="doc-list">r: The last byte in the Builder or 0 if empty</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="pop_rune"><span><a class="doc-id-link" href="#pop_rune">pop_rune<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L556"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">pop_rune :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>) -> (r: untyped rune, width: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Pops the last rune in the Builder and returns the popped rune and its rune width or (0, 0) if empty</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span></p>
<p><b>Returns:</b><br><span class="doc-list">r: The popped rune</span>
<span class="doc-list">width: The rune width or 0 if the builder was empty</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="prefix_length"><span><a class="doc-id-link" href="#prefix_length">prefix_length<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L477"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">prefix_length :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (a, b: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the prefix length common between strings <code>a</code> and <code>b</code></p>
<p><b>Inputs:</b><br><span class="doc-list">a: The first input string</span>
<span class="doc-list">b: The second input string</span></p>
<p><b>Returns:</b><br><span class="doc-list">n: The prefix length common between strings <code>a</code> and <code>b</code></span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

prefix_length_example :: proc() {
	fmt.println(strings.prefix_length("testing", "test"))
	fmt.println(strings.prefix_length("testing", "te"))
	fmt.println(strings.prefix_length("telephone", "te"))
	fmt.println(strings.prefix_length("testing", "est"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">4
2
2
0
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="reader_init"><span><a class="doc-id-link" href="#reader_init">reader_init<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/reader.odin#L23"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">reader_init :: <span class="keyword-type">proc</span>(r: ^<a class="code-typename" href="/core/strings/#Reader">Reader</a>, s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initializes a string Reader with the provided string</p>
<p><b>Inputs:</b><br><span class="doc-list">r: A pointer to a Reader struct</span>
<span class="doc-list">s: The input string to be read</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="reader_length"><span><a class="doc-id-link" href="#reader_length">reader_length<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/reader.odin#L81"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">reader_length :: <span class="keyword-type">proc</span>(r: ^<a class="code-typename" href="/core/strings/#Reader">Reader</a>) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the remaining length of the Reader</p>
<p><b>Inputs:</b><br><span class="doc-list">r: A pointer to a Reader struct</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The remaining length of the Reader</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="reader_read"><span><a class="doc-id-link" href="#reader_read">reader_read<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/reader.odin#L110"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">reader_read :: <span class="keyword-type">proc</span>(r: ^<a class="code-typename" href="/core/strings/#Reader">Reader</a>, p: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, err: io.<a class="code-typename" href="/core/io/#Error">Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reads len(p) bytes from the Reader's string and copies into the provided slice.</p>
<p><b>Inputs:</b><br><span class="doc-list">r: A pointer to a Reader struct</span>
<span class="doc-list">p: A byte slice to copy data into</span></p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of bytes read</span>
<span class="doc-list">err: An <code>io.Error</code> if an error occurs while reading, including <code>.EOF</code>, otherwise <code>nil</code> denotes success.</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="reader_read_at"><span><a class="doc-id-link" href="#reader_read_at">reader_read_at<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/reader.odin#L131"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">reader_read_at :: <span class="keyword-type">proc</span>(r: ^<a class="code-typename" href="/core/strings/#Reader">Reader</a>, p: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, off: <a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a>) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, err: io.<a class="code-typename" href="/core/io/#Error">Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reads len(p) bytes from the Reader's string and copies into the provided slice, at the specified offset from the current index.</p>
<p><b>Inputs:</b><br><span class="doc-list">r: A pointer to a Reader struct</span>
<span class="doc-list">p: A byte slice to copy data into</span>
<span class="doc-list">off: The offset from which to read</span></p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of bytes read</span>
<span class="doc-list">err: An <code>io.Error</code> if an error occurs while reading, including <code>.EOF</code>, otherwise <code>nil</code> denotes success.</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="reader_read_byte"><span><a class="doc-id-link" href="#reader_read_byte">reader_read_byte<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/reader.odin#L154"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">reader_read_byte :: <span class="keyword-type">proc</span>(r: ^<a class="code-typename" href="/core/strings/#Reader">Reader</a>) -> (res: <a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, err: io.<a class="code-typename" href="/core/io/#Error">Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reads and returns a single byte from the Reader's string</p>
<p><b>Inputs:</b><br><span class="doc-list">r: A pointer to a Reader struct</span></p>
<p><b>Returns:</b><br><span class="doc-list">The byte read from the Reader</span>
<span class="doc-list">err: An <code>io.Error</code> if an error occurs while reading, including <code>.EOF</code>, otherwise <code>nil</code> denotes success.</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="reader_read_rune"><span><a class="doc-id-link" href="#reader_read_rune">reader_read_rune<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/reader.odin#L191"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">reader_read_rune :: <span class="keyword-type">proc</span>(r: ^<a class="code-typename" href="/core/strings/#Reader">Reader</a>) -> (rr: untyped rune, size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, err: io.<a class="code-typename" href="/core/io/#Error">Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reads and returns a single rune and its <code>size</code> from the Reader's string</p>
<p><b>Inputs:</b><br><span class="doc-list">r: A pointer to a Reader struct</span></p>
<p><b>Returns:</b><br><span class="doc-list">rr: The rune read from the Reader</span>
<span class="doc-list">size: The size of the rune in bytes</span>
<span class="doc-list">err: An <code>io.Error</code> if an error occurs while reading</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="reader_seek"><span><a class="doc-id-link" href="#reader_seek">reader_seek<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/reader.odin#L239"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">reader_seek :: <span class="keyword-type">proc</span>(r: ^<a class="code-typename" href="/core/strings/#Reader">Reader</a>, offset: <a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a>, whence: io.<a class="code-typename" href="/core/io/#Seek_From">Seek_From</a>) -> (res: <a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a>, err: io.<a class="code-typename" href="/core/io/#Error">Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Seeks the Reader's index to a new position</p>
<p><b>Inputs:</b><br><span class="doc-list">r: A pointer to a Reader struct</span>
<span class="doc-list">offset: The new offset position</span>
<span class="doc-list">whence: The reference point for the new position (<code>.Start</code>, <code>.Current</code>, or <code>.End</code>)</span></p>
<p><b>Returns:</b><br><span class="doc-list">The absolute offset after seeking</span>
<span class="doc-list">err: An <code>io.Error</code> if an error occurs while seeking (<code>.Invalid_Whence</code>, <code>.Invalid_Offset</code>)</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="reader_size"><span><a class="doc-id-link" href="#reader_size">reader_size<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/reader.odin#L96"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">reader_size :: <span class="keyword-type">proc</span>(r: ^<a class="code-typename" href="/core/strings/#Reader">Reader</a>) -> (res: <a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the length of the string stored in the Reader</p>
<p><b>Inputs:</b><br><span class="doc-list">r: A pointer to a Reader struct</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The length of the string stored in the Reader</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="reader_to_stream"><span><a class="doc-id-link" href="#reader_to_stream">reader_to_stream<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/reader.odin#L37"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">reader_to_stream :: <span class="keyword-type">proc</span>(r: ^<a class="code-typename" href="/core/strings/#Reader">Reader</a>) -> (s: io.<a class="code-typename" href="/core/io/#Stream">Stream</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Converts a Reader into an <code>io.Stream</code></p>
<p><b>Inputs:</b><br><span class="doc-list">r: A pointer to a Reader struct</span></p>
<p><b>Returns:</b><br><span class="doc-list">s: An io.Stream for the given Reader</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="reader_unread_byte"><span><a class="doc-id-link" href="#reader_unread_byte">reader_unread_byte<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/reader.odin#L172"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">reader_unread_byte :: <span class="keyword-type">proc</span>(r: ^<a class="code-typename" href="/core/strings/#Reader">Reader</a>) -> (err: io.<a class="code-typename" href="/core/io/#Error">Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Decrements the Reader's index (i) by 1</p>
<p><b>Inputs:</b><br><span class="doc-list">r: A pointer to a Reader struct</span></p>
<p><b>Returns:</b><br><span class="doc-list">err: An <code>io.Error</code> if <code>r.i &lt;= 0</code> (<code>.Invalid_Unread</code>), otherwise <code>nil</code> denotes success.</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="reader_unread_rune"><span><a class="doc-id-link" href="#reader_unread_rune">reader_unread_rune<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/reader.odin#L216"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">reader_unread_rune :: <span class="keyword-type">proc</span>(r: ^<a class="code-typename" href="/core/strings/#Reader">Reader</a>) -> (err: io.<a class="code-typename" href="/core/io/#Error">Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Decrements the Reader's index (i) by the size of the last read rune</p>
<p><b>Inputs:</b><br><span class="doc-list">r: A pointer to a Reader struct</span></p>
<p>WARNING: May only be used once and after a valid <code>read_rune</code> call</p>
<p><b>Returns:</b><br><span class="doc-list">err: An <code>io.Error</code> if an error occurs while unreading (<code>.Invalid_Unread</code>), else <code>nil</code> denotes success.</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="reader_write_to"><span><a class="doc-id-link" href="#reader_write_to">reader_write_to<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/reader.odin#L272"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">reader_write_to :: <span class="keyword-type">proc</span>(r: ^<a class="code-typename" href="/core/strings/#Reader">Reader</a>, w: io.<a class="code-typename" href="/core/io/#Stream">Stream</a>) -> (n: <a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a>, err: io.<a class="code-typename" href="/core/io/#Error">Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Writes the remaining content of the Reader's string into the provided <code>io.Writer</code></p>
<p><b>Inputs:</b><br><span class="doc-list">r: A pointer to a Reader struct</span>
<span class="doc-list">w: The io.Writer to write the remaining content into</span></p>
<p>WARNING: Panics if writer writes more bytes than remainig length of string.</p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of bytes written</span>
<span class="doc-list">err: An io.Error if an error occurs while writing (<code>.Short_Write</code>)</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="remove"><span><a class="doc-id-link" href="#remove">remove<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2163"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">remove :: <span class="keyword-type">proc</span>(s, key: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (output: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, was_allocation: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Removes the key string <code>n</code> times from the <code>s</code> string</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">key: The substring to be removed</span>
<span class="doc-list">n: The number of instances to remove (if <code>n &lt; 0</code>, no limit on the number of removes)</span>
<span class="doc-list">allocator: (default: context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">output: The modified string</span>
<span class="doc-list">was_allocation: <code>true</code> if an allocation occurred during the replacement, <code>false</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

remove_example :: proc() {
	fmt.println(strings.remove("abcabc", "abc", 1))
	fmt.println(strings.remove("abcabc", "abc", -1))
	fmt.println(strings.remove("abcabc", "a", -1))
	fmt.println(strings.remove("abcabc", "x", -1))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">abc true
 true
bcbc true
abcabc false
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="remove_all"><span><a class="doc-id-link" href="#remove_all">remove_all<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2199"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">remove_all :: <span class="keyword-type">proc</span>(s, key: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (output: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, was_allocation: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Removes all the <code>key</code> string instances from the <code>s</code> string</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">key: The substring to be removed</span>
<span class="doc-list">allocator: (default: context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">output: The modified string</span>
<span class="doc-list">was_allocation: <code>true</code> if an allocation occurred during the replacement, <code>false</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

remove_all_example :: proc() {
	fmt.println(strings.remove_all("abcabc", "abc"))
	fmt.println(strings.remove_all("abcabc", "a"))
	fmt.println(strings.remove_all("abcabc", "x"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code"> true
bcbc true
abcabc false
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="repeat"><span><a class="doc-id-link" href="#repeat">repeat<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1995"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">repeat :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, count: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Repeats the string <code>s</code> <code>count</code> times, concatenating the result</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The string to repeat</span>
<span class="doc-list">count: The number of times to repeat <code>s</code></span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The concatenated repeated string</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<p>WARNING: Panics if count &lt; 0</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

repeat_example :: proc() {
	fmt.println(strings.repeat("abc", 2))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">abcabc
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="replace"><span><a class="doc-id-link" href="#replace">replace<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2085"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">replace :: <span class="keyword-type">proc</span>(
	s, old, new: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, 
	n:           <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	allocator := <a href="/base/runtime/#Context">context.allocator</a>, 
	loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>, 
) -> (output: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, was_allocation: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Replaces n instances of old in the string s with the new string</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">old: The substring to be replaced</span>
<span class="doc-list">new: The replacement string</span>
<span class="doc-list">n: The number of instances to replace (if <code>n &lt; 0</code>, no limit on the number of replacements)</span>
<span class="doc-list">allocator: (default: context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">output: The modified string</span>
<span class="doc-list">was_allocation: <code>true</code> if an allocation occurred during the replacement, <code>false</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

replace_example :: proc() {
	fmt.println(strings.replace("xyzxyz", "xyz", "abc", 2))
	fmt.println(strings.replace("xyzxyz", "xyz", "abc", 1))
	fmt.println(strings.replace("xyzxyz", "abc", "xyz", -1))
	fmt.println(strings.replace("xyzxyz", "xy", "z", -1))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">abcabc true
abcxyz true
xyzxyz false
zzzz true
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="replace_all"><span><a class="doc-id-link" href="#replace_all">replace_all<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2045"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">replace_all :: <span class="keyword-type">proc</span>(s, old, new: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (output: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, was_allocation: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="reverse"><span><a class="doc-id-link" href="#reverse">reverse<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2884"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">reverse :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reverses the input string <code>s</code></p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: A reversed version of the input string</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

reverse_example :: proc() {
	a := "abcxyz"
	b := strings.reverse(a)
	fmt.println(a, b)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">abcxyz zyxcba
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="right_justify"><span><a class="doc-id-link" href="#right_justify">right_justify<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L3113"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">right_justify :: <span class="keyword-type">proc</span>(str: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, length: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, pad: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Right-justifies the input string within a field of specified length by adding pad string on the left side, if its length is less than the target length.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">str: The input string</span>
<span class="doc-list">length: The desired length of the right-justified string</span>
<span class="doc-list">pad: The string used for padding on the left side</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: A new string right-justified within a field of the specified length</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="rune_count"><span><a class="doc-id-link" href="#rune_count">rune_count<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L369"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">rune_count :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the UTF-8 rune count of the string <code>s</code></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The UTF-8 rune count of the string <code>s</code></span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

rune_count_example :: proc() {
	fmt.println(strings.rune_count("test"))
	fmt.println(strings.rune_count("testö")) // where len("testö") == 6
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">4
5
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="scrub"><span><a class="doc-id-link" href="#scrub">scrub<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2823"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">scrub :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, replacement: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Replaces invalid UTF-8 characters in the input string with a specified replacement string. Adjacent invalid bytes are only replaced once.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">replacement: The string used to replace invalid UTF-8 characters</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: A new string with invalid UTF-8 characters replaced</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

scrub_example :: proc() {
	text := "Hello\xC0\x80World"
	fmt.println(strings.scrub(text, "?")) // -&gt; "Hello?World"
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">Hello?
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="split"><span><a class="doc-id-link" href="#split">split<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L890"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">split :: <span class="keyword-type">proc</span>(s, sep: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: []<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits a string into parts based on a separator.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The string to split.</span>
<span class="doc-list">sep: The separator string used to split the input string.</span>
<span class="doc-list">allocator: (default is context.allocator).</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The slice of strings, each representing a part of the split string.</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<p>NOTE: Allocation occurs for the array, the splits are all views of the original string.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

split_example :: proc() {
	s := "aaa.bbb.ccc.ddd.eee"    // 5 parts
	ss := strings.split(s, ".")
	fmt.println(ss)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">["aaa", "bbb", "ccc", "ddd", "eee"]
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="split_after"><span><a class="doc-id-link" href="#split_after">split_after<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L963"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">split_after :: <span class="keyword-type">proc</span>(s, sep: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: []<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits a string into parts after the separator, retaining it in the substrings.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The string to split.</span>
<span class="doc-list">sep: The separator string used to split the input string.</span>
<span class="doc-list">allocator: (default is context.allocator).</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The slice of strings, each representing a part of the split string after the separator</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<p>NOTE: Allocation occurs for the array, the splits are all views of the original string.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

split_after_example :: proc() {
	a := "aaa.bbb.ccc.ddd.eee"         // 5 parts
	aa := strings.split_after(a, ".")
	fmt.println(aa)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">["aaa.", "bbb.", "ccc.", "ddd.", "eee"]
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="split_after_iterator"><span><a class="doc-id-link" href="#split_after_iterator">split_after_iterator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1160"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">split_after_iterator :: <span class="keyword-type">proc</span>(s: ^<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, sep: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, ok: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits the input string after every separator string in an iterator fashion.</p>
<p><b>Inputs:</b><br><span class="doc-list">s: Pointer to the input string, which is modified during the search.</span>
<span class="doc-list">sep: The separator string to search for.</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The resulting substring</span>
<span class="doc-list">ok: <code>true</code> if an iteration result was returned, <code>false</code> if the iterator has reached the end</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

split_after_iterator_example :: proc() {
	text := "a.b.c.d.e"
	for str in strings.split_after_iterator(&text, ".") {
		fmt.println(str)
	}
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">a.
b.
c.
d.
e
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="split_after_n"><span><a class="doc-id-link" href="#split_after_n">split_after_n<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1000"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">split_after_n :: <span class="keyword-type">proc</span>(s, sep: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: []<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits a string into a total of <code>n</code> parts after the separator.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The string to split.</span>
<span class="doc-list">sep: The separator string used to split the input string.</span>
<span class="doc-list">n: The maximum number of parts to split the string into.</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The slice of strings with <code>n</code> parts or fewer if there weren't</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<p>NOTE: Allocation occurs for the array, the splits are all views of the original string.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

split_after_n_example :: proc() {
	a := "aaa.bbb.ccc.ddd.eee"
	aa := strings.split_after_n(a, ".", 3)
	fmt.println(aa)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">["aaa.", "bbb.", "ccc.ddd.eee"]
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="split_by_byte_iterator"><span><a class="doc-id-link" href="#split_by_byte_iterator">split_by_byte_iterator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1077"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">split_by_byte_iterator :: <span class="keyword-type">proc</span>(s: ^<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, sep: <a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, ok: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits the input string by the byte separator in an iterator fashion.</p>
<p><b>Inputs:</b><br><span class="doc-list">s: Pointer to the input string, which is modified during the search.</span>
<span class="doc-list">sep: The byte separator to search for.</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The resulting substring</span>
<span class="doc-list">ok: <code>true</code> if an iteration result was returned, <code>false</code> if the iterator has reached the end</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

split_by_byte_iterator_example :: proc() {
	text := "a.b.c.d.e"
	for str in strings.split_by_byte_iterator(&text, '.') {
		fmt.println(str) // every loop -&gt; a b c d e
	}
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">a
b
c
d
e
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="split_iterator"><span><a class="doc-id-link" href="#split_iterator">split_iterator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1124"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">split_iterator :: <span class="keyword-type">proc</span>(s: ^<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, sep: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, ok: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits the input string by the separator string in an iterator fashion.</p>
<p><b>Inputs:</b><br><span class="doc-list">s: Pointer to the input string, which is modified during the search.</span>
<span class="doc-list">sep: The separator string to search for.</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The resulting substring</span>
<span class="doc-list">ok: <code>true</code> if an iteration result was returned, <code>false</code> if the iterator has reached the end</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

split_iterator_example :: proc() {
	text := "a.b.c.d.e"
	for str in strings.split_iterator(&text, ".") {
		fmt.println(str)
	}
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">a
b
c
d
e
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="split_lines"><span><a class="doc-id-link" href="#split_lines">split_lines<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1215"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">split_lines :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: []<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits the input string at every line break <code>\n</code>.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to split.</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The slice (allocated) of the split string (slices into original string)</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

split_lines_example :: proc() {
	a := "a\nb\nc\nd\ne"
	b := strings.split_lines(a)
	fmt.println(b)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">["a", "b", "c", "d", "e"]
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="split_lines_after"><span><a class="doc-id-link" href="#split_lines_after">split_lines_after<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1296"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">split_lines_after :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: []<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits the input string at every line break <code>\n</code> leaving the <code>\n</code> in the resulting strings.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to split.</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The slice (allocated) of the split string (slices into original string), with <code>\n</code> included</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<p>NOTE: Allocation occurs for the array, the splits are all views of the original string.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

split_lines_after_example :: proc() {
	a := "a\nb\nc\nd\ne"
	b := strings.split_lines_after(a)
	fmt.println(b)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">["a\n", "b\n", "c\n", "d\n", "e"]
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="split_lines_after_iterator"><span><a class="doc-id-link" href="#split_lines_after_iterator">split_lines_after_iterator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1414"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">split_lines_after_iterator :: <span class="keyword-type">proc</span>(s: ^<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (line: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, ok: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits the input string at every line break <code>\n</code>.
Returns the current split string with line breaks included every iteration until the string is consumed.</p>
<p><b>Inputs:</b><br><span class="doc-list">s: Pointer to the input string, which is modified during the search.</span></p>
<p><b>Returns:</b><br><span class="doc-list">line: The resulting substring with line breaks included</span>
<span class="doc-list">ok: <code>true</code> if an iteration result was returned, <code>false</code> if the iterator has reached the end</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

split_lines_after_iterator_example :: proc() {
	text := "a\nb\nc\nd\ne\n"
	for str in strings.split_lines_after_iterator(&text) {
		fmt.print(str) // every loop -&gt; a\n b\n c\n d\n e\n
	}
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">a
b
c
d
e
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="split_lines_after_n"><span><a class="doc-id-link" href="#split_lines_after_n">split_lines_after_n<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1338"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">split_lines_after_n :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: []<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits the input string at every line break <code>\n</code> leaving the <code>\n</code> in the resulting strings.
Only runs for n parts.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to split.</span>
<span class="doc-list">n: The number of parts to split into.</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The slice (allocated) of the split string (slices into original string), with <code>\n</code> included</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<p>NOTE: Allocation occurs for the array, the splits are all views of the original string.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

split_lines_after_n_example :: proc() {
	a := "a\nb\nc\nd\ne"
	b := strings.split_lines_after_n(a, 3)
	fmt.println(b)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">["a\n", "b\n", "c\nd\ne"]
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="split_lines_iterator"><span><a class="doc-id-link" href="#split_lines_iterator">split_lines_iterator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1376"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">split_lines_iterator :: <span class="keyword-type">proc</span>(s: ^<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (line: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, ok: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits the input string at every line break <code>\n</code>.
Returns the current split string every iteration until the string is consumed.</p>
<p><b>Inputs:</b><br><span class="doc-list">s: Pointer to the input string, which is modified during the search.</span></p>
<p><b>Returns:</b><br><span class="doc-list">line: The resulting substring</span>
<span class="doc-list">ok: <code>true</code> if an iteration result was returned, <code>false</code> if the iterator has reached the end</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

split_lines_iterator_example :: proc() {
	text := "a\nb\nc\nd\ne"
	for str in strings.split_lines_iterator(&text) {
		fmt.print(str)    // every loop -&gt; a b c d e
	}
	fmt.print("\n")
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">abcde
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="split_lines_n"><span><a class="doc-id-link" href="#split_lines_n">split_lines_n<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L1256"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">split_lines_n :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: []<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits the input string at every line break <code>\n</code> for <code>n</code> parts.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to split.</span>
<span class="doc-list">n: The number of parts to split into.</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The slice (allocated) of the split string (slices into original string)</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<p>NOTE: Allocation occurs for the array, the splits are all views of the original string.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

split_lines_n_example :: proc() {
	a := "a\nb\nc\nd\ne"
	b := strings.split_lines_n(a, 3)
	fmt.println(b)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">["a", "b", "c\nd\ne"]
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="split_multi"><span><a class="doc-id-link" href="#split_multi">split_multi<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2693"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">split_multi :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, substrs: []<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (res: []<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits the input string <code>s</code> by all possible <code>substrs</code> and returns an allocated array of strings</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">substrs: An array of substrings used for splitting</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: An array of strings, or nil on empty substring or no matches</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<p>NOTE: Allocation occurs for the array, the splits are all views of the original string.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

split_multi_example :: proc() {
	splits := [?]string { "---", "~~~", ".", "_", "," }
	res := strings.split_multi("testing,this.out_nice---done~~~last", splits[:])
	fmt.println(res) // -&gt; [testing, this, out, nice, done, last]
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">["testing", "this", "out", "nice", "done", "last"]
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="split_multi_iterate"><span><a class="doc-id-link" href="#split_multi_iterate">split_multi_iterate<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2768"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">split_multi_iterate :: <span class="keyword-type">proc</span>(it: ^<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, substrs: []<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, ok: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits the input string <code>s</code> by all possible <code>substrs</code> in an iterator fashion. The full string is returned if no match.</p>
<p><b>Inputs:</b><br><span class="doc-list">it: A pointer to the input string</span>
<span class="doc-list">substrs: An array of substrings used for splitting</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The split string</span>
<span class="doc-list">ok: <code>true</code> if an iteration result was returned, <code>false</code> if the iterator has reached the end</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

split_multi_iterate_example :: proc() {
	it := "testing,this.out_nice---done~~~last"
	splits := [?]string { "---", "~~~", ".", "_", "," }
	for str in strings.split_multi_iterate(&it, splits[:]) {
		fmt.println(str)
	}
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">testing
this
out
nice
done
last
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="split_n"><span><a class="doc-id-link" href="#split_n">split_n<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L927"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">split_n :: <span class="keyword-type">proc</span>(s, sep: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: []<a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Splits a string into parts based on a separator. If n &lt; count of seperators, the remainder of the string is returned in the last entry.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The string to split.</span>
<span class="doc-list">sep: The separator string used to split the input string.</span>
<span class="doc-list">n: The maximum amount of parts to split the string into.</span>
<span class="doc-list">allocator: (default is context.allocator)</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The slice of strings, each representing a part of the split string.</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<p>NOTE: Allocation occurs for the array, the splits are all views of the original string.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

split_n_example :: proc() {
	s := "aaa.bbb.ccc.ddd.eee"  // 5 parts present
	ss := strings.split_n(s, ".",3) // total of 3 wanted
	fmt.println(ss)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">["aaa", "bbb", "ccc.ddd.eee"]
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="starts_with"><span><a class="doc-id-link" href="#starts_with">starts_with<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L559"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">starts_with :: <a class="code-procedure" href="/core/strings/#has_prefix">has_prefix</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Determines if a string <code>s</code> starts with a given <code>prefix</code></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The string to check for the <code>prefix</code></span>
<span class="doc-list">prefix: The prefix to look for</span></p>
<p><b>Returns:</b><br><span class="doc-list">result: <code>true</code> if the string <code>s</code> starts with the <code>prefix</code>, otherwise <code>false</code></span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

has_prefix_example :: proc() {
	fmt.println(strings.has_prefix("testing", "test"))
	fmt.println(strings.has_prefix("testing", "te"))
	fmt.println(strings.has_prefix("telephone", "te"))
	fmt.println(strings.has_prefix("testing", "est"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">true
true
true
false
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="string_case_iterator"><span><a class="doc-id-link" href="#string_case_iterator">string_case_iterator<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L225"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">string_case_iterator :: <span class="keyword-type">proc</span>(w: io.<a class="code-typename" href="/core/io/#Stream">Stream</a>, s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, callback: <span class="keyword-type">proc</span>(w: io.<a class="code-typename" href="/core/io/#Stream">Stream</a>, prev, curr, next: untyped rune)) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Iterates over a string, calling a callback for each rune with the previous, current, and next runes as arguments.</p>
<p><b>Inputs:</b><br><span class="doc-list">w: An io.Writer to be used by the callback for writing output.</span>
<span class="doc-list">s: The input string to be iterated over.</span>
<span class="doc-list">callback: A procedure to be called for each rune in the string, with arguments (w: io.Writer, prev, curr, next: rune).</span>
The callback can utilize the provided io.Writer to write output during the iteration.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"
import "core:io"

string_case_iterator_example :: proc() {
	my_callback :: proc(w: io.Writer, prev, curr, next: rune) {
		fmt.println("my_callback", curr) // &lt;-- Custom logic here
	}
	s := "hello"
	b: strings.Builder
	strings.builder_init_len(&b, len(s))
	w := strings.to_writer(&b)
	strings.string_case_iterator(w, s, my_callback)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">my_callback h
my_callback e
my_callback l
my_callback l
my_callback o
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="string_from_null_terminated_ptr"><span><a class="doc-id-link" href="#string_from_null_terminated_ptr">string_from_null_terminated_ptr<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L82"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">string_from_null_terminated_ptr :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (ptr: [^]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Transmutes a raw pointer (null-terminated) into a string. Non-allocating. Searches for a null-byte from <code>0..&lt;len</code>, otherwise <code>len</code> will be the end size</p>
<p>NOTE: The created string is only valid as long as the pointer and length are valid.</p>
<pre>  The string is truncated at the first null-byte encountered.

</pre>
<p><b>Inputs:</b><br><span class="doc-list">ptr: A pointer to the start of the null-terminated byte sequence</span>
<span class="doc-list">len: The length of the byte sequence</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: A string created from the null-terminated byte pointer and length</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="string_from_ptr"><span><a class="doc-id-link" href="#string_from_ptr">string_from_ptr<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L65"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">string_from_ptr :: <span class="keyword-type">proc</span>(ptr: ^<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Transmutes a raw pointer into a string. Non-allocating.</p>
<p><b>Inputs:</b><br><span class="doc-list">ptr: A pointer to the start of the byte sequence</span>
<span class="doc-list">len: The length of the byte sequence</span></p>
<p>NOTE: The created string is only valid as long as the pointer and length are valid.</p>
<p><b>Returns:</b><br><span class="doc-list">res: A string created from the byte pointer and length</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="substring"><span><a class="doc-id-link" href="#substring">substring<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L3433"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">substring :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, rune_start: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, rune_end: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> (sub: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, ok: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns a substring of <code>s</code> that starts at rune index <code>rune_start</code> and goes up to <code>rune_end</code>.</p>
<p>Think of it as slicing <code>s[rune_start:rune_end]</code> but rune-wise.</p>
<p><b>Inputs:</b><br><span class="doc-list">s: the string to substring</span>
<span class="doc-list">rune_start: the start (inclusive) rune</span>
<span class="doc-list">rune_end: the end (exclusive) rune</span></p>
<p><b>Returns:</b><br><span class="doc-list">sub: the substring</span>
<span class="doc-list">ok: whether the rune indexes where in bounds of the original string</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="substring_from"><span><a class="doc-id-link" href="#substring_from">substring_from<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L3454"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">substring_from :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, rune_start: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> (sub: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, ok: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns a substring of <code>s</code> that starts at rune index <code>rune_start</code> and goes up to the end of the string.</p>
<p>Think of it as slicing <code>s[rune_start:]</code> but rune-wise.</p>
<p><b>Inputs:</b><br><span class="doc-list">s: the string to substring</span>
<span class="doc-list">rune_start: the start (inclusive) rune</span></p>
<p><b>Returns:</b><br><span class="doc-list">sub: the substring</span>
<span class="doc-list">ok: whether the rune indexes where in bounds of the original string</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="substring_to"><span><a class="doc-id-link" href="#substring_to">substring_to<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L3475"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">substring_to :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, rune_end: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> (sub: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, ok: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns a substring of <code>s</code> that goes up to rune index <code>rune_end</code>.</p>
<p>Think of it as slicing <code>s[:rune_end]</code> but rune-wise.</p>
<p><b>Inputs:</b><br><span class="doc-list">s: the string to substring</span>
<span class="doc-list">rune_end: the end (exclusive) rune</span></p>
<p><b>Returns:</b><br><span class="doc-list">sub: the substring</span>
<span class="doc-list">ok: whether the rune indexes where in bounds of the original string</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_ada_case"><span><a class="doc-id-link" href="#to_ada_case">to_ada_case<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L547"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_ada_case :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Converts a string to "Ada_Case"</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to be converted</span>
<span class="doc-list">allocator: (default: context.allocator).</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The converted string</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

to_ada_case_example :: proc() {
	fmt.println(strings.to_ada_case("HelloWorld"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">Hello_World
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_camel_case"><span><a class="doc-id-link" href="#to_camel_case">to_camel_case<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L263"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_camel_case :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Converts the input string <code>s</code> to "lowerCamelCase".</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: Input string to be converted.</span>
<span class="doc-list">allocator: (default: context.allocator).</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The converted string</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_cstring"><span><a class="doc-id-link" href="#to_cstring">to_cstring<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L314"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_cstring :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>) -> (res: <a href="/base/builtin#cstring"><span class="doc-builtin">cstring</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Appends a trailing null byte after the end of the current Builder byte buffer and then casts it to a cstring</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to builder</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: A cstring of the Builder's buffer upon success</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_delimiter_case"><span><a class="doc-id-link" href="#to_delimiter_case">to_delimiter_case<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L353"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_delimiter_case :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, delimiter: untyped rune, all_upper_case: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns a string converted to a delimiter-separated case with configurable casing</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to be converted</span>
<span class="doc-list">delimiter: The rune to be used as the delimiter between words</span>
<span class="doc-list">all_upper_case: A boolean indicating if the output should be all uppercased (true) or lowercased (false)</span>
<span class="doc-list">allocator: (default: context.allocator).</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The converted string</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

to_delimiter_case_example :: proc() {
	fmt.println(strings.to_delimiter_case("Hello World", '_', false))
	fmt.println(strings.to_delimiter_case("Hello World", ' ', true))
	fmt.println(strings.to_delimiter_case("aBC", '_', false))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">hello_world
HELLO WORLD
a_bc
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_kebab_case"><span><a class="doc-id-link" href="#to_kebab_case">to_kebab_case<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L487"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_kebab_case :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Converts a string to "kebab-case" with all runes lowercased</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to be converted</span>
<span class="doc-list">allocator: (default: context.allocator).</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The converted string</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

to_kebab_case_example :: proc() {
	fmt.println(strings.to_kebab_case("HelloWorld"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">hello-world
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_lower"><span><a class="doc-id-link" href="#to_lower">to_lower<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L104"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_lower :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Converts the input string <code>s</code> to all lowercase characters.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: Input string to be converted.</span>
<span class="doc-list">allocator: (default: context.allocator).</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The new string with all characters converted to lowercase</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

to_lower_example :: proc() {
	fmt.println(strings.to_lower("TeST"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">test
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_lower_camel_case"><span><a class="doc-id-link" href="#to_lower_camel_case">to_lower_camel_case<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L263"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_lower_camel_case :: <a class="code-procedure" href="/core/strings/#to_camel_case">to_camel_case</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Converts the input string <code>s</code> to "lowerCamelCase".</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: Input string to be converted.</span>
<span class="doc-list">allocator: (default: context.allocator).</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The converted string</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_pascal_case"><span><a class="doc-id-link" href="#to_pascal_case">to_pascal_case<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L299"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_pascal_case :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Converts the input string <code>s</code> to "UpperCamelCase" (PascalCase).</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: Input string to be converted.</span>
<span class="doc-list">allocator: (default: context.allocator).</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The converted string</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_reader"><span><a class="doc-id-link" href="#to_reader">to_reader<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/reader.odin#L52"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_reader :: <span class="keyword-type">proc</span>(r: ^<a class="code-typename" href="/core/strings/#Reader">Reader</a>, s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: io.<a class="code-typename" href="/core/io/#Stream">Stream</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initializes a string Reader and returns an <code>io.Reader</code> for the given string</p>
<p><b>Inputs:</b><br><span class="doc-list">r: A pointer to a Reader struct</span>
<span class="doc-list">s: The input string to be read</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: An io.Reader for the given string</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_reader_at"><span><a class="doc-id-link" href="#to_reader_at">to_reader_at<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/reader.odin#L67"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_reader_at :: <span class="keyword-type">proc</span>(r: ^<a class="code-typename" href="/core/strings/#Reader">Reader</a>, s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: io.<a class="code-typename" href="/core/io/#Stream">Stream</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Initializes a string Reader and returns an <code>io.Reader_At</code> for the given string</p>
<p><b>Inputs:</b><br><span class="doc-list">r: A pointer to a Reader struct</span>
<span class="doc-list">s: The input string to be read</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: An <code>io.Reader_At</code> for the given string</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_screaming_snake_case"><span><a class="doc-id-link" href="#to_screaming_snake_case">to_screaming_snake_case<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L457"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_screaming_snake_case :: <a class="code-procedure" href="/core/strings/#to_upper_snake_case">to_upper_snake_case</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Converts a string to "SNAKE_CASE" with all runes uppercased</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to be converted</span>
<span class="doc-list">allocator: (default: context.allocator).</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The converted string</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

to_upper_snake_case_example :: proc() {
	fmt.println(strings.to_upper_snake_case("HelloWorld"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">HELLO_WORLD
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_snake_case"><span><a class="doc-id-link" href="#to_snake_case">to_snake_case<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L425"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_snake_case :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Converts a string to "snake_case" with all runes lowercased</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to be converted</span>
<span class="doc-list">allocator: (default: context.allocator).</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The converted string</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

to_snake_case_example :: proc() {
	fmt.println(strings.to_snake_case("HelloWorld"))
	fmt.println(strings.to_snake_case("Hello World"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">hello_world
hello_world
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_stream"><span><a class="doc-id-link" href="#to_stream">to_stream<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L197"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_stream :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>) -> (res: io.<a class="code-typename" href="/core/io/#Stream">Stream</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns an io.Stream from a Builder</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: the io.Stream</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_string"><span><a class="doc-id-link" href="#to_string">to_string<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L285"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_string :: <span class="keyword-type">proc</span>(b: <a class="code-typename" href="/core/strings/#Builder">Builder</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Casts the Builder byte buffer to a string and returns it</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A Builder</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The contents of the Builder's buffer, as a string</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_upper"><span><a class="doc-id-link" href="#to_upper">to_upper<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L139"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_upper :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Converts the input string <code>s</code> to all uppercase characters.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: Input string to be converted.</span>
<span class="doc-list">allocator: (default: context.allocator).</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The new string with all characters converted to uppercase</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

to_upper_example :: proc() {
	fmt.println(strings.to_upper("Test"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">TEST
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_upper_camel_case"><span><a class="doc-id-link" href="#to_upper_camel_case">to_upper_camel_case<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L299"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_upper_camel_case :: <a class="code-procedure" href="/core/strings/#to_pascal_case">to_pascal_case</a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Converts the input string <code>s</code> to "UpperCamelCase" (PascalCase).</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: Input string to be converted.</span>
<span class="doc-list">allocator: (default: context.allocator).</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The converted string</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_upper_kebab_case"><span><a class="doc-id-link" href="#to_upper_kebab_case">to_upper_kebab_case<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L517"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_upper_kebab_case :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Converts a string to "KEBAB-CASE" with all runes uppercased</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to be converted</span>
<span class="doc-list">allocator: (default: context.allocator).</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The converted string</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

to_upper_kebab_case_example :: proc() {
	fmt.println(strings.to_upper_kebab_case("HelloWorld"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">HELLO-WORLD
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_upper_snake_case"><span><a class="doc-id-link" href="#to_upper_snake_case">to_upper_snake_case<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L457"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_upper_snake_case :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Converts a string to "SNAKE_CASE" with all runes uppercased</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string to be converted</span>
<span class="doc-list">allocator: (default: context.allocator).</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The converted string</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

to_upper_snake_case_example :: proc() {
	fmt.println(strings.to_upper_snake_case("HelloWorld"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">HELLO_WORLD
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_valid_utf8"><span><a class="doc-id-link" href="#to_valid_utf8">to_valid_utf8<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin#L24"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_valid_utf8 :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, replacement: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, allocator := <a href="/base/runtime/#Context">context.allocator</a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, err: runtime.<a class="code-typename" href="/base/runtime/#Allocator_Error">Allocator_Error</a>) <span class="directive">#optional_ok</span> {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Converts invalid UTF-8 sequences in the input string <code>s</code> to the <code>replacement</code> string.</p>
<p><i>Allocates Using Provided Allocator</i></p>
<p><b>Inputs:</b><br><span class="doc-list">s: Input string that may contain invalid UTF-8 sequences.</span>
<span class="doc-list">replacement: String to replace invalid UTF-8 sequences with.</span>
<span class="doc-list">allocator: (default: context.allocator).</span></p>
<p>WARNING: Allocation does not occur when len(s) == 0</p>
<p><b>Returns:</b><br><span class="doc-list">res: A valid UTF-8 string with invalid sequences replaced by <code>replacement</code>.</span>
<span class="doc-list">err: An optional allocator error if one occured, <code>nil</code> otherwise</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_writer"><span><a class="doc-id-link" href="#to_writer">to_writer<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L209"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_writer :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>) -> (res: io.<a class="code-typename" href="/core/io/#Stream">Stream</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns an io.Writer from a Builder</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The io.Writer</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="trim"><span><a class="doc-id-link" href="#trim">trim<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2514"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">trim :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, cutset: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Trims the cutset string from the <code>s</code> string, both from left and right</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">cutset: The set of characters to be trimmed from both sides of the input string</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The trimmed string as a slice of the original</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="trim_left"><span><a class="doc-id-link" href="#trim_left">trim_left<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2478"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">trim_left :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, cutset: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Trims the cutset string from the <code>s</code> string</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">cutset: The set of characters to be trimmed from the left of the input string</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The trimmed string as a slice of the original</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="trim_left_null"><span><a class="doc-id-link" href="#trim_left_null">trim_left_null<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2566"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">trim_left_null :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Trims null runes from the left, "\x00\x00testing\x00\x00" -&gt; "testing\x00\x00"</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The trimmed string as a slice of the original</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="trim_left_proc"><span><a class="doc-id-link" href="#trim_left_proc">trim_left_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2370"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">trim_left_proc :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, p: <span class="keyword-type">proc</span>(untyped rune) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Trims the input string <code>s</code> from the left until the procedure <code>p</code> returns false</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">p: A procedure that takes a rune and returns a boolean</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The trimmed string as a slice of the original</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

trim_left_proc_example :: proc() {
	find :: proc(r: rune) -&gt; bool {
		return r == 'x'
	}
	fmt.println(strings.trim_left_proc("xxxxxxtesting", find))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">testing
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="trim_left_proc_with_state"><span><a class="doc-id-link" href="#trim_left_proc_with_state">trim_left_proc_with_state<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2389"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">trim_left_proc_with_state :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, p: <span class="keyword-type">proc</span>(<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, untyped rune) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>, state: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Trims the input string <code>s</code> from the left until the procedure <code>p</code> with state returns false</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">p: A procedure that takes a raw pointer and a rune and returns a boolean</span>
<span class="doc-list">state: The raw pointer to be passed to the procedure <code>p</code></span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The trimmed string as a slice of the original</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="trim_left_space"><span><a class="doc-id-link" href="#trim_left_space">trim_left_space<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2527"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">trim_left_space :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Trims until a valid non-space rune from the left, "\t\txyz\t\t" -&gt; "xyz\t\t"</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The trimmed string as a slice of the original</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="trim_null"><span><a class="doc-id-link" href="#trim_null">trim_null<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2591"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">trim_null :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Trims null runes from both sides, "\x00\x00testing\x00\x00" -&gt; "testing"</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
Returns:
<span class="doc-list">res: The trimmed string as a slice of the original</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="trim_prefix"><span><a class="doc-id-link" href="#trim_prefix">trim_prefix<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2621"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">trim_prefix :: <span class="keyword-type">proc</span>(s, prefix: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Trims a <code>prefix</code> string from the start of the <code>s</code> string and returns the trimmed string</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">prefix: The prefix string to be removed</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The trimmed string as a slice of original, or the input string if no prefix was found</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

trim_prefix_example :: proc() {
	fmt.println(strings.trim_prefix("testing", "test"))
	fmt.println(strings.trim_prefix("testing", "abc"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">ing
testing
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="trim_right"><span><a class="doc-id-link" href="#trim_right">trim_right<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2496"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">trim_right :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, cutset: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Trims the cutset string from the <code>s</code> string from the right</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">cutset: The set of characters to be trimmed from the right of the input string</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The trimmed string as a slice of the original</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="trim_right_null"><span><a class="doc-id-link" href="#trim_right_null">trim_right_null<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2579"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">trim_right_null :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Trims null runes from the right, "\x00\x00testing\x00\x00" -&gt; "\x00\x00testing"</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The trimmed string as a slice of the original</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="trim_right_proc"><span><a class="doc-id-link" href="#trim_right_proc">trim_right_proc<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2424"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">trim_right_proc :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, p: <span class="keyword-type">proc</span>(untyped rune) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Trims the input string <code>s</code> from the right until the procedure <code>p</code> returns <code>false</code></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">p: A procedure that takes a rune and returns a boolean</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The trimmed string as a slice of the original</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

trim_right_proc_example :: proc() {
	find :: proc(r: rune) -&gt; bool {
		return r != 't'
	}
	fmt.println(strings.trim_right_proc("testing", find))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">test
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="trim_right_proc_with_state"><span><a class="doc-id-link" href="#trim_right_proc_with_state">trim_right_proc_with_state<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2446"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">trim_right_proc_with_state :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, p: <span class="keyword-type">proc</span>(<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, untyped rune) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>, state: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Trims the input string <code>s</code> from the right until the procedure <code>p</code> with state returns <code>false</code></p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">p: A procedure that takes a raw pointer and a rune and returns a boolean</span>
<span class="doc-list">state: The raw pointer to be passed to the procedure <code>p</code></span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The trimmed string as a slice of the original, empty when no match</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="trim_right_space"><span><a class="doc-id-link" href="#trim_right_space">trim_right_space<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2540"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">trim_right_space :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Trims from the right until a valid non-space rune, "\t\txyz\t\t" -&gt; "\t\txyz"</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The trimmed string as a slice of the original</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="trim_space"><span><a class="doc-id-link" href="#trim_space">trim_space<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2553"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">trim_space :: <span class="keyword-type">proc</span>(s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Trims from both sides until a valid non-space rune, "\t\txyz\t\t" -&gt; "xyz"</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The trimmed string as a slice of the original</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="trim_suffix"><span><a class="doc-id-link" href="#trim_suffix">trim_suffix<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L2654"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">trim_suffix :: <span class="keyword-type">proc</span>(s, suffix: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Trims a <code>suffix</code> string from the end of the <code>s</code> string and returns the trimmed string</p>
<p><b>Inputs:</b><br><span class="doc-list">s: The input string</span>
<span class="doc-list">suffix: The suffix string to be removed</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The trimmed string as a slice of original, or the input string if no suffix was found</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

trim_suffix_example :: proc() {
	fmt.println(strings.trim_suffix("todo.txt", ".txt"))
	fmt.println(strings.trim_suffix("todo.doc", ".txt"))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">todo
todo.doc
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="truncate_to_byte"><span><a class="doc-id-link" href="#truncate_to_byte">truncate_to_byte<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L116"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">truncate_to_byte :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (str: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, b: <a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Truncates a string <code>str</code> at the first occurrence of char/byte <code>b</code></p>
<p><b>Inputs:</b><br><span class="doc-list">str: The input string</span>
<span class="doc-list">b: The byte to truncate the string at</span></p>
<p>NOTE: Failure to find the byte results in returning the entire string.</p>
<p><b>Returns:</b><br><span class="doc-list">res: The truncated string</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="truncate_to_rune"><span><a class="doc-id-link" href="#truncate_to_rune">truncate_to_rune<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L134"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">truncate_to_rune :: <span class="keyword-type">proc</span>(str: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, r: untyped rune) -> (res: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Truncates a string <code>str</code> at the first occurrence of rune <code>r</code> as a slice of the original, entire string if not found</p>
<p><b>Inputs:</b><br><span class="doc-list">str: The input string</span>
<span class="doc-list">r: The rune to truncate the string at</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The truncated string</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="unsafe_string_to_cstring"><span><a class="doc-id-link" href="#unsafe_string_to_cstring">unsafe_string_to_cstring<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L99"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">unsafe_string_to_cstring :: <span class="keyword-type">proc</span>(str: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (res: <a href="/base/builtin#cstring"><span class="doc-builtin">cstring</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Converts a string <code>str</code> to a cstring</p>
<p><b>Inputs:</b><br><span class="doc-list">str: The input string</span></p>
<p>WARNING: This is unsafe because the original string may not contain a null-byte.</p>
<p><b>Returns:</b><br><span class="doc-list">res: The converted cstring</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="unsafe_to_cstring"><span><a class="doc-id-link" href="#unsafe_to_cstring">unsafe_to_cstring<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L299"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">unsafe_to_cstring :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>) -> (res: <a href="/base/builtin#cstring"><span class="doc-builtin">cstring</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Appends a trailing null byte after the end of the current Builder byte buffer and then casts it to a cstring</p>
<p>NOTE: This procedure will not check if the backing buffer has enough space to include the extra null byte.</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to builder</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: A cstring of the Builder's buffer</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="write_byte"><span><a class="doc-id-link" href="#write_byte">write_byte<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L390"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">write_byte :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, x: <a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Appends a byte to the Builder and returns the number of bytes appended</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">x: The byte to be appended</span></p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of bytes appended</span></p>
<p>NOTE: The backing dynamic array may be fixed in capacity or fail to resize, <code>n</code> states the number actually written.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

write_byte_example :: proc() {
	builder := strings.builder_make()
	strings.write_byte(&builder, 'a')        // 1
	strings.write_byte(&builder, 'b')        // 1
	fmt.println(strings.to_string(builder))  // -&gt; ab
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">ab
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="write_bytes"><span><a class="doc-id-link" href="#write_bytes">write_bytes<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L420"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">write_bytes :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, x: []<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, loc := <a href="/base/runtime/#Source_Code_Location">#caller_location</a>) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Appends a slice of bytes to the Builder and returns the number of bytes appended</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">x: The slice of bytes to be appended</span></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

write_bytes_example :: proc() {
	builder := strings.builder_make()
	bytes := [?]byte { 'a', 'b', 'c' }
	strings.write_bytes(&builder, bytes[:]) // 3
	fmt.println(strings.to_string(builder)) // -&gt; abc
}
</code></pre>
</details>
<p>NOTE: The backing dynamic array may be fixed in capacity or fail to resize, <code>n</code> states the number actually written.</p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of bytes appended</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="write_encoded_rune"><span><a class="doc-id-link" href="#write_encoded_rune">write_encoded_rune<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L632"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">write_encoded_rune :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, r: untyped rune, write_quote: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> = true) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Appends a rune to the Builder and returns the number of bytes written</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">r: The rune to be appended</span>
<span class="doc-list">write_quote: Optional boolean flag to wrap in single-quotes (') (default is true)</span></p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of bytes written</span></p>
<p>NOTE: The backing dynamic array may be fixed in capacity or fail to resize, <code>n</code> states the number actually written.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

write_encoded_rune_example :: proc() {
	builder := strings.builder_make()
	strings.write_encoded_rune(&builder, 'a', false) // 1
	strings.write_encoded_rune(&builder, '\"', true) // 3
	strings.write_encoded_rune(&builder, 'x', false) // 1
	fmt.println(strings.to_string(builder))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">a'"'x
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="write_escaped_rune"><span><a class="doc-id-link" href="#write_escaped_rune">write_escaped_rune<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L656"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">write_escaped_rune :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, r: untyped rune, quote: <a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, html_safe: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> = false) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Appends an escaped rune to the Builder and returns the number of bytes written</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">r: The rune to be appended</span>
<span class="doc-list">quote: The quote character</span>
<span class="doc-list">html_safe: Optional boolean flag to encode '&lt;', '&gt;', '&' as digits (default is false)</span></p>
<p><b>Usage</b>
<span class="doc-list">'\a' will be written as such</span>
<span class="doc-list"><code>r</code> and <code>quote</code> match and <code>quote</code> is <code>\\</code> - they will be written as two slashes</span>
<span class="doc-list"><code>html_safe</code> flag in case the runes '&lt;', '&gt;', '&' should be encoded as digits e.g. <code>\u0026</code></span></p>
<p>NOTE: The backing dynamic array may be fixed in capacity or fail to resize, <code>n</code> states the number actually written.</p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of bytes written</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="write_f16"><span><a class="doc-id-link" href="#write_f16">write_f16<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L700"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">write_f16 :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, f: <a href="/base/builtin#f16"><span class="doc-builtin">f16</span></a>, fmt: <a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, always_signed: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> = false) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Writes a f16 value to the Builder and returns the number of characters written</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">f: The f16 value to be appended</span>
<span class="doc-list">fmt: The format byte</span>
<span class="doc-list">always_signed: Optional boolean flag to always include the sign</span></p>
<p>NOTE: The backing dynamic array may be fixed in capacity or fail to resize, <code>n</code> states the number actually written.</p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of characters written</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="write_f32"><span><a class="doc-id-link" href="#write_f32">write_f32<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L740"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">write_f32 :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, f: <a href="/base/builtin#f32"><span class="doc-builtin">f32</span></a>, fmt: <a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, always_signed: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> = false) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Writes a f32 value to the Builder and returns the number of characters written</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">f: The f32 value to be appended</span>
<span class="doc-list">fmt: The format byte</span>
<span class="doc-list">always_signed: Optional boolean flag to always include the sign</span></p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of characters written</span></p>
<p>NOTE: The backing dynamic array may be fixed in capacity or fail to resize, <code>n</code> states the number actually written.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

write_f32_example :: proc() {
	builder := strings.builder_make()
	strings.write_f32(&builder, 3.14159, 'f') // 6
	strings.write_string(&builder, " - ")     // 3
	strings.write_f32(&builder, -0.123, 'e')  // 8
	fmt.println(strings.to_string(builder))   // -&gt; 3.14159012 - -1.23000003e-01
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">3.14159012 - -1.23000003e-01
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="write_f64"><span><a class="doc-id-link" href="#write_f64">write_f64<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L762"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">write_f64 :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, f: <a href="/base/builtin#f64"><span class="doc-builtin">f64</span></a>, fmt: <a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, always_signed: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> = false) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Writes a f64 value to the Builder and returns the number of characters written</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">f: The f64 value to be appended</span>
<span class="doc-list">fmt: The format byte</span>
<span class="doc-list">always_signed: Optional boolean flag to always include the sign</span></p>
<p>NOTE: The backing dynamic array may be fixed in capacity or fail to resize, <code>n</code> states the number actually written.</p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of characters written</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="write_float"><span><a class="doc-id-link" href="#write_float">write_float<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L676"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">write_float :: <span class="keyword-type">proc</span>(
	b:              ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, 
	f:              <a href="/base/builtin#f64"><span class="doc-builtin">f64</span></a>, 
	fmt:            <a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a>, 
	prec, bit_size: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, 
	always_signed:  <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> = false, 
) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Writes a f64 value to the Builder and returns the number of characters written</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">f: The f64 value to be appended</span>
<span class="doc-list">fmt: The format byte</span>
<span class="doc-list">prec: The precision</span>
<span class="doc-list">bit_size: The bit size</span>
<span class="doc-list">always_signed: Optional boolean flag to always include the sign (default is false)</span></p>
<p>NOTE: The backing dynamic array may be fixed in capacity or fail to resize, <code>n</code> states the number actually written.</p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of characters written</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="write_i64"><span><a class="doc-id-link" href="#write_i64">write_i64<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L801"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">write_i64 :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, i: <a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a>, base: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = 10) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Writes a i64 value to the Builder and returns the number of characters written</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">i: The i64 value to be appended</span>
<span class="doc-list">base: The optional base for the numeric representation</span></p>
<p>NOTE: The backing dynamic array may be fixed in capacity or fail to resize, <code>n</code> states the number actually written.</p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of characters written</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="write_int"><span><a class="doc-id-link" href="#write_int">write_int<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L835"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">write_int :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, i: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, base: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = 10) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Writes a int value to the Builder and returns the number of characters written</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">i: The int value to be appended</span>
<span class="doc-list">base: The optional base for the numeric representation</span></p>
<p>NOTE: The backing dynamic array may be fixed in capacity or fail to resize, <code>n</code> states the number actually written.</p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of characters written</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="write_quoted_rune"><span><a class="doc-id-link" href="#write_quoted_rune">write_quoted_rune<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L489"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">write_quoted_rune :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, r: untyped rune) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Appends a quoted rune to the Builder and returns the number of bytes written</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">r: The rune to be appended</span></p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of bytes written</span></p>
<p>NOTE: The backing dynamic array may be fixed in capacity or fail to resize, <code>n</code> states the number actually written.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

write_quoted_rune_example :: proc() {
	builder := strings.builder_make()
	strings.write_string(&builder, "abc")      // 3
	strings.write_quoted_rune(&builder, 'ä') // 4
	strings.write_string(&builder, "abc")      // 3
	fmt.println(strings.to_string(builder))    // -&gt; abc'ä'abc
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">abc'ä'abc
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="write_quoted_string"><span><a class="doc-id-link" href="#write_quoted_string">write_quoted_string<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L597"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">write_quoted_string :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, str: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>, quote: <a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a> = '"') -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">str: The string to be quoted and appended</span>
<span class="doc-list">quote: The optional quote character (default is double quotes)</span></p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of bytes written</span></p>
<p>NOTE: The backing dynamic array may be fixed in capacity or fail to resize, <code>n</code> states the number actually written.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

write_quoted_string_example :: proc() {
	builder := strings.builder_make()
	strings.write_quoted_string(&builder, "a")        // 3
	strings.write_quoted_string(&builder, "bc", '\'') // 4
	strings.write_quoted_string(&builder, "xyz")      // 5
	fmt.println(strings.to_string(builder))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">"a"'bc'"xyz"
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="write_rune"><span><a class="doc-id-link" href="#write_rune">write_rune<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L456"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">write_rune :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, r: untyped rune) -> (res: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, err: io.<a class="code-typename" href="/core/io/#Error">Error</a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Appends a single rune to the Builder and returns the number of bytes written and an <code>io.Error</code></p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">r: The rune to be appended</span></p>
<p><b>Returns:</b><br><span class="doc-list">res: The number of bytes written</span>
<span class="doc-list">err: An io.Error if one occured, <code>nil</code> otherwise</span></p>
<p>NOTE: The backing dynamic array may be fixed in capacity or fail to resize, <code>n</code> states the number actually written.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

write_rune_example :: proc() {
	builder := strings.builder_make()
	strings.write_rune(&builder, 'ä')     // 2 None
	strings.write_rune(&builder, 'b')       // 1 None
	fmt.println(strings.to_string(builder)) // -&gt; äb
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">äb
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="write_string"><span><a class="doc-id-link" href="#write_string">write_string<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L521"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">write_string :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, s: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Appends a string to the Builder and returns the number of bytes written</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">s: The string to be appended</span></p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of bytes written</span></p>
<p>NOTE: The backing dynamic array may be fixed in capacity or fail to resize, <code>n</code> states the number actually written.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"

write_string_example :: proc() {
	builder := strings.builder_make()
	strings.write_string(&builder, "a")     // 1
	strings.write_string(&builder, "bc")    // 2
	fmt.println(strings.to_string(builder)) // -&gt; abc
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">abc
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="write_u64"><span><a class="doc-id-link" href="#write_u64">write_u64<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L783"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">write_u64 :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, i: <a href="/base/builtin#u64"><span class="doc-builtin">u64</span></a>, base: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = 10) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Writes a u64 value to the Builder and returns the number of characters written</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">i: The u64 value to be appended</span>
<span class="doc-list">base: The optional base for the numeric representation</span></p>
<p>NOTE: The backing dynamic array may be fixed in capacity or fail to resize, <code>n</code> states the number actually written.</p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of characters written</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="write_uint"><span><a class="doc-id-link" href="#write_uint">write_uint<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L819"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">write_uint :: <span class="keyword-type">proc</span>(b: ^<a class="code-typename" href="/core/strings/#Builder">Builder</a>, i: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>, base: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> = 10) -> (n: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Writes a uint value to the Builder and returns the number of characters written</p>
<p><b>Inputs:</b><br><span class="doc-list">b: A pointer to the Builder</span>
<span class="doc-list">i: The uint value to be appended</span>
<span class="doc-list">base: The optional base for the numeric representation</span></p>
<p>NOTE: The backing dynamic array may be fixed in capacity or fail to resize, <code>n</code> states the number actually written.</p>
<p><b>Returns:</b><br><span class="doc-list">n: The number of characters written</span></p>
</details>
</div>
<h2 id="pkg-Procedure Groups" class="pkg-header">Procedure Groups</h2>
<div class="pkg-entity">
<h3 id="builder_init"><span><a class="doc-id-link" href="#builder_init">builder_init<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L161"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">builder_init :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/strings/#builder_init_none">builder_init_none</a>,
	<a class="code-procedure" href="/core/strings/#builder_init_len">builder_init_len</a>,
	<a class="code-procedure" href="/core/strings/#builder_init_len_cap">builder_init_len_cap</a>,
}
</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Overload simple <code>builder_init_*</code> with or without len / ap parameters</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="builder_make"><span><a class="doc-id-link" href="#builder_make">builder_make<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin#L100"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">builder_make :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/strings/#builder_make_none">builder_make_none</a>,
	<a class="code-procedure" href="/core/strings/#builder_make_len">builder_make_len</a>,
	<a class="code-procedure" href="/core/strings/#builder_make_len_cap">builder_make_len_cap</a>,
}
</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Produces a String Builder</p>
<p><i>Allocates Using Provided Allocator</i></p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:fmt"
import "core:strings"
builder_make_example :: proc() {
	sb := strings.builder_make()
	strings.write_byte(&sb, 'a')
	strings.write_string(&sb, " slice of ")
	strings.write_f64(&sb, 3.14,'g',true) // See `fmt.fmt_float` byte codes
	strings.write_string(&sb, " is ")
	strings.write_int(&sb, 180)
	strings.write_rune(&sb,'°')
	the_string :=strings.to_string(sb)
	fmt.println(the_string)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">a slice of +3.14 is 180°
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="clone_from"><span><a class="doc-id-link" href="#clone_from">clone_from<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin#L204"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">clone_from :: <span class="keyword-type">proc</span>{
	<a class="code-procedure" href="/core/strings/#clone">clone</a>,
	<a class="code-procedure" href="/core/strings/#clone_from_bytes">clone_from_bytes</a>,
	<a class="code-procedure" href="/core/strings/#clone_from_cstring">clone_from_cstring</a>,
	<a class="code-procedure" href="/core/strings/#clone_from_ptr">clone_from_ptr</a>,
}
</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Overloaded procedure to clone from a string, <code>[]byte</code>, <code>cstring</code> or a <code>^byte</code> + length</p>
</details>
</div>
</section>
<h2 id="pkg-source-files">Source Files</h2>
<ul>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/ascii_set.odin">ascii_set.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/builder.odin">builder.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/conversion.odin">conversion.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/intern.odin">intern.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/reader.odin">reader.odin</a></li>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/strings/strings.odin">strings.odin</a></li>
</ul>
<h2 id="pkg-generation-information">Generation Information</h2>
<p>Generated with <code>odin version dev-2025-06 (vendor "odin") Windows_amd64 @ 2025-06-27 21:13:16.979382700 +0000 UTC</code></p>
</article>
<div class="col-lg-2 odin-toc-border navbar-light"><div class="sticky-top odin-below-navbar py-3">
<nav id="TableOfContents">
<ul>
<li><a href="#pkg-overview">Overview</a><li><a href="#pkg-Types">Types</a><ul>
<li><a href="#Ascii_Set">Ascii_Set</a></li>
<li><a href="#Builder">Builder</a></li>
<li><a href="#Builder_Flush_Proc">Builder_Flush_Proc</a></li>
<li><a href="#Intern">Intern</a></li>
<li><a href="#Intern_Entry">Intern_Entry</a></li>
<li><a href="#Reader">Reader</a></li>
</ul>
</li>
<li><a href="#pkg-Procedures">Procedures</a><ul>
<li><a href="#ascii_set_contains">ascii_set_contains</a></li>
<li><a href="#ascii_set_make">ascii_set_make</a></li>
<li><a href="#builder_cap">builder_cap</a></li>
<li><a href="#builder_destroy">builder_destroy</a></li>
<li><a href="#builder_from_bytes">builder_from_bytes</a></li>
<li><a href="#builder_from_slice">builder_from_slice</a></li>
<li><a href="#builder_grow">builder_grow</a></li>
<li><a href="#builder_init_len">builder_init_len</a></li>
<li><a href="#builder_init_len_cap">builder_init_len_cap</a></li>
<li><a href="#builder_init_none">builder_init_none</a></li>
<li><a href="#builder_len">builder_len</a></li>
<li><a href="#builder_make_len">builder_make_len</a></li>
<li><a href="#builder_make_len_cap">builder_make_len_cap</a></li>
<li><a href="#builder_make_none">builder_make_none</a></li>
<li><a href="#builder_reset">builder_reset</a></li>
<li><a href="#builder_space">builder_space</a></li>
<li><a href="#center_justify">center_justify</a></li>
<li><a href="#centre_justify">centre_justify</a></li>
<li><a href="#clone">clone</a></li>
<li><a href="#clone_from_bytes">clone_from_bytes</a></li>
<li><a href="#clone_from_cstring">clone_from_cstring</a></li>
<li><a href="#clone_from_cstring_bounded">clone_from_cstring_bounded</a></li>
<li><a href="#clone_from_ptr">clone_from_ptr</a></li>
<li><a href="#clone_to_cstring">clone_to_cstring</a></li>
<li><a href="#common_prefix">common_prefix</a></li>
<li><a href="#compare">compare</a></li>
<li><a href="#concatenate">concatenate</a></li>
<li><a href="#contains">contains</a></li>
<li><a href="#contains_any">contains_any</a></li>
<li><a href="#contains_rune">contains_rune</a></li>
<li><a href="#contains_space">contains_space</a></li>
<li><a href="#count">count</a></li>
<li><a href="#cut">cut</a></li>
<li><a href="#cut_clone">cut_clone</a></li>
<li><a href="#ends_with">ends_with</a></li>
<li><a href="#equal_fold">equal_fold</a></li>
<li><a href="#expand_tabs">expand_tabs</a></li>
<li><a href="#fields">fields</a></li>
<li><a href="#fields_iterator">fields_iterator</a></li>
<li><a href="#fields_proc">fields_proc</a></li>
<li><a href="#has_prefix">has_prefix</a></li>
<li><a href="#has_suffix">has_suffix</a></li>
<li><a href="#index">index</a></li>
<li><a href="#index_any">index_any</a></li>
<li><a href="#index_byte">index_byte</a></li>
<li><a href="#index_multi">index_multi</a></li>
<li><a href="#index_proc">index_proc</a></li>
<li><a href="#index_proc_with_state">index_proc_with_state</a></li>
<li><a href="#index_rune">index_rune</a></li>
<li><a href="#intern_destroy">intern_destroy</a></li>
<li><a href="#intern_get">intern_get</a></li>
<li><a href="#intern_get_cstring">intern_get_cstring</a></li>
<li><a href="#intern_init">intern_init</a></li>
<li><a href="#is_ascii_space">is_ascii_space</a></li>
<li><a href="#is_delimiter">is_delimiter</a></li>
<li><a href="#is_in_cutset">is_in_cutset</a></li>
<li><a href="#is_null">is_null</a></li>
<li><a href="#is_separator">is_separator</a></li>
<li><a href="#is_space">is_space</a></li>
<li><a href="#join">join</a></li>
<li><a href="#last_index">last_index</a></li>
<li><a href="#last_index_any">last_index_any</a></li>
<li><a href="#last_index_byte">last_index_byte</a></li>
<li><a href="#last_index_proc">last_index_proc</a></li>
<li><a href="#last_index_proc_with_state">last_index_proc_with_state</a></li>
<li><a href="#left_justify">left_justify</a></li>
<li><a href="#levenshtein_distance">levenshtein_distance</a></li>
<li><a href="#partition">partition</a></li>
<li><a href="#pop_byte">pop_byte</a></li>
<li><a href="#pop_rune">pop_rune</a></li>
<li><a href="#prefix_length">prefix_length</a></li>
<li><a href="#reader_init">reader_init</a></li>
<li><a href="#reader_length">reader_length</a></li>
<li><a href="#reader_read">reader_read</a></li>
<li><a href="#reader_read_at">reader_read_at</a></li>
<li><a href="#reader_read_byte">reader_read_byte</a></li>
<li><a href="#reader_read_rune">reader_read_rune</a></li>
<li><a href="#reader_seek">reader_seek</a></li>
<li><a href="#reader_size">reader_size</a></li>
<li><a href="#reader_to_stream">reader_to_stream</a></li>
<li><a href="#reader_unread_byte">reader_unread_byte</a></li>
<li><a href="#reader_unread_rune">reader_unread_rune</a></li>
<li><a href="#reader_write_to">reader_write_to</a></li>
<li><a href="#remove">remove</a></li>
<li><a href="#remove_all">remove_all</a></li>
<li><a href="#repeat">repeat</a></li>
<li><a href="#replace">replace</a></li>
<li><a href="#replace_all">replace_all</a></li>
<li><a href="#reverse">reverse</a></li>
<li><a href="#right_justify">right_justify</a></li>
<li><a href="#rune_count">rune_count</a></li>
<li><a href="#scrub">scrub</a></li>
<li><a href="#split">split</a></li>
<li><a href="#split_after">split_after</a></li>
<li><a href="#split_after_iterator">split_after_iterator</a></li>
<li><a href="#split_after_n">split_after_n</a></li>
<li><a href="#split_by_byte_iterator">split_by_byte_iterator</a></li>
<li><a href="#split_iterator">split_iterator</a></li>
<li><a href="#split_lines">split_lines</a></li>
<li><a href="#split_lines_after">split_lines_after</a></li>
<li><a href="#split_lines_after_iterator">split_lines_after_iterator</a></li>
<li><a href="#split_lines_after_n">split_lines_after_n</a></li>
<li><a href="#split_lines_iterator">split_lines_iterator</a></li>
<li><a href="#split_lines_n">split_lines_n</a></li>
<li><a href="#split_multi">split_multi</a></li>
<li><a href="#split_multi_iterate">split_multi_iterate</a></li>
<li><a href="#split_n">split_n</a></li>
<li><a href="#starts_with">starts_with</a></li>
<li><a href="#string_case_iterator">string_case_iterator</a></li>
<li><a href="#string_from_null_terminated_ptr">string_from_null_terminated_ptr</a></li>
<li><a href="#string_from_ptr">string_from_ptr</a></li>
<li><a href="#substring">substring</a></li>
<li><a href="#substring_from">substring_from</a></li>
<li><a href="#substring_to">substring_to</a></li>
<li><a href="#to_ada_case">to_ada_case</a></li>
<li><a href="#to_camel_case">to_camel_case</a></li>
<li><a href="#to_cstring">to_cstring</a></li>
<li><a href="#to_delimiter_case">to_delimiter_case</a></li>
<li><a href="#to_kebab_case">to_kebab_case</a></li>
<li><a href="#to_lower">to_lower</a></li>
<li><a href="#to_lower_camel_case">to_lower_camel_case</a></li>
<li><a href="#to_pascal_case">to_pascal_case</a></li>
<li><a href="#to_reader">to_reader</a></li>
<li><a href="#to_reader_at">to_reader_at</a></li>
<li><a href="#to_screaming_snake_case">to_screaming_snake_case</a></li>
<li><a href="#to_snake_case">to_snake_case</a></li>
<li><a href="#to_stream">to_stream</a></li>
<li><a href="#to_string">to_string</a></li>
<li><a href="#to_upper">to_upper</a></li>
<li><a href="#to_upper_camel_case">to_upper_camel_case</a></li>
<li><a href="#to_upper_kebab_case">to_upper_kebab_case</a></li>
<li><a href="#to_upper_snake_case">to_upper_snake_case</a></li>
<li><a href="#to_valid_utf8">to_valid_utf8</a></li>
<li><a href="#to_writer">to_writer</a></li>
<li><a href="#trim">trim</a></li>
<li><a href="#trim_left">trim_left</a></li>
<li><a href="#trim_left_null">trim_left_null</a></li>
<li><a href="#trim_left_proc">trim_left_proc</a></li>
<li><a href="#trim_left_proc_with_state">trim_left_proc_with_state</a></li>
<li><a href="#trim_left_space">trim_left_space</a></li>
<li><a href="#trim_null">trim_null</a></li>
<li><a href="#trim_prefix">trim_prefix</a></li>
<li><a href="#trim_right">trim_right</a></li>
<li><a href="#trim_right_null">trim_right_null</a></li>
<li><a href="#trim_right_proc">trim_right_proc</a></li>
<li><a href="#trim_right_proc_with_state">trim_right_proc_with_state</a></li>
<li><a href="#trim_right_space">trim_right_space</a></li>
<li><a href="#trim_space">trim_space</a></li>
<li><a href="#trim_suffix">trim_suffix</a></li>
<li><a href="#truncate_to_byte">truncate_to_byte</a></li>
<li><a href="#truncate_to_rune">truncate_to_rune</a></li>
<li><a href="#unsafe_string_to_cstring">unsafe_string_to_cstring</a></li>
<li><a href="#unsafe_to_cstring">unsafe_to_cstring</a></li>
<li><a href="#write_byte">write_byte</a></li>
<li><a href="#write_bytes">write_bytes</a></li>
<li><a href="#write_encoded_rune">write_encoded_rune</a></li>
<li><a href="#write_escaped_rune">write_escaped_rune</a></li>
<li><a href="#write_f16">write_f16</a></li>
<li><a href="#write_f32">write_f32</a></li>
<li><a href="#write_f64">write_f64</a></li>
<li><a href="#write_float">write_float</a></li>
<li><a href="#write_i64">write_i64</a></li>
<li><a href="#write_int">write_int</a></li>
<li><a href="#write_quoted_rune">write_quoted_rune</a></li>
<li><a href="#write_quoted_string">write_quoted_string</a></li>
<li><a href="#write_rune">write_rune</a></li>
<li><a href="#write_string">write_string</a></li>
<li><a href="#write_u64">write_u64</a></li>
<li><a href="#write_uint">write_uint</a></li>
</ul>
</li>
<li><a href="#pkg-Procedure Groups">Procedure Groups</a><ul>
<li><a href="#builder_init">builder_init</a></li>
<li><a href="#builder_make">builder_make</a></li>
<li><a href="#clone_from">clone_from</a></li>
</ul>
</li>
<li><a href="#pkg-source-files">Source Files</a></ul>
</nav>
</div></div>
<script type="text/javascript">var odin_pkg_name = "strings";</script>
</div>

</div>
</main>

<footer class="odin-footer">
	<div class="container pb-5 pt-5">
		<div class="row g-4">
		<div class="col">
		<a class="navbar-brand" href="https://odin-lang.org">
		<img class="mb-3" src="https://odin-lang.org/logo.svg" height="30" alt="Odin"></a>
		<p>
		The Data-Oriented Language for Sane Software Development.
		</p>
		</div>
		<nav class="col-md-auto">
			<h4 class="fw-normal">Resources</h4>
			<ul class="list-unstyled">
			<li><a href="https://odin-lang.org/docs" class="link-light">Docs</a></li>
			<li><a href="https://pkg.odin-lang.org/" class="link-light">Packages</a></li>
			<li><a href="https://odin-lang.org/news" class="link-light">News</a></li>
			</ul>
		</nav>
		<nav class="col-md-auto">
			<h4 class="fw-normal">Community</h4>
			<ul class="list-unstyled">
			<li><a href="https://github.com/odin-lang/Odin" target="_blank" class="link-light">GitHub</a></li>
			<li><a href="https://forum.odin-lang.org" target="_blank" class="link-light">Forum</a></li>
			<li><a href="https://discord.com/invite/sVBPHEv" target="_blank" class="link-light">Discord</a></li>
			<li><a href="https://www.twitch.tv/ginger_bill" target="_blank" class="link-light">Twitch</a></li>
			<li><a href="https://www.youtube.com/channel/UCUSck1dOH7VKmG4lRW7tZXg" target="_blank" class="link-light">YouTube</a></li>
			<li><a href="https://odin-lang.org/showcase" target="_blank" class="link-light">Showcase</a></li>
			</ul>
		</nav>
		<nav class="col-md-auto">
			<h4 class="fw-normal">Contribute</h4>
			<ul class="list-unstyled">
			<li><a href="https://github.com/odin-lang/Odin/issues" target="_blank" class="link-light">Issues</a></li>
			<li><a href="https://www.patreon.com/gingerbill" target="_blank" class="link-light">Donate</a></li>
			</ul>
			</nav>
		</div>
		<div class="mt-4 text-muted">© 2016–2023 Ginger Bill</div>
	</div>
</footer>

<script src="https://odin-lang.org/lib/bootstrap/js/bootstrap.min.js"></script>
<script src="https://odin-lang.org/js/script.js"></script>
<script src="/pkg-data.js"></script>
<script src="/search.js"></script>
</body>
</html>
