<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>package simd - pkg.odin-lang.org</title>	<link rel="icon" href="/favicon.svg">
	<link rel="stylesheet" type="text/css" href="https://odin-lang.org/scss/custom.min.css">
	<link rel=stylesheet href="//odin-lang.org/lib/highlight/styles/github-dark.min.css">
	<script src="//odin-lang.org/lib/highlight/highlight.min.js"></script>

	<script>hljs.registerLanguage("odin",function(a){return{aliases:["odin","odinlang","odin-lang"],keywords:{keyword:"auto_cast bit_set break case cast context continue defer distinct do dynamic else enum fallthrough for foreign if import in map not_in or_else or_return package proc return struct switch transmute type_of typeid union using when where",literal:"true false nil",built_in:"abs align_of cap clamp complex conj expand_to_tuple imag jmag kmag len max min offset_of quaternion real size_of soa_unzip soa_zip swizzle type_info_of type_of typeid_of"},illegal:"</",contains:[a.C_LINE_COMMENT_MODE,a.C_BLOCK_COMMENT_MODE,{className:"string",variants:[a.QUOTE_STRING_MODE,{begin:"'",end:"[^\\\\]'"},{begin:"`",end:"`"}]},{className:"number",variants:[{begin:a.C_NUMBER_RE+"[ijk]",relevance:1},a.C_NUMBER_MODE]}]}})</script>
	<script>hljs.highlightAll()</script>
	<script>
		function OSDarkModeQuery() {
			return window.matchMedia?.("(prefers-color-scheme: dark)");
		}
		function setDarkMode() {
			document.body.classList.add("dark-mode");
			window.localStorage.setItem("theme", "dark");
		}
		function removeDarkMode() {
			document.body.classList.remove("dark-mode");
			window.localStorage.setItem("theme", "light");
		}
		function toggleDarkMode() {
			if (document.body.classList.contains("dark-mode")) removeDarkMode()
			else setDarkMode()
		}
		function syncThemeToOS() {
			if (OSDarkModeQuery().matches) setDarkMode()
			else removeDarkMode()
		}
		document.addEventListener("DOMContentLoaded", () => {
			OSDarkModeQuery().addEventListener("change", syncThemeToOS);
		});
	</script>
	<link rel="stylesheet" type="text/css" href="https://odin-lang.org/css/style.css">

	<link rel="stylesheet" type="text/css" href="/style.css">

	</style>
</head>
<body>
<script>
	const themeSet = window.localStorage.getItem("theme");
	if (themeSet === null) {
		syncThemeToOS();
	} else if (themeSet === "dark") {
		setDarkMode();
	} else if (themeSet === "light") {
		removeDarkMode();
	}
</script>
<header class="sticky-top">
	<nav class="navbar navbar-expand-lg navbar-dark bg-primary odin-menu">
		<div class="container">
			<a class="navbar-brand" href="https://odin-lang.org/">
			<img src="https://odin-lang.org/logo.svg" height="30" alt="Odin"></a>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#odin-navbar-content" aria-controls="odin-navbar-content" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
			<div class="collapse navbar-collapse" id="odin-navbar-content">
			<ul class="navbar-nav ms-md-auto">
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/">Home</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/docs">Docs</a></li>
				<li class="nav-item"><a class="nav-link active" href="/">Packages</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/news">News</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/showcase">Showcase</a></li>
				<li class="nav-item"><a class="nav-link" href="https://forum.odin-lang.org">Forum</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/community">Community</a></li>
				<li class="nav-item"><a class="nav-link" href="https://github.com/odin-lang/Odin" target="_blank">GitHub</a></li>
				<li class="nav-item">
					<a
						class="nav-link btn-dark-mode"
						onclick="toggleDarkMode();"
						title="Toggle Light/Dark Mode"
					>
						<span class="dark-mode-appearance">Appearance:</span>
						<svg fill="white" id="dark-mode-icon" viewBox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"/></svg>
						<svg fill="white" id="light-mode-icon" viewBox="0 0 16 16">
						  <path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8M8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0m0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13m8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5M3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8m10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0m-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0m9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707M4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708"/>
						</svg>
					</button>
					</a>
				</li>
			</ul>
		</div>
		</div>
	</nav>
</header>
<main>
<div class="container full-width">
<div class="row odin-main my-4" id="pkg">
<nav id="pkg-sidebar" class="col-lg-2 odin-sidebar-border navbar-light sticky-top odin-below-navbar">
<div class="py-3">
<div>Current Package: <em><a href="/core/simd">simd</a></em></div><br>
<h4><a style="text-transform: capitalize; color: inherit;" href="/core">core Library</a></h4>
<ul>
<li class="nav-item"><a href="/core/bufio">bufio</a></li>
<li class="nav-item"><a href="/core/bytes">bytes</a></li>
<li class="nav-item"><a href="/core/c">c</a><ul>
<li><a href="/core/c/libc">libc</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/compress">compress</a><ul>
<li><a href="/core/compress/gzip">gzip</a></li>
<li><a href="/core/compress/shoco">shoco</a></li>
<li><a href="/core/compress/zlib">zlib</a></li>
</ul>

</li>
<li class="nav-item">container<ul>
<li><a href="/core/container/avl">avl</a></li>
<li><a href="/core/container/bit_array">bit_array</a></li>
<li><a href="/core/container/intrusive/list">intrusive/list</a></li>
<li><a href="/core/container/lru">lru</a></li>
<li><a href="/core/container/priority_queue">priority_queue</a></li>
<li><a href="/core/container/queue">queue</a></li>
<li><a href="/core/container/rbtree">rbtree</a></li>
<li><a href="/core/container/small_array">small_array</a></li>
<li><a href="/core/container/topological_sort">topological_sort</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/crypto">crypto</a><ul>
<li><a href="/core/crypto/aead">aead</a></li>
<li><a href="/core/crypto/aegis">aegis</a></li>
<li><a href="/core/crypto/aes">aes</a></li>
<li><a href="/core/crypto/blake2b">blake2b</a></li>
<li><a href="/core/crypto/blake2s">blake2s</a></li>
<li><a href="/core/crypto/chacha20">chacha20</a></li>
<li><a href="/core/crypto/chacha20poly1305">chacha20poly1305</a></li>
<li><a href="/core/crypto/deoxysii">deoxysii</a></li>
<li><a href="/core/crypto/ed25519">ed25519</a></li>
<li><a href="/core/crypto/hash">hash</a></li>
<li><a href="/core/crypto/hkdf">hkdf</a></li>
<li><a href="/core/crypto/hmac">hmac</a></li>
<li><a href="/core/crypto/kmac">kmac</a></li>
<li><a href="/core/crypto/legacy/keccak">legacy/keccak</a></li>
<li><a href="/core/crypto/legacy/md5">legacy/md5</a></li>
<li><a href="/core/crypto/legacy/sha1">legacy/sha1</a></li>
<li><a href="/core/crypto/pbkdf2">pbkdf2</a></li>
<li><a href="/core/crypto/poly1305">poly1305</a></li>
<li><a href="/core/crypto/ristretto255">ristretto255</a></li>
<li><a href="/core/crypto/sha2">sha2</a></li>
<li><a href="/core/crypto/sha3">sha3</a></li>
<li><a href="/core/crypto/shake">shake</a></li>
<li><a href="/core/crypto/sm3">sm3</a></li>
<li><a href="/core/crypto/tuplehash">tuplehash</a></li>
<li><a href="/core/crypto/x25519">x25519</a></li>
<li><a href="/core/crypto/x448">x448</a></li>
</ul>

</li>
<li class="nav-item">debug<ul>
<li><a href="/core/debug/pe">pe</a></li>
<li><a href="/core/debug/trace">trace</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/dynlib">dynlib</a></li>
<li class="nav-item">encoding<ul>
<li><a href="/core/encoding/base32">base32</a></li>
<li><a href="/core/encoding/base64">base64</a></li>
<li><a href="/core/encoding/cbor">cbor</a></li>
<li><a href="/core/encoding/csv">csv</a></li>
<li><a href="/core/encoding/endian">endian</a></li>
<li><a href="/core/encoding/entity">entity</a></li>
<li><a href="/core/encoding/hex">hex</a></li>
<li><a href="/core/encoding/hxa">hxa</a></li>
<li><a href="/core/encoding/ini">ini</a></li>
<li><a href="/core/encoding/json">json</a></li>
<li><a href="/core/encoding/uuid">uuid</a></li>
<li><a href="/core/encoding/uuid/legacy">uuid/legacy</a></li>
<li><a href="/core/encoding/varint">varint</a></li>
<li><a href="/core/encoding/xml">xml</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/flags">flags</a></li>
<li class="nav-item"><a href="/core/fmt">fmt</a></li>
<li class="nav-item"><a href="/core/hash">hash</a><ul>
<li><a href="/core/hash/xxhash">xxhash</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/image">image</a><ul>
<li><a href="/core/image/bmp">bmp</a></li>
<li><a href="/core/image/jpeg">jpeg</a></li>
<li><a href="/core/image/netpbm">netpbm</a></li>
<li><a href="/core/image/png">png</a></li>
<li><a href="/core/image/qoi">qoi</a></li>
<li><a href="/core/image/tga">tga</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/io">io</a></li>
<li class="nav-item"><a href="/core/log">log</a></li>
<li class="nav-item"><a href="/core/math">math</a><ul>
<li><a href="/core/math/big">big</a></li>
<li><a href="/core/math/bits">bits</a></li>
<li><a href="/core/math/cmplx">cmplx</a></li>
<li><a href="/core/math/ease">ease</a></li>
<li><a href="/core/math/fixed">fixed</a></li>
<li><a href="/core/math/linalg">linalg</a></li>
<li><a href="/core/math/linalg/glsl">linalg/glsl</a></li>
<li><a href="/core/math/linalg/hlsl">linalg/hlsl</a></li>
<li><a href="/core/math/noise">noise</a></li>
<li><a href="/core/math/rand">rand</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/mem">mem</a><ul>
<li><a href="/core/mem/tlsf">tlsf</a></li>
<li><a href="/core/mem/virtual">virtual</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/net">net</a></li>
<li class="nav-item">odin<ul>
<li><a href="/core/odin/ast">ast</a></li>
<li><a href="/core/odin/doc-format">doc-format</a></li>
<li><a href="/core/odin/parser">parser</a></li>
<li><a href="/core/odin/tokenizer">tokenizer</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/os">os</a></li>
<li class="nav-item">path<ul>
<li><a href="/core/path/filepath">filepath</a></li>
<li><a href="/core/path/slashpath">slashpath</a></li>
</ul>

</li>
<li class="nav-item">prof<ul>
<li><a href="/core/prof/spall">spall</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/reflect">reflect</a></li>
<li class="nav-item"><a href="/core/relative">relative</a></li>
<li class="nav-item"><a class="active" href="/core/simd">simd</a><ul>
<li><a href="/core/simd/x86">x86</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/slice">slice</a><ul>
<li><a href="/core/slice/heap">heap</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/sort">sort</a></li>
<li class="nav-item"><a href="/core/strconv">strconv</a><ul>
<li><a href="/core/strconv/decimal">decimal</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/strings">strings</a></li>
<li class="nav-item"><a href="/core/sync">sync</a><ul>
<li><a href="/core/sync/chan">chan</a></li>
</ul>

</li>
<li class="nav-item">sys<ul>
<li><a href="/core/sys/darwin">darwin</a></li>
<li><a href="/core/sys/darwin/CoreFoundation">darwin/CoreFoundation</a></li>
<li><a href="/core/sys/darwin/Foundation">darwin/Foundation</a></li>
<li><a href="/core/sys/darwin/Security">darwin/Security</a></li>
<li><a href="/core/sys/freebsd">freebsd</a></li>
<li><a href="/core/sys/haiku">haiku</a></li>
<li><a href="/core/sys/info">info</a></li>
<li><a href="/core/sys/kqueue">kqueue</a></li>
<li><a href="/core/sys/linux">linux</a></li>
<li><a href="/core/sys/orca">orca</a></li>
<li><a href="/core/sys/posix">posix</a></li>
<li><a href="/core/sys/unix">unix</a></li>
<li><a href="/core/sys/valgrind">valgrind</a></li>
<li><a href="/core/sys/windows">windows</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/terminal">terminal</a><ul>
<li><a href="/core/terminal/ansi">ansi</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/testing">testing</a></li>
<li class="nav-item">text<ul>
<li><a href="/core/text/edit">edit</a></li>
<li><a href="/core/text/i18n">i18n</a></li>
<li><a href="/core/text/match">match</a></li>
<li><a href="/core/text/regex">regex</a></li>
<li><a href="/core/text/regex/common">regex/common</a></li>
<li><a href="/core/text/regex/compiler">regex/compiler</a></li>
<li><a href="/core/text/regex/optimizer">regex/optimizer</a></li>
<li><a href="/core/text/regex/parser">regex/parser</a></li>
<li><a href="/core/text/regex/tokenizer">regex/tokenizer</a></li>
<li><a href="/core/text/regex/virtual_machine">regex/virtual_machine</a></li>
<li><a href="/core/text/scanner">scanner</a></li>
<li><a href="/core/text/table">table</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/thread">thread</a></li>
<li class="nav-item"><a href="/core/time">time</a><ul>
<li><a href="/core/time/datetime">datetime</a></li>
<li><a href="/core/time/timezone">timezone</a></li>
</ul>

</li>
<li class="nav-item"><a href="/core/unicode">unicode</a><ul>
<li><a href="/core/unicode/utf16">utf16</a></li>
<li><a href="/core/unicode/utf8">utf8</a></li>
<li><a href="/core/unicode/utf8/utf8string">utf8/utf8string</a></li>
</ul>

</li>
</ul>
</div>
</nav>
<article class="col-lg-8 p-4 documentation odin-article">
<nav class="pkg-breadcrumb" aria-label="breadcrumb">
<ol class="breadcrumb">
<li class="breadcrumb-item"><a href="/core">core</a></li>
<li class="breadcrumb-item active" aria-current="page"><a href="/core/simd">simd</a></li>
</ol>
</nav>
<h1>package core:simd<div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd"><em>Source</em></a></div></h1>

		<div class="odin-search-wrapper">
			<input type="search" id="odin-search" class="odin-search-package" autocomplete="off" spellcheck="false" placeholder="Fuzzy Search...">
			<div class="odin-search-shortcut">
				<div class="odin-search-key key-macos">⌘K</div>
				<div class="odin-search-key key-windows">Ctrl+K</div>
				<span class="odin-search-or">or</span>
				<div class="odin-search-key">/</div>
			</div>
		</div>
	
<div id="odin-search-info">
<div id="odin-search-time"></div>

		<div id="odin-search-options">
			<input type="checkbox" id="odin-search-filter" name="odin-search-filter">
			<label for="odin-search-filter">Filter Results</label>
		</div>
</div>
<ul id="odin-search-results"></ul>
<div id="pkg-top">
<h2>Overview</h2>
<div id="pkg-overview">
<p>Cross-platform <code>SIMD</code> support types and procedures.</p>
<p>SIMD (Single Instruction Multiple Data), is a CPU hardware feature that
introduce special registers and instructions which operate on multiple units
of data at the same time, which enables faster data processing for
applications with heavy computational workloads.</p>
<p>In Odin SIMD is exposed via a special kinds of arrays, called the *SIMD
vectors*. The types of SIMD vectors is written as <code>#simd [N]T</code>, where N is a
power of two, and T could be any basic type (integers, floats, etc.). The
documentation of this package will call <i>SIMD vectors</i> just <i>vectors</i>.</p>
<p>SIMD vectors consist of elements, called <i>scalar values</i>, or
<i>scalars</i>, each occupying a <i>lane</i> of the SIMD vector. In the type declaration,
<code>N</code> specifies the amount of lanes, or values, that a vector stores.</p>
<p>This package implements procedures for working with vectors.</p>
</div>
<div id="pkg-index">
<h2>Index</h2>
<div>
<details class="doc-index" id="doc-index-Types" aria-labelledby="#doc-index-Types-header">
<summary id="#doc-index-Types-header">
Types (45)</summary>
<ul>
<li><a href="#b16x16">b16x16</a></li>
<li><a href="#b16x32">b16x32</a></li>
<li><a href="#b16x8">b16x8</a></li>
<li><a href="#b32x16">b32x16</a></li>
<li><a href="#b32x4">b32x4</a></li>
<li><a href="#b32x8">b32x8</a></li>
<li><a href="#b64x2">b64x2</a></li>
<li><a href="#b64x4">b64x4</a></li>
<li><a href="#b64x8">b64x8</a></li>
<li><a href="#b8x16">b8x16</a></li>
<li><a href="#b8x32">b8x32</a></li>
<li><a href="#b8x64">b8x64</a></li>
<li><a href="#boolx16">boolx16</a></li>
<li><a href="#boolx32">boolx32</a></li>
<li><a href="#boolx64">boolx64</a></li>
<li><a href="#f32x16">f32x16</a></li>
<li><a href="#f32x4">f32x4</a></li>
<li><a href="#f32x8">f32x8</a></li>
<li><a href="#f64x2">f64x2</a></li>
<li><a href="#f64x4">f64x4</a></li>
<li><a href="#f64x8">f64x8</a></li>
<li><a href="#i16x16">i16x16</a></li>
<li><a href="#i16x32">i16x32</a></li>
<li><a href="#i16x8">i16x8</a></li>
<li><a href="#i32x16">i32x16</a></li>
<li><a href="#i32x4">i32x4</a></li>
<li><a href="#i32x8">i32x8</a></li>
<li><a href="#i64x2">i64x2</a></li>
<li><a href="#i64x4">i64x4</a></li>
<li><a href="#i64x8">i64x8</a></li>
<li><a href="#i8x16">i8x16</a></li>
<li><a href="#i8x32">i8x32</a></li>
<li><a href="#i8x64">i8x64</a></li>
<li><a href="#u16x16">u16x16</a></li>
<li><a href="#u16x32">u16x32</a></li>
<li><a href="#u16x8">u16x8</a></li>
<li><a href="#u32x16">u32x16</a></li>
<li><a href="#u32x4">u32x4</a></li>
<li><a href="#u32x8">u32x8</a></li>
<li><a href="#u64x2">u64x2</a></li>
<li><a href="#u64x4">u64x4</a></li>
<li><a href="#u64x8">u64x8</a></li>
<li><a href="#u8x16">u8x16</a></li>
<li><a href="#u8x32">u8x32</a></li>
<li><a href="#u8x64">u8x64</a></li>
</ul>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Constants" aria-labelledby="#doc-index-Constants-header">
<summary id="#doc-index-Constants-header">
Constants (1)</summary>
<ul>
<li><a href="#HAS_HARDWARE_SIMD">HAS_HARDWARE_SIMD</a></li>
</ul>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Variables" aria-labelledby="#doc-index-Variables-header">
<summary id="#doc-index-Variables-header">
Variables (0)</summary>
<p class="pkg-empty-section">This section is empty.</p>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Procedures" aria-labelledby="#doc-index-Procedures-header">
<summary id="#doc-index-Procedures-header">
Procedures (77)</summary>
<ul>
<li><a href="#abs">abs</a></li>
<li><a href="#add">add</a></li>
<li><a href="#bit_and">bit_and</a></li>
<li><a href="#bit_and_not">bit_and_not</a></li>
<li><a href="#bit_not">bit_not</a></li>
<li><a href="#bit_or">bit_or</a></li>
<li><a href="#bit_xor">bit_xor</a></li>
<li><a href="#ceil">ceil</a></li>
<li><a href="#clamp">clamp</a></li>
<li><a href="#copysign">copysign</a></li>
<li><a href="#count_leading_zeros">count_leading_zeros</a></li>
<li><a href="#count_ones">count_ones</a></li>
<li><a href="#count_trailing_zeros">count_trailing_zeros</a></li>
<li><a href="#count_zeros">count_zeros</a></li>
<li><a href="#div">div</a></li>
<li><a href="#extract">extract</a></li>
<li><a href="#extract_lsbs">extract_lsbs</a></li>
<li><a href="#extract_msbs">extract_msbs</a></li>
<li><a href="#floor">floor</a></li>
<li><a href="#fma">fma</a></li>
<li><a href="#from_array">from_array</a></li>
<li><a href="#from_slice">from_slice</a></li>
<li><a href="#fused_mul_add">fused_mul_add</a></li>
<li><a href="#gather">gather</a></li>
<li><a href="#indices">indices</a></li>
<li><a href="#lanes_eq">lanes_eq</a></li>
<li><a href="#lanes_ge">lanes_ge</a></li>
<li><a href="#lanes_gt">lanes_gt</a></li>
<li><a href="#lanes_le">lanes_le</a></li>
<li><a href="#lanes_lt">lanes_lt</a></li>
<li><a href="#lanes_ne">lanes_ne</a></li>
<li><a href="#lanes_reverse">lanes_reverse</a></li>
<li><a href="#lanes_rotate_left">lanes_rotate_left</a></li>
<li><a href="#lanes_rotate_right">lanes_rotate_right</a></li>
<li><a href="#masked_compress_store">masked_compress_store</a></li>
<li><a href="#masked_expand_load">masked_expand_load</a></li>
<li><a href="#masked_load">masked_load</a></li>
<li><a href="#masked_store">masked_store</a></li>
<li><a href="#max">max</a></li>
<li><a href="#min">min</a></li>
<li><a href="#mul">mul</a></li>
<li><a href="#nearest">nearest</a></li>
<li><a href="#neg">neg</a></li>
<li><a href="#recip">recip</a></li>
<li><a href="#reduce_add_bisect">reduce_add_bisect</a></li>
<li><a href="#reduce_add_ordered">reduce_add_ordered</a></li>
<li><a href="#reduce_add_pairs">reduce_add_pairs</a></li>
<li><a href="#reduce_all">reduce_all</a></li>
<li><a href="#reduce_and">reduce_and</a></li>
<li><a href="#reduce_any">reduce_any</a></li>
<li><a href="#reduce_max">reduce_max</a></li>
<li><a href="#reduce_min">reduce_min</a></li>
<li><a href="#reduce_mul_bisect">reduce_mul_bisect</a></li>
<li><a href="#reduce_mul_ordered">reduce_mul_ordered</a></li>
<li><a href="#reduce_mul_pairs">reduce_mul_pairs</a></li>
<li><a href="#reduce_or">reduce_or</a></li>
<li><a href="#reduce_xor">reduce_xor</a></li>
<li><a href="#replace">replace</a></li>
<li><a href="#reverse_bits">reverse_bits</a></li>
<li><a href="#runtime_swizzle">runtime_swizzle</a></li>
<li><a href="#saturating_add">saturating_add</a></li>
<li><a href="#saturating_sub">saturating_sub</a></li>
<li><a href="#scatter">scatter</a></li>
<li><a href="#select">select</a></li>
<li><a href="#shl">shl</a></li>
<li><a href="#shl_masked">shl_masked</a></li>
<li><a href="#shr">shr</a></li>
<li><a href="#shr_masked">shr_masked</a></li>
<li><a href="#shuffle">shuffle</a></li>
<li><a href="#signum">signum</a></li>
<li><a href="#sqrt">sqrt</a></li>
<li><a href="#sub">sub</a></li>
<li><a href="#swizzle">swizzle</a></li>
<li><a href="#to_array">to_array</a></li>
<li><a href="#to_array_ptr">to_array_ptr</a></li>
<li><a href="#to_bits">to_bits</a></li>
<li><a href="#trunc">trunc</a></li>
</ul>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Procedure Groups" aria-labelledby="#doc-index-Procedure Groups-header">
<summary id="#doc-index-Procedure Groups-header">
Procedure Groups (0)</summary>
<p class="pkg-empty-section">This section is empty.</p>
</details>
</div>
</div>
</div>
<section class="documentation">
<h2 id="pkg-Types" class="pkg-header">Types</h2>
<div class="pkg-entity">
<h3 id="b16x16"><span><a class="doc-id-link" href="#b16x16">b16x16<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L174"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">b16x16 :: <span class="directive">#simd</span>[16]<a href="/base/builtin#b16"><span class="doc-builtin">b16</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 16 <code>b16</code> lanes (256 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="b16x32"><span><a class="doc-id-link" href="#b16x32">b16x32<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L249"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">b16x32 :: <span class="directive">#simd</span>[32]<a href="/base/builtin#b16"><span class="doc-builtin">b16</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 32 <code>b16</code> lanes (512 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="b16x8"><span><a class="doc-id-link" href="#b16x8">b16x8<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L99"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">b16x8 :: <span class="directive">#simd</span>[8]<a href="/base/builtin#b16"><span class="doc-builtin">b16</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 8 <code>b16</code> lanes (128 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="b32x16"><span><a class="doc-id-link" href="#b32x16">b32x16<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L254"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">b32x16 :: <span class="directive">#simd</span>[16]<a href="/base/builtin#b32"><span class="doc-builtin">b32</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 16 <code>b32</code> lanes (512 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="b32x4"><span><a class="doc-id-link" href="#b32x4">b32x4<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L104"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">b32x4 :: <span class="directive">#simd</span>[4]<a href="/base/builtin#b32"><span class="doc-builtin">b32</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 4 <code>b32</code> lanes (128 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="b32x8"><span><a class="doc-id-link" href="#b32x8">b32x8<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L179"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">b32x8 :: <span class="directive">#simd</span>[8]<a href="/base/builtin#b32"><span class="doc-builtin">b32</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 8 <code>b32</code> lanes (256 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="b64x2"><span><a class="doc-id-link" href="#b64x2">b64x2<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L109"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">b64x2 :: <span class="directive">#simd</span>[2]<a href="/base/builtin#b64"><span class="doc-builtin">b64</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 2 <code>b64</code> lanes (128 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="b64x4"><span><a class="doc-id-link" href="#b64x4">b64x4<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L184"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">b64x4 :: <span class="directive">#simd</span>[4]<a href="/base/builtin#b64"><span class="doc-builtin">b64</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 4 <code>b64</code> lanes (256 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="b64x8"><span><a class="doc-id-link" href="#b64x8">b64x8<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L259"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">b64x8 :: <span class="directive">#simd</span>[8]<a href="/base/builtin#b64"><span class="doc-builtin">b64</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 8 <code>b64</code> lanes (512 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="b8x16"><span><a class="doc-id-link" href="#b8x16">b8x16<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L94"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">b8x16 :: <span class="directive">#simd</span>[16]<a href="/base/builtin#b8"><span class="doc-builtin">b8</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 16 <code>b8</code> lanes (128 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="b8x32"><span><a class="doc-id-link" href="#b8x32">b8x32<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L169"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">b8x32 :: <span class="directive">#simd</span>[32]<a href="/base/builtin#b8"><span class="doc-builtin">b8</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 32 <code>b8</code> lanes (256 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="b8x64"><span><a class="doc-id-link" href="#b8x64">b8x64<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L244"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">b8x64 :: <span class="directive">#simd</span>[64]<a href="/base/builtin#b8"><span class="doc-builtin">b8</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 64 <code>b8</code> lanes (512 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="boolx16"><span><a class="doc-id-link" href="#boolx16">boolx16<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L89"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">boolx16 :: <span class="directive">#simd</span>[16]<a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 16 <code>bool</code> lanes (128 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="boolx32"><span><a class="doc-id-link" href="#boolx32">boolx32<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L164"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">boolx32 :: <span class="directive">#simd</span>[32]<a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 32 <code>bool</code> lanes (256 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="boolx64"><span><a class="doc-id-link" href="#boolx64">boolx64<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L239"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">boolx64 :: <span class="directive">#simd</span>[64]<a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 64 <code>bool</code> lanes (512 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="f32x16"><span><a class="doc-id-link" href="#f32x16">f32x16<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L229"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">f32x16 :: <span class="directive">#simd</span>[16]<a href="/base/builtin#f32"><span class="doc-builtin">f32</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 16 <code>f32</code> lanes (512 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="f32x4"><span><a class="doc-id-link" href="#f32x4">f32x4<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L79"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">f32x4 :: <span class="directive">#simd</span>[4]<a href="/base/builtin#f32"><span class="doc-builtin">f32</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 4 <code>f32</code> lanes (128 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="f32x8"><span><a class="doc-id-link" href="#f32x8">f32x8<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L154"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">f32x8 :: <span class="directive">#simd</span>[8]<a href="/base/builtin#f32"><span class="doc-builtin">f32</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 8 <code>f32</code> lanes (256 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="f64x2"><span><a class="doc-id-link" href="#f64x2">f64x2<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L84"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">f64x2 :: <span class="directive">#simd</span>[2]<a href="/base/builtin#f64"><span class="doc-builtin">f64</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 2 <code>f64</code> lanes (128 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="f64x4"><span><a class="doc-id-link" href="#f64x4">f64x4<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L159"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">f64x4 :: <span class="directive">#simd</span>[4]<a href="/base/builtin#f64"><span class="doc-builtin">f64</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 4 <code>f64</code> lanes (256 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="f64x8"><span><a class="doc-id-link" href="#f64x8">f64x8<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L234"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">f64x8 :: <span class="directive">#simd</span>[8]<a href="/base/builtin#f64"><span class="doc-builtin">f64</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 8 <code>f64</code> lanes (512 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="i16x16"><span><a class="doc-id-link" href="#i16x16">i16x16<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L129"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">i16x16 :: <span class="directive">#simd</span>[16]<a href="/base/builtin#i16"><span class="doc-builtin">i16</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 16 <code>i16</code> lanes (256 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="i16x32"><span><a class="doc-id-link" href="#i16x32">i16x32<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L204"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">i16x32 :: <span class="directive">#simd</span>[32]<a href="/base/builtin#i16"><span class="doc-builtin">i16</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 32 <code>i16</code> lanes (512 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="i16x8"><span><a class="doc-id-link" href="#i16x8">i16x8<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L54"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">i16x8 :: <span class="directive">#simd</span>[8]<a href="/base/builtin#i16"><span class="doc-builtin">i16</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 8 <code>i16</code> lanes (128 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="i32x16"><span><a class="doc-id-link" href="#i32x16">i32x16<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L214"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">i32x16 :: <span class="directive">#simd</span>[16]<a href="/base/builtin#i32"><span class="doc-builtin">i32</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 16 <code>i32</code> lanes (512 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="i32x4"><span><a class="doc-id-link" href="#i32x4">i32x4<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L64"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">i32x4 :: <span class="directive">#simd</span>[4]<a href="/base/builtin#i32"><span class="doc-builtin">i32</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 4 <code>i32</code> lanes (128 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="i32x8"><span><a class="doc-id-link" href="#i32x8">i32x8<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L139"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">i32x8 :: <span class="directive">#simd</span>[8]<a href="/base/builtin#i32"><span class="doc-builtin">i32</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 8 <code>i32</code> lanes (256 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="i64x2"><span><a class="doc-id-link" href="#i64x2">i64x2<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L74"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">i64x2 :: <span class="directive">#simd</span>[2]<a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 2 <code>i64</code> lanes (128 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="i64x4"><span><a class="doc-id-link" href="#i64x4">i64x4<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L149"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">i64x4 :: <span class="directive">#simd</span>[4]<a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 4 <code>i64</code> lanes (256 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="i64x8"><span><a class="doc-id-link" href="#i64x8">i64x8<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L224"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">i64x8 :: <span class="directive">#simd</span>[8]<a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 8 <code>i64</code> lanes (512 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="i8x16"><span><a class="doc-id-link" href="#i8x16">i8x16<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L44"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">i8x16 :: <span class="directive">#simd</span>[16]<a href="/base/builtin#i8"><span class="doc-builtin">i8</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 16 <code>i8</code> lanes (128 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="i8x32"><span><a class="doc-id-link" href="#i8x32">i8x32<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L119"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">i8x32 :: <span class="directive">#simd</span>[32]<a href="/base/builtin#i8"><span class="doc-builtin">i8</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 32 <code>i8</code> lanes (256 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="i8x64"><span><a class="doc-id-link" href="#i8x64">i8x64<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L194"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">i8x64 :: <span class="directive">#simd</span>[64]<a href="/base/builtin#i8"><span class="doc-builtin">i8</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 64 <code>i8</code> lanes (512 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="u16x16"><span><a class="doc-id-link" href="#u16x16">u16x16<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L124"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">u16x16 :: <span class="directive">#simd</span>[16]<a href="/base/builtin#u16"><span class="doc-builtin">u16</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 16 <code>u16</code> lanes (256 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="u16x32"><span><a class="doc-id-link" href="#u16x32">u16x32<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L199"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">u16x32 :: <span class="directive">#simd</span>[32]<a href="/base/builtin#u16"><span class="doc-builtin">u16</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 32 <code>u16</code> lanes (512 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="u16x8"><span><a class="doc-id-link" href="#u16x8">u16x8<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L49"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">u16x8 :: <span class="directive">#simd</span>[8]<a href="/base/builtin#u16"><span class="doc-builtin">u16</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 8 <code>u16</code> lanes (128 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="u32x16"><span><a class="doc-id-link" href="#u32x16">u32x16<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L209"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">u32x16 :: <span class="directive">#simd</span>[16]<a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 16 <code>u32</code> lanes (512 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="u32x4"><span><a class="doc-id-link" href="#u32x4">u32x4<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L59"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">u32x4 :: <span class="directive">#simd</span>[4]<a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 4 <code>u32</code> lanes (128 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="u32x8"><span><a class="doc-id-link" href="#u32x8">u32x8<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L134"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">u32x8 :: <span class="directive">#simd</span>[8]<a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 8 <code>u32</code> lanes (256 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="u64x2"><span><a class="doc-id-link" href="#u64x2">u64x2<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L69"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">u64x2 :: <span class="directive">#simd</span>[2]<a href="/base/builtin#u64"><span class="doc-builtin">u64</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 2 <code>u64</code> lanes (128 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="u64x4"><span><a class="doc-id-link" href="#u64x4">u64x4<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L144"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">u64x4 :: <span class="directive">#simd</span>[4]<a href="/base/builtin#u64"><span class="doc-builtin">u64</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 4 <code>u64</code> lanes (256 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="u64x8"><span><a class="doc-id-link" href="#u64x8">u64x8<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L219"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">u64x8 :: <span class="directive">#simd</span>[8]<a href="/base/builtin#u64"><span class="doc-builtin">u64</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 8 <code>u64</code> lanes (512 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="u8x16"><span><a class="doc-id-link" href="#u8x16">u8x16<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L39"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">u8x16 :: <span class="directive">#simd</span>[16]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 16 <code>u8</code> lanes (128 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="u8x32"><span><a class="doc-id-link" href="#u8x32">u8x32<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L114"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">u8x32 :: <span class="directive">#simd</span>[32]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 32 <code>u8</code> lanes (256 bits).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="u8x64"><span><a class="doc-id-link" href="#u8x64">u8x64<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L189"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">u8x64 :: <span class="directive">#simd</span>[64]<a href="/base/builtin#u8"><span class="doc-builtin">u8</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Vector of 64 <code>u8</code> lanes (512 bits).</p>
</details>
</div>
<h2 id="pkg-Constants" class="pkg-header">Constants</h2>
<div class="pkg-entity">
<h3 id="HAS_HARDWARE_SIMD"><span><a class="doc-id-link" href="#HAS_HARDWARE_SIMD">HAS_HARDWARE_SIMD<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L34"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">HAS_HARDWARE_SIMD: <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> : runtime.HAS_HARDWARE_SIMD</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Check if SIMD is software-emulated on a target platform.</p>
<p>This value is <code>true</code>, when the compile-time target has the hardware support for
at least 128-bit (or wider) SIMD. If the compile-time target lacks the hardware support
for 128-bit SIMD, this value is <code>false</code>, and all SIMD operations will likely be
emulated.</p>
</details>
</div>
<h2 id="pkg-Variables" class="pkg-header">Variables</h2>
<p class="pkg-empty-section">This section is empty.</p>
<h2 id="pkg-Procedures" class="pkg-header">Procedures</h2>
<div class="pkg-entity">
<h3 id="abs"><span><a class="doc-id-link" href="#abs">abs<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">abs :: <a href="/base/intrinsics#simd_abs">intrinsics</a>.simd_abs</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Absolute value of a SIMD vector.</p>
<p>This procedure returns a vector where each lane has the absolute value of the
corresponding lane in the vector <code>a</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer or a float vector to negate</span></p>
<p><b>Returns:</b><br><span class="doc-list">The absolute value of a vector.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	switch {
		case a[i] &lt; 0:  res[i] = -a[i]
		case a[i] &gt; 0:  res[i] = a[i]
		case a[i] == 0: res[i] = 0
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +------+------+------+------+
a: |   0  |  -1  |   2  |  -3  |
   +------+------+------+------+
res:
   +------+------+------+------+
   |   0  |   1  |   2  |   3  |
   +------+------+------+------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="add"><span><a class="doc-id-link" href="#add">add<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">add :: <a href="/base/intrinsics#simd_add">intrinsics</a>.simd_add</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Add SIMD vectors.</p>
<p>This procedure returns a vector, where each lane holds the sum of the
corresponding <code>a</code> and <code>b</code> vectors' lanes.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer or a float vector.</span>
<span class="doc-list"><code>b</code>: An integer or a float vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector that is the sum of two input vectors.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	res[i] = a[i] + b[i]
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +-----+-----+-----+-----+
a: |  0  |  1  |  2  |  3  |
   +-----+-----+-----+-----+
   +-----+-----+-----+-----+
b: |  0  |  1  |  2  | -1  |
   +-----+-----+-----+-----+
res:
   +-----+-----+-----+-----+
   |  0  |  2  |  4  |  2  |
   +-----+-----+-----+-----+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="bit_and"><span><a class="doc-id-link" href="#bit_and">bit_and<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">bit_and :: <a href="/base/intrinsics#simd_bit_and">intrinsics</a>.simd_bit_and</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Bitwise AND of vectors.</p>
<p>This procedure returns a vector, such that each lane has the result of a bitwise
AND operation between the corresponding lanes of the vectors <code>a</code> and <code>b</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer or a boolean vector.</span>
<span class="doc-list"><code>b</code>: An integer or a boolean vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector that is the result of the bitwise AND operation between two vectors.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	res[i] = a[i] & b[i]
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +------+------+------+------+
a: | 0x11 | 0x33 | 0x55 | 0xaa |
   +------+------+------+------+
   +------+------+------+------+
b: | 0xff | 0xf0 | 0x0f | 0x00 |
   +------+------+------+------+
res:
   +------+------+------+------+
   | 0x11 | 0x30 | 0x05 | 0x00 |
   +------+------+------+------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="bit_and_not"><span><a class="doc-id-link" href="#bit_and_not">bit_and_not<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">bit_and_not :: <a href="/base/intrinsics#simd_bit_and_not">intrinsics</a>.simd_bit_and_not</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Bitwise AND NOT of vectors.</p>
<p>This procedure returns a vector, such that each lane has the result of a bitwise
AND NOT operation between the corresponding lanes of the vectors <code>a</code> and <code>b</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer or a boolean vector.</span>
<span class="doc-list"><code>b</code>: An integer or a boolean vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector that is the result of the bitwise AND NOT operation between two vectors.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	res[i] = a[i] &~ b[i]
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +------+------+------+------+
a: | 0x11 | 0x33 | 0x55 | 0xaa |
   +------+------+------+------+
   +------+------+------+------+
b: | 0xff | 0xf0 | 0x0f | 0x00 |
   +------+------+------+------+
res:
   +------+------+------+------+
   | 0x00 | 0x03 | 0x50 | 0xaa |
   +------+------+------+------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="bit_not"><span><a class="doc-id-link" href="#bit_not">bit_not<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L2692"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">bit_not :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (v: <span class="directive">#simd</span>[0]$E) -> <span class="directive">#simd</span>[0]$E {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Perform binary not operation on a SIMD vector.</p>
<p>This procedure returns a vector where each lane is the result of the binary
NOT operation of the corresponding lane in the vector <code>a</code>.</p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	res[i] = ~a[i]
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +------+------+------+------+
a: | 0x00 | 0x50 | 0x80 | 0xff |
   +------+------+------+------+
res:
   +------+------+------+------+
   | 0xff | 0xaf | 0x7f | 0x00 |
   +------+------+------+------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="bit_or"><span><a class="doc-id-link" href="#bit_or">bit_or<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">bit_or :: <a href="/base/intrinsics#simd_bit_or">intrinsics</a>.simd_bit_or</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Bitwise OR of vectors.</p>
<p>This procedure returns a vector, such that each lane has the result of a bitwise
OR operation between the corresponding lanes of the vectors <code>a</code> and <code>b</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer or a boolean vector.</span>
<span class="doc-list"><code>b</code>: An integer or a boolean vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector that is the result of the bitwise OR operation between two vectors.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	res[i] = a[i] | b[i]
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +------+------+------+------+
a: | 0x11 | 0x33 | 0x55 | 0xaa |
   +------+------+------+------+
   +------+------+------+------+
b: | 0xff | 0xf0 | 0x0f | 0x00 |
   +------+------+------+------+
res:
   +------+------+------+------+
   | 0xff | 0xf3 | 0x5f | 0xaa |
   +------+------+------+------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="bit_xor"><span><a class="doc-id-link" href="#bit_xor">bit_xor<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">bit_xor :: <a href="/base/intrinsics#simd_bit_xor">intrinsics</a>.simd_bit_xor</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Bitwise XOR of vectors.</p>
<p>This procedure returns a vector, such that each lane has the result of a bitwise
XOR operation between the corresponding lanes of the vectors <code>a</code> and <code>b</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer or a boolean vector.</span>
<span class="doc-list"><code>b</code>: An integer or a boolean vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector that is the result of the bitwise XOR operation between two vectors.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	res[i] = a[i] ~ b[i]
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +------+------+------+------+
a: | 0x11 | 0x33 | 0x55 | 0xaa |
   +------+------+------+------+
   +------+------+------+------+
b: | 0xff | 0xf0 | 0x0f | 0x00 |
   +------+------+------+------+
res:
   +------+------+------+------+
   | 0xee | 0xc3 | 0x5a | 0xaa |
   +------+------+------+------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="ceil"><span><a class="doc-id-link" href="#ceil">ceil<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">ceil :: <a href="/base/intrinsics#simd_ceil">intrinsics</a>.simd_ceil</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Ceil each lane in a SIMD vector.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="clamp"><span><a class="doc-id-link" href="#clamp">clamp<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">clamp :: <a href="/base/intrinsics#simd_clamp">intrinsics</a>.simd_clamp</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Clamp lanes of vector.</p>
<p>This procedure returns a vector, where each lane is the result of the
clamping of the lane from the vector <code>v</code> between the values in the corresponding
lanes of vectors <code>min</code> and <code>max</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>v</code>: An integer or a float vector with values to be clamped.</span>
<span class="doc-list"><code>min</code>: An integer or a float vector with minimum bounds.</span>
<span class="doc-list"><code>max</code>: An integer or a float vectoe with maximum bounds.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector containing clamped values in each lane.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	val := v[i]
	switch {
		case val &lt; min: val = min
		case val &gt; max: val = max
	}
	res[i] = val
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">     +-------+-------+-------+-------+
v:   |  -1   |  0.3  |  1.2  |   1   |
     +-------+-------+-------+-------+
     +-------+-------+-------+-------+
min: |   0   |   0   |   0   |   0   |
     +-------+-------+-------+-------+
     +-------+-------+-------+-------+
max: |   1   |   1   |   1   |   1   |
     +-------+-------+-------+-------+
res:
     +-------+-------+-------+-------+
     |   0   |  0.3  |   1   |   1   |
     +-------+-------+-------+-------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="copysign"><span><a class="doc-id-link" href="#copysign">copysign<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L2699"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">copysign :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (v, sign: <span class="directive">#simd</span>[0]$E) -> <span class="directive">#simd</span>[0]$E {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Copy the signs from lanes of one SIMD vector into another SIMD vector.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="count_leading_zeros"><span><a class="doc-id-link" href="#count_leading_zeros">count_leading_zeros<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">count_leading_zeros :: <a href="/base/intrinsics#count_leading_zeros">intrinsics</a>.count_leading_zeros</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Count the number of leading unset bits in each lane of a SIMD vector.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="count_ones"><span><a class="doc-id-link" href="#count_ones">count_ones<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">count_ones :: <a href="/base/intrinsics#count_ones">intrinsics</a>.count_ones</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Count the number of set bits in each lane of a SIMD vector.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="count_trailing_zeros"><span><a class="doc-id-link" href="#count_trailing_zeros">count_trailing_zeros<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">count_trailing_zeros :: <a href="/base/intrinsics#count_trailing_zeros">intrinsics</a>.count_trailing_zeros</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Count the number of trailing unset bits in each lane of a SIMD vector.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="count_zeros"><span><a class="doc-id-link" href="#count_zeros">count_zeros<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">count_zeros :: <a href="/base/intrinsics#count_zeros">intrinsics</a>.count_zeros</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Count the number of unset bits in each lane of a SIMD vector.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="div"><span><a class="doc-id-link" href="#div">div<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">div :: <a href="/base/intrinsics#simd_div">intrinsics</a>.simd_div</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Divide SIMD vectors.</p>
<p>This procedure returns a vector, where each lane holds the quotient (result
of division) between the corresponding lanes of the vectors <code>a</code> and <code>b</code>. Each
lane of the vector <code>a</code> is divided by the corresponding lane of the vector <code>b</code>.</p>
<p>This operation performs a standard floating-point division for each lane.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: A float vector.</span>
<span class="doc-list"><code>b</code>: A float vector to divide by.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector that is the quotient of two vectors, <code>a</code> / <code>b</code>.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	res[i] = a[i] / b[i]
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +-----+-----+-----+-----+
a: |  2  |  2  |  2  |  2  |
   +-----+-----+-----+-----+
   +-----+-----+-----+-----+
b: |  0  | -1  |  2  | -3  |
   +-----+-----+-----+-----+
res:
   +-----+-----+-----+------+
   | +∞  | -2  |  1  | -2/3 |
   +-----+-----+-----+------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="extract"><span><a class="doc-id-link" href="#extract">extract<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">extract :: <a href="/base/intrinsics#simd_extract">intrinsics</a>.simd_extract</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Extract scalar from a vector's lane.</p>
<p>This procedure returns the scalar from the lane at the specified index of the
vector.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: The vector to extract from.</span>
<span class="doc-list"><code>idx</code>: The lane index.</span></p>
<p><b>Returns:</b><br><span class="doc-list">The value of the lane at the specified index.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">return a[idx]
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="extract_lsbs"><span><a class="doc-id-link" href="#extract_lsbs">extract_lsbs<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">extract_lsbs :: <a href="/base/intrinsics#simd_extract_lsbs">intrinsics</a>.simd_extract_lsbs</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Extract the set of least-significant bits of a SIMD vector.</p>
<p>This procedure checks the the least-significant bit (LSB) for each lane of vector
and returns the numbers of lanes with the least-significant bit set. This procedure
can be used in conjuction with <code>lanes_eq</code> (and other similar procedures) to
count the number of matched lanes by computing the cardinality of the resulting
set.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An input vector.</span></p>
<p>Result:
<span class="doc-list">A bitset of integers, corresponding to the indexes of the lanes, whose LSBs</span>
  are set.</p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">res = bit_set {}
for i in 0 ..&lt; len(a) {
	if a[i] & 1 != 0 {
		res |= i
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// Since lanes 0, 2, 4, 6 contain odd integers, the least significant bits
// for these lanes are set.

import "core:fmt"
import "core:simd"

simd_extract_lsbs_example :: proc() {
	v := #simd [8]i32 { -1, -2, +3, +4, -5, +6, +7, -8 }
	fmt.println(simd.extract_lsbs(v))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">bit_set[0..=7]{0, 2, 4, 6}
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="extract_msbs"><span><a class="doc-id-link" href="#extract_msbs">extract_msbs<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">extract_msbs :: <a href="/base/intrinsics#simd_extract_msbs">intrinsics</a>.simd_extract_msbs</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Extract the set of most-significant bits of a SIMD vector.</p>
<p>This procedure checks the the most-significant bit (MSB) for each lane of vector
and returns the numbers of lanes with the most-significant bit set. This procedure
can be used in conjuction with <code>lanes_eq</code> (and other similar procedures) to
count the number of matched lanes by computing the cardinality of the resulting
set.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An input vector.</span></p>
<p>Result:
<span class="doc-list">A bitset of integers, corresponding to the indexes of the lanes, whose MSBs</span>
  are set.</p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">bits_per_lane = 8*size_of(a[0])
res = bit_set {}
for i in 0 ..&lt; len(a) {
	if a[i] & 1&lt;&lt;(bits_per_lane-1) != 0 {
		res |= i
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// Since lanes 0, 1, 4, 7 contain negative numbers, the most significant
// bits for them will be set.

import "core:fmt"
import "core:simd"

simd_extract_msbs_example :: proc() {
	v := #simd [8]i32 { -1, -2, +3, +4, -5, +6, +7, -8 }
	fmt.println(simd.extract_msbs(v))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">bit_set[0..=7]{0, 1, 4, 7}
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="floor"><span><a class="doc-id-link" href="#floor">floor<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">floor :: <a href="/base/intrinsics#simd_floor">intrinsics</a>.simd_floor</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Floor each lane in a SIMD vector.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="fma"><span><a class="doc-id-link" href="#fma">fma<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">fma :: <a href="/base/intrinsics#fused_mul_add">intrinsics</a>.fused_mul_add</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Perform a FMA (Fused multiply-add) operation on each lane of SIMD vectors.</p>
<p>A fused multiply-add is a ternary operation that for three operands, <code>a</code>, <code>b</code>
and <code>c</code>  performs the operation <code>a*b+c</code>. This operation is a hardware feature
that allows to minimize floating-point error and allow for faster computation.</p>
<p>This procedure performs a FMA operation on each lane of the SIMD vectors.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: The multiplier.</span>
<span class="doc-list"><code>b</code>: The multiplicand.</span>
<span class="doc-list"><code>c</code>: The addend.</span></p>
<p><b>Returns:</b><br><span class="doc-list"><code>a*b+c</code></span></p>
<p><b>Operation</b></p>
<pre>res := 0
for i in 0 ..&lt; len(a) {
	res[i] = fma(a[i], b[i], c[i])
}
return res
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="from_array"><span><a class="doc-id-link" href="#from_array">from_array<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L2653"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">from_array :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (v: [0]$E) -> <span class="directive">#simd</span>[0]$E {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Convert array to SIMD vector.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="from_slice"><span><a class="doc-id-link" href="#from_slice">from_slice<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L2660"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">from_slice :: <span class="keyword-type">proc</span>($T: <span class="directive">#simd</span>[0]$E, slice: T) -> <span class="directive">#simd</span>[0]$E {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Convert slice to SIMD vector.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="fused_mul_add"><span><a class="doc-id-link" href="#fused_mul_add">fused_mul_add<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">fused_mul_add :: <a href="/base/intrinsics#fused_mul_add">intrinsics</a>.fused_mul_add</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Perform a FMA (Fused multiply-add) operation on each lane of SIMD vectors.</p>
<p>A fused multiply-add is a ternary operation that for three operands, <code>a</code>, <code>b</code>
and <code>c</code>  performs the operation <code>a*b+c</code>. This operation is a hardware feature
that allows to minimize floating-point error and allow for faster computation.</p>
<p>This procedure performs a FMA operation on each lane of the SIMD vectors.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: The multiplier</span>
<span class="doc-list"><code>b</code>: The multiplicand</span>
<span class="doc-list"><code>c</code>: The addend</span></p>
<p><b>Returns:</b><br><span class="doc-list"><code>a*b+c</code></span></p>
<p><b>Operation</b></p>
<pre>res := 0
for i in 0 ..&lt; len(a) {
	res[i] = fma(a[i], b[i], c[i])
}
return res
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="gather"><span><a class="doc-id-link" href="#gather">gather<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">gather :: <a href="/base/intrinsics#simd_gather">intrinsics</a>.simd_gather</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Perform a gather load into a vector.</p>
<p>A <i>gather</i> operation is memory load operation, that loads values from an vector
of addresses into a single value vector. This can be used to achieve the
following results:</p>
<p><span class="doc-list">Accessing every N'th element of an array (strided access)</span>
<span class="doc-list">Access of elements according to some computed offsets (indexed access).</span>
<span class="doc-list">Access of elements in a different order (shuffling access).</span></p>
<p>When used alongside other SIMD procedures in order to compute the offsets
for the <code>ptr</code> and <code>mask</code> parameters.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>ptr</code>: A vector of memory locations. Each pointer points to a single value,</span></p>
<pre>of a SIMD vector's lane type that will be loaded into the vector. Pointer
in this vector can be `nil` or any other invalid value, if the corresponding
value in the `mask` parameter is zero.
</pre>
<p><span class="doc-list"><code>val</code>: A vector of values that will be used at corresponding positions</span></p>
<pre>of the result vector, if the corresponding memory location has been
masked out.
</pre>
<p><span class="doc-list"><code>mask</code>: A vector of booleans or unsigned integers that determines which memory</span></p>
<pre>locations to read from. If the value at an index has the value true
(lowest bit set), the value at that index will be loaded into the result
vector from the corresponding memory location in the `ptr` vector. Otherwise
the value will be loaded from the `val` vector.

</pre>
<p><b>Returns:</b><br><span class="doc-list">A vector with all values from unmasked indices</span>
loaded from the pointer vector <code>ptr</code>, and all values from masked indices loaded
from the value vector <code>val</code>.</p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	if mask[i]&1 == 1 {
		res[i] = ptr[i]^
	} else {
		res[i] = val[i]
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// Example below loads 2 lanes of values from 2 lanes of float vectors, `v1` and
// `v2`. From each of these vectors we're loading the second value, into the first
// and the third position of the result vector.

// Therefore the `ptrs` argument is initialized such that the first and the third
// value are the addresses of the values that we want to load into the result
// vector, and we'll fill in `nil` for the rest of them. To prevent CPU from
// dereferencing those `nil` addresses we provide the mask that only allows us
// to load valid positions of the `ptrs` array, and the array of defaults which
// will have `127` in each position as the default value.

import "core:fmt"
import "core:simd"

simd_gather_example :: proc() {
	v1 := [4] f32 {1, 2, 3, 4};
	v2 := [4] f32 {9, 10,11,12};
	ptrs := #simd [4]rawptr { &v1[1], nil, &v2[1], nil }
	mask := #simd [4]bool { true, false, true, false }
	defaults := #simd [4]f32 { 0x7f, 0x7f, 0x7f, 0x7f }
	res := simd.gather(ptrs, defaults, mask)
	fmt.println(res)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">&lt;2, 127, 10, 127&gt;
</pre>
<p>The first and the third positions came from the <code>ptrs</code> array, and the other
2 lanes of from the default vector. The graphic below shows how the values of
the result are decided based on the mask:</p>
<pre>      +-------------------------------+ 
mask: |   1   |   0   |   1   |   0   | 
      +-------------------------------+ 
        |         |       |       `----------------------------.
        |         |       |                                    |
        |          `----  |  ------------------------.         |
        v                 v                          v         v
      +-------------------------------+       +-------------------+
ptrs: |  &m0  |  nil  |  &m2  |  nil  | vals: | d0 | d1 | d2 | d3 |
      +-------------------------------+       +-------------------+
          |               |                          |         |
          |          .--- | -------------------------'         |
          |         |     |          ,-------------------------'
          v         v     v         v
        +-------------------------------+
result: |   m0  |   d1  |   m2  |  d3   |
        +-------------------------------+
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="indices"><span><a class="doc-id-link" href="#indices">indices<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">indices :: <a href="/base/intrinsics#simd_indices">intrinsics</a>.simd_indices</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Create a vector where each lane contains the index of that lane.
Inputs:
<span class="doc-list"><code>V</code>: The type of the vector to create.</span>
Result:
<span class="doc-list">A vector of the given type, where each lane contains the index of that lane.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; N {
	res[i] = i
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="lanes_eq"><span><a class="doc-id-link" href="#lanes_eq">lanes_eq<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">lanes_eq :: <a href="/base/intrinsics#simd_lanes_eq">intrinsics</a>.simd_lanes_eq</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Check if lanes of vectors are equal.</p>
<p>This procedure checks each pair of lanes from vectors <code>a</code> and <code>b</code> for whether
they are equal, and if they are, the corresponding lane of the result vector
will have a value with all bits set (<code>0xff..ff</code>). Otherwise the lane of the
result vector will have the value <code>0</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer, a float or a boolean vector.</span>
<span class="doc-list"><code>b</code>: An integer, a float or a boolean vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector of unsigned integers of the same size as the input vector's lanes,</span>
containing the comparison results for each lane.</p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	if a[i] == b[i] {
		res[i] = max(T)
	} else {
		res[i] = 0
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +-------+-------+-------+-------+
a: |   0   |   1   |   2   |   3   |
   +-------+-------+-------+-------+
   +-------+-------+-------+-------+
b: |   0   |   2   |   2   |   2   |
   +-------+-------+-------+-------+
res:
   +-------+-------+-------+-------+
   | 0xff  | 0x00  | 0xff  | 0x00  |
   +-------+-------+-------+-------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="lanes_ge"><span><a class="doc-id-link" href="#lanes_ge">lanes_ge<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">lanes_ge :: <a href="/base/intrinsics#simd_lanes_ge">intrinsics</a>.simd_lanes_ge</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Check if lanes of a vector are greater than or equal than another.
SIMD vector.</p>
<p>This procedure checks each pair of lanes from vectors <code>a</code> and <code>b</code> for whether the
lane of <code>a</code> is greater than or equal to the lane of <code>b</code>, and if so, the
corresponding lane of the result vector will have a value with all bits set
(<code>0xff..ff</code>). Otherwise the lane of the result vector will have the value <code>0</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer or a float vector.</span>
<span class="doc-list"><code>b</code>: An integer or a float vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector of unsigned integers of the same size as the input vector's lanes,</span>
containing the comparison results for each lane.</p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	if a[i] &gt;= b[i] {
		res[i] = unsigned(-1)
	} else {
		res[i] = 0
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +-------+-------+-------+-------+
a: |   0   |   1   |   2   |   3   |
   +-------+-------+-------+-------+
   +-------+-------+-------+-------+
b: |   0   |   2   |   2   |   2   |
   +-------+-------+-------+-------+
res:
   +-------+-------+-------+-------+
   | 0xff  | 0x00  | 0xff  | 0xff  |
   +-------+-------+-------+-------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="lanes_gt"><span><a class="doc-id-link" href="#lanes_gt">lanes_gt<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">lanes_gt :: <a href="/base/intrinsics#simd_lanes_gt">intrinsics</a>.simd_lanes_gt</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Check if lanes of a vector are greater than another.
vector.</p>
<p>This procedure checks each pair of lanes from vectors <code>a</code> and <code>b</code> for whether the
lane of <code>a</code> is greater than to the lane of <code>b</code>, and if so, the corresponding
lane of the result vector will have a value with all bits set (<code>0xff..ff</code>).
Otherwise the lane of the result vector will have the value <code>0</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer or a float vector.</span>
<span class="doc-list"><code>b</code>: An integer or a float vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector of unsigned integers of the same size as the input vector's lanes,</span>
containing the comparison results for each lane.</p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	if a[i] &gt; b[i] {
		res[i] = unsigned(-1)
	} else {
		res[i] = 0
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +-------+-------+-------+-------+
a: |   0   |   1   |   2   |   3   |
   +-------+-------+-------+-------+
   +-------+-------+-------+-------+
b: |   0   |   2   |   2   |   2   |
   +-------+-------+-------+-------+
res:
   +-------+-------+-------+-------+
   | 0x00  | 0x00  | 0x00  | 0xff  |
   +-------+-------+-------+-------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="lanes_le"><span><a class="doc-id-link" href="#lanes_le">lanes_le<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">lanes_le :: <a href="/base/intrinsics#simd_lanes_le">intrinsics</a>.simd_lanes_le</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Check if lanes of a vector are less than or equal than another.
SIMD vector.</p>
<p>This procedure checks each pair of lanes from vectors <code>a</code> and <code>b</code> for whether the
lane of <code>a</code> is less than or equal to the lane of <code>b</code>, and if so, the
corresponding lane of the result vector will have a value with all bits set
(<code>0xff..ff</code>). Otherwise the lane of the result vector will have the value <code>0</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer or a float vector.</span>
<span class="doc-list"><code>b</code>: An integer or a float vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector of unsigned integers of the same size as the input vector's lanes,</span>
containing the comparison results for each lane.</p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	if a[i] &lt;= b[i] {
		res[i] = unsigned(-1)
	} else {
		res[i] = 0
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +-------+-------+-------+-------+
a: |   0   |   1   |   2   |   3   |
   +-------+-------+-------+-------+
   +-------+-------+-------+-------+
b: |   0   |   2   |   2   |   2   |
   +-------+-------+-------+-------+
res:
   +-------+-------+-------+-------+
   | 0xff  | 0xff  | 0xff  | 0x00  |
   +-------+-------+-------+-------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="lanes_lt"><span><a class="doc-id-link" href="#lanes_lt">lanes_lt<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">lanes_lt :: <a href="/base/intrinsics#simd_lanes_lt">intrinsics</a>.simd_lanes_lt</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Check if lanes of a vector are less than another.</p>
<p>This procedure checks each pair of lanes from vectors <code>a</code> and <code>b</code> for whether
the lane of <code>a</code> is less than the lane of <code>b</code>, and if so, the corresponding lane
of the result vector will have a value with all bits set (<code>0xff..ff</code>). Otherwise
the lane of the result vector will have the value <code>0</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer or a float vector.</span>
<span class="doc-list"><code>b</code>: An integer or a float vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector of unsigned integers of the same size as the input vector's lanes,</span>
containing the comparison results for each lane.</p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	if a[i] &lt; b[i] {
		res[i] = unsigned(-1)
	} else {
		res[i] = 0
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +-------+-------+-------+-------+
a: |   0   |   1   |   2   |   3   |
   +-------+-------+-------+-------+
   +-------+-------+-------+-------+
b: |   0   |   2   |   2   |   2   |
   +-------+-------+-------+-------+
res:
   +-------+-------+-------+-------+
r: | 0x00  | 0xff  | 0x00  | 0x00  |
   +-------+-------+-------+-------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="lanes_ne"><span><a class="doc-id-link" href="#lanes_ne">lanes_ne<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">lanes_ne :: <a href="/base/intrinsics#simd_lanes_ne">intrinsics</a>.simd_lanes_ne</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Check if lanes of vectors are not equal.</p>
<p>This procedure checks each pair of lanes from vectors <code>a</code> and <code>b</code> for whether
they are not equal, and if they are, the corresponding lane of the result
vector will have a value with all bits set (<code>0xff..ff</code>). Otherwise the lane of
the result vector will have the value <code>0</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer, a float or a boolean vector.</span>
<span class="doc-list"><code>b</code>: An integer, a float or a boolean vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector of unsigned integers of the same size as the input vector's lanes,</span>
containing the comparison results for each lane.</p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	if a[i] != b[i] {
		res[i] = unsigned(-1)
	} else {
		res[i] = 0
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +-------+-------+-------+-------+
a: |   0   |   1   |   2   |   3   |
   +-------+-------+-------+-------+
   +-------+-------+-------+-------+
b: |   0   |   2   |   2   |   2   |
   +-------+-------+-------+-------+
res:
   +-------+-------+-------+-------+
   | 0x00  | 0xff  | 0x00  | 0xff  |
   +-------+-------+-------+-------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="lanes_reverse"><span><a class="doc-id-link" href="#lanes_reverse">lanes_reverse<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">lanes_reverse :: <a href="/base/intrinsics#simd_lanes_reverse">intrinsics</a>.simd_lanes_reverse</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reverse the lanes of a SIMD vector.</p>
<p>This procedure reverses the lanes of a vector, putting last lane in the
first spot, etc. This procedure is equivalent to the following call (for
4-element vectors):</p>
<pre>swizzle(a, 3, 2, 1, 0)
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="lanes_rotate_left"><span><a class="doc-id-link" href="#lanes_rotate_left">lanes_rotate_left<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">lanes_rotate_left :: <a href="/base/intrinsics#simd_lanes_rotate_left">intrinsics</a>.simd_lanes_rotate_left</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Rotate the lanes of a SIMD vector left.</p>
<p>This procedure rotates the lanes of a vector, putting the first lane of the
last spot, second lane in the first spot, third lane in the second spot, etc.
For 4-element vectors, this procedure is equvalent to the following:</p>
<pre>swizzle(a, 1, 2, 3, 0)
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="lanes_rotate_right"><span><a class="doc-id-link" href="#lanes_rotate_right">lanes_rotate_right<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">lanes_rotate_right :: <a href="/base/intrinsics#simd_lanes_rotate_right">intrinsics</a>.simd_lanes_rotate_right</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Rotate the lanes of a SIMD vector right.</p>
<p>This procedure rotates the lanes of a SIMD vector, putting the first lane of the
second spot, second lane in the third spot, etc. For 4-element vectors, this
procedure is equvalent to the following:</p>
<pre>swizzle(a, 3, 0, 1, 2)
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="masked_compress_store"><span><a class="doc-id-link" href="#masked_compress_store">masked_compress_store<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">masked_compress_store :: <a href="/base/intrinsics#simd_masked_compress_store">intrinsics</a>.simd_masked_compress_store</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Store masked values to consecutive memory locations.</p>
<p>This procedure stores values from masked lanes of a vector <code>val</code> consecutively
into memory. This operation is the opposite of <code>masked_expand_load</code>. The number
of items stored into memory is the number of set bits in the mask. If the value
in a lane of a mask is <code>true</code>, that lane is stored into memory. Otherwise
nothing is stored.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>ptr</code>: The pointer to the memory of a store.</span>
<span class="doc-list"><code>val</code>: The vector to store into memory.</span>
<span class="doc-list"><code>mask</code>: The mask that selects which values to store into memory.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">mem_idx := 0
for i in 0 ..&lt; len(mask) {
	if mask[i]&1 == 1 {
		ptr[mem_idx] = val[i]
		mem_idx += 1
	}
}
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// The code below fills the vector `v` with two values from a 4-element SIMD
// vector, the first and the third value. The items in the mask are set to `true`
// in those lanes.

import "core:fmt"
import "core:simd"

simd_masked_compress_store_example :: proc() {
	v := [2] f64 { };
	mask := #simd [4]bool { true, false, true, false }
	vals := #simd [4]f64 { 1, 2, 3, 4 }
	simd.masked_compress_store(&v, vals, mask)
	fmt.println(v)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">[1, 3]
</pre>
<p>Graphical representation of the operation:</p>
<pre>      +-------------------+
mask: | 1  | 0  | 1  | 0  |
      +-------------------+
        |         |
        v         v
      +-------------------+
vals: | v0 | v1 | v2 | v3 |
      +-------------------+
        |      ,--'
ptr     v     v
 +---&gt;+-----------------
      | v0  | v2  | ...
      +-----------------
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="masked_expand_load"><span><a class="doc-id-link" href="#masked_expand_load">masked_expand_load<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">masked_expand_load :: <a href="/base/intrinsics#simd_masked_expand_load">intrinsics</a>.simd_masked_expand_load</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Load consecutive scalar values and expand into a vector.</p>
<p>This procedure loads a number of consecutive scalar values from an address,
specified by the <code>ptr</code> parameter, and stores them in a result vector, according
to the mask. The number of values read from memory is the number of set bits
in the mask. The lanes for which the mask has the value <code>true</code> get the next
consecutive value from memory, otherwise if the mask is <code>false</code> for the
lane, its value is filled from the corresponding lane of the <code>val</code> parameter.</p>
<p>This procedure acts like <code>masked_store</code>, except the values from memory are
read consecutively, and not according to the lanes. The memory values are read
and assigned to the result vector's masked lanes in order of increasing
addresses.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>ptr</code>: The pointer to the memory to read from.</span>
<span class="doc-list"><code>vals</code>: The default values for masked-off entries.</span>
<span class="doc-list"><code>mask</code>: The mask that determines which lanes get consecutive memory values.</span></p>
<p><b>Returns:</b><br><span class="doc-list">The result vector, holding masked memory values unmasked default values.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">mem_idx := 0
for i in 0 ..&lt; len(mask) {
	if mask[i]&1 == 1 {
		res[i] = ptr[mem_idx]
		mem_idx += 1
	} else {
		res[i] = val[i]
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// The example below loads two values from memory of the vector `v`. Two values in
// the mask are set to `true`, meaning only two memory items will be loaded into
// the result vector. The mask is set to `true` in the first and the third
// position, which specifies that the first memory item will be read into the
// first lane of the result vector, and the second memory item will be read into
// the third lane of the result vector. All the other lanes of the result vector
// will be initialized to the default value `127`.

import "core:fmt"
import "core:simd"

simd_masked_expand_load_example :: proc() {
	v := [2] f64 {1, 2};
	mask := #simd [4]bool { true, false, true, false }
	vals := #simd [4]f64 { 0x7f, 0x7f, 0x7f, 0x7f }
	res := simd.masked_expand_load(&v, vals, mask)
	fmt.println(res)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">&lt;1, 127, 2, 127&gt;
</pre>
<p>Graphical representation of the operation:</p>
<pre>ptr ---&gt;+-----------+-----
        | m0  | m1  | ...
        +-----------+-----
          |      `--.
          v         v
        +-------------------+         +-------------------+
mask:   | 1  | 0  | 1  | 0  |   vals: | v0 | v1 | v2 | v3 |
        +-------------------+         +-------------------+
          |         |                         |         |
          |     .-- | -----------------------'          |
          |    |    |     ,----------------------------'
          v    v    v    v
        +-------------------+
result: | m0 | v1 | m1 | v3 |
        +-------------------+
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="masked_load"><span><a class="doc-id-link" href="#masked_load">masked_load<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">masked_load :: <a href="/base/intrinsics#simd_masked_load">intrinsics</a>.simd_masked_load</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Perform a masked load into the vector.</p>
<p>This procedure performs a masked load from memory, into the vector. The <code>ptr</code>
argument specifies the base address from which the values of the vector
will be loaded. The mask selects the source for the result vector's lanes. If
the mask for the corresponding lane has the value <code>true</code> (lowest bit set), the
result lane is loaded from memory. Otherwise the result lane is loaded from the
corresponding lane of the <code>val</code> vector.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>ptr</code>: The address of the vector values to load. Masked-off values are not</span></p>
<pre>accessed.
</pre>
<p><span class="doc-list"><code>val</code>: The vector of values that will be loaded into the masked slots of the</span></p>
<pre>result vector.
</pre>
<p><span class="doc-list"><code>mask</code>: The mask that selects where to load the values from.</span></p>
<p><b>Returns:</b><br><span class="doc-list">The loaded vector. The lanes for which the mask was set are loaded from</span>
memory, and the other lanes are loaded from the <code>val</code> vector.</p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	if mask[i]&1 == 1 {
		res[i] = ptr[i]
	} else {
		res[i] = vals[i]
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// The following code loads two values from the `src` vector, the first and the
// third value (selected by the mask). The masked-off values are given the value
// of 127 (`0x7f`).

import "core:fmt"
import "core:simd"

simd_masked_load_example :: proc() {
	src := [4] f32 {1, 2, 3, 4};
	mask := #simd [4]bool { true, false, true, false }
	vals := #simd [4]f32 { 0x7f, 0x7f, 0x7f, 0x7f }
	res := simd.masked_load(&src, vals, mask)
	fmt.println(res)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">&lt;1, 127, 3, 127&gt;
</pre>
<p>The graphic below demonstrates the flow of lanes.</p>
<pre>      +-------------------------------+ 
mask: |   1   |   0   |   1   |   0   | 
      +-------------------------------+ 
        |         |       |       `----------------------------.
        |         |       |                                    |
        |          `----  |  ------------------------.         |
ptr     v                 v                          v         v
+----&gt;+-------------------------------+       +-------------------+
      |   v1  |   v2  |   v3  |   v4  | vals: | d0 | d1 | d2 | d3 |
      +-------------------------------+       +-------------------+
          |               |                          |         |
          |          .--- | -------------------------'         |
          |         |     |          ,-------------------------'
          v         v     v         v
        +-------------------------------+
result: |  v1   |   d1  |  v3   |  d3   |
        +-------------------------------+
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="masked_store"><span><a class="doc-id-link" href="#masked_store">masked_store<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">masked_store :: <a href="/base/intrinsics#simd_masked_store">intrinsics</a>.simd_masked_store</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Perform a masked store to memory.</p>
<p>This procedure performs a masked store from a vector <code>val</code>, into memory at
address <code>ptr</code>, with the <code>mask</code> deciding which lanes are going to be stored,
and which aren't. If the mask at a corresponding lane has the value <code>true</code>
(lowest bit set), the lane is stored into memory. Otherwise the lane is not
stored into memory.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>ptr</code>: The base address of the store.</span>
<span class="doc-list"><code>val</code>: The vector to store.</span>
<span class="doc-list"><code>mask</code>: The mask, selecting which lanes of the vector to store into memory.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(val) {
	if mask[i]&1 == 1 {
		ptr[i] = val
	}
}
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// Example below stores the value 127 into the first and the third slot of the
// vector `v`.

import "core:fmt"
import "core:simd"

simd_masked_store_example :: proc() {
	v := [4] f32 {1, 2, 3, 4};
	mask := #simd [4]bool { true, false, true, false }
	vals := #simd [4]f32 { 0x7f, 0x7f, 0x7f, 0x7f }
	simd.masked_store(&v, vals, mask)
	fmt.println(v)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">[127, 2, 127, 4]
</pre>
<p>The graphic below shows the flow of lanes:</p>
<pre>      +-------------------+
mask: | 1  | 0  | 1  | 0  |
      +-------------------+
        |    |    |    |
        v    X    v    X
      +-------------------+
vals: | v0 | v1 | v2 | v3 |
      +-------------------+
         |         \
ptr      v          v
 +---&gt;+-----------------------+
      | v0  | ... | v2  | ... |
      +-----------------------+
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="max"><span><a class="doc-id-link" href="#max">max<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">max :: <a href="/base/intrinsics#simd_max">intrinsics</a>.simd_max</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Maximum of each lane of vectors.</p>
<p>This procedure returns a vector, such that each lane has the maximum value
between the corresponding lanes in vectors <code>a</code> and <code>b</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer or a float vector.</span>
<span class="doc-list"><code>b</code>: An integer or a float vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector containing with maximum values from corresponding lanes of <code>a</code> and <code>b</code>.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	if a[i] &gt; b[i] {
		res[i] = a[i]
	} else {
		res[i] = b[i]
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +-----+-----+-----+-----+
a: |  0  |  1  |  2  |  3  |
   +-----+-----+-----+-----+
   +-----+-----+-----+-----+
b: |  0  |  2  |  1  | -1  |
   +-----+-----+-----+-----+
res:
   +-----+-----+-----+-----+
   |  0  |  2  |  2  |  3  |
   +-----+-----+-----+-----+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="min"><span><a class="doc-id-link" href="#min">min<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">min :: <a href="/base/intrinsics#simd_min">intrinsics</a>.simd_min</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Minimum of each lane of vectors.</p>
<p>This procedure returns a vector, such that each lane has the minimum value
between the corresponding lanes in vectors <code>a</code> and <code>b</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer or a float vector.</span>
<span class="doc-list"><code>b</code>: An integer or a float vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector containing with minimum values from corresponding lanes of <code>a</code> and <code>b</code>.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	if a[i] &lt; b[i] {
		res[i] = a[i]
	} else {
		res[i] = b[i]
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +-----+-----+-----+-----+
a: |  0  |  1  |  2  |  3  |
   +-----+-----+-----+-----+
   +-----+-----+-----+-----+
b: |  0  |  2  |  1  | -1  |
   +-----+-----+-----+-----+
res:
   +-----+-----+-----+-----+
   |  0  |  1  |  1  | -1  |
   +-----+-----+-----+-----+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="mul"><span><a class="doc-id-link" href="#mul">mul<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">mul :: <a href="/base/intrinsics#simd_mul">intrinsics</a>.simd_mul</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Multiply (component-wise) SIMD vectors.</p>
<p>This procedure returns a vector, where each lane holds the product of the
corresponding lanes of the vectors <code>a</code> and <code>b</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer or a float vector.</span>
<span class="doc-list"><code>b</code>: An integer or a float vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector that is the product of two vectors.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	res[i] = a[i] * b[i]
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +-----+-----+-----+-----+
a: |  2  |  2  |  2  |  2  |
   +-----+-----+-----+-----+
   +-----+-----+-----+-----+
b: |  0  | -1  |  2  | -3  |
   +-----+-----+-----+-----+
res:
   +-----+-----+-----+-----+
   |  0  | -2  |  4  | -6  |
   +-----+-----+-----+-----+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="nearest"><span><a class="doc-id-link" href="#nearest">nearest<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">nearest :: <a href="/base/intrinsics#simd_nearest">intrinsics</a>.simd_nearest</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Compute the nearest integer of each lane in a SIMD vector.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="neg"><span><a class="doc-id-link" href="#neg">neg<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">neg :: <a href="/base/intrinsics#simd_neg">intrinsics</a>.simd_neg</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Negation of a SIMD vector.</p>
<p>This procedure returns a vector where each lane is the negation of the
corresponding lane in the vector <code>a</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer or a float vector to negate.</span></p>
<p><b>Returns:</b><br><span class="doc-list">The negated version of the vector <code>a</code>.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	res[i] = -a[i]
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +------+------+------+------+
a: |   0  |   1  |   2  |   3  |
   +------+------+------+------+
res:
   +------+------+------+------+
   |   0  |  -1  |  -2  |  -3  |
   +------+------+------+------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="recip"><span><a class="doc-id-link" href="#recip">recip<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L2748"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">recip :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (v: <span class="directive">#simd</span>[0]$E) -> <span class="directive">#simd</span>[0]$E {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Calculate reciprocals of SIMD lanes.</p>
<p>This procedure returns a vector where each lane is the reciprocal of the
corresponding lane in the vector <code>a</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer or a float vector to negate.</span></p>
<p><b>Returns:</b><br><span class="doc-list">Negated vector.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	res[i] = 1.0 / a[i]
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +------+------+------+------+
a: |   2  |   1  |   3  |   5  |
   +------+------+------+------+
res:
   +------+------+------+------+
   |  0.5 |   1  | 0.33 |  0.2 |
   +------+------+------+------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="reduce_add_bisect"><span><a class="doc-id-link" href="#reduce_add_bisect">reduce_add_bisect<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">reduce_add_bisect :: <a href="/base/intrinsics#simd_reduce_add_bisect">intrinsics</a>.simd_reduce_add_bisect</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reduce a vector to a scalar by adding up all the lanes in a bisecting fashion.</p>
<p>This procedure returns a scalar that is the sum of all lanes, calculated by
bisecting the vector into two parts, where the first contains lanes [0, N/2)
and the second contains lanes [N/2, N), and adding the two halves element-wise
to produce N/2 values. This is repeated until only a single element remains.
This order may be faster to compute than the ordered sum for floats, as it can
often be better parallelized.</p>
<p>The order of the sum may be important for accounting for precision errors in
floating-point computation, as floating-point addition is not associative, that
is <code>(a+b)+c</code> may not be equal to <code>a+(b+c)</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>v</code>: The vector to reduce.</span></p>
<p>Result:
<span class="doc-list">Sum of all lanes, as a scalar.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for n &gt; 1 {
	n = n / 2
	for i in 0 ..&lt; n {
		a[i] += a[i+n]
	}
}
res := a[0]
</code></pre>
</details>
<p>Graphical representation of the operation for N=4:</p>
<pre>     +-----------------------+
     | v0  | v1  | v2  | v3  |
     +-----------------------+
        |     |     |     |
       [+]&lt;-- | ---'      |
        |    [+]&lt;--------'
        |     |
        `&gt;[+]&lt;'
           |
           v
        +-----+
result: | y0  |
        +-----+
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="reduce_add_ordered"><span><a class="doc-id-link" href="#reduce_add_ordered">reduce_add_ordered<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">reduce_add_ordered :: <a href="/base/intrinsics#simd_reduce_add_ordered">intrinsics</a>.simd_reduce_add_ordered</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reduce a vector to a scalar by adding up all the lanes in an ordered fashion.</p>
<p>This procedure returns a scalar that is the ordered sum of all lanes. The
ordered sum may be important for accounting for precision errors in
floating-point computation, as floating-point addition is not associative,
that is <code>(a+b)+c</code> may not be equal to <code>a+(b+c)</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: The vector to reduce.</span></p>
<p>Result:
<span class="doc-list">Sum of all lanes, as a scalar.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">res := 0
for i in 0 ..&lt; len(a) {
	res += a[i]
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="reduce_add_pairs"><span><a class="doc-id-link" href="#reduce_add_pairs">reduce_add_pairs<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">reduce_add_pairs :: <a href="/base/intrinsics#simd_reduce_add_pairs">intrinsics</a>.simd_reduce_add_pairs</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reduce a vector to a scalar by adding up all the lanes in a pairwise fashion.</p>
<p>This procedure returns a scalar that is the sum of all lanes, calculated by
adding each even-indexed element with the following odd-indexed element to
produce N/2 values. This is repeated until only a single element remains. This
order is supported by hardware instructions for some types/architectures (e.g.
i16/i32/f32/f64 on x86 SSE, i8/i16/i32/f32 on ARM NEON).</p>
<p>The order of the sum may be important for accounting for precision errors in
floating-point computation, as floating-point addition is not associative, that
is <code>(a+b)+c</code> may not be equal to <code>a+(b+c)</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>v</code>: The vector to reduce.</span></p>
<p>Result:
<span class="doc-list">Sum of all lanes, as a scalar.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for n &gt; 1 {
	n = n / 2
	for i in 0 ..&lt; n {
		a[i] = a[2*i+0] + a[2*i+1]
	}
}
res := a[0]
</code></pre>
</details>
<p>Graphical representation of the operation for N=4:</p>
<pre>   +-----------------------+
v: | v0  | v1  | v2  | v3  |
   +-----------------------+
      |     |     |     |
      `&gt;[+]&lt;'     `&gt;[+]&lt;'
         |           |
         `---&gt;[+]&lt;--'
               |
               v
            +-----+
    result: | y0  |
            +-----+
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="reduce_all"><span><a class="doc-id-link" href="#reduce_all">reduce_all<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">reduce_all :: <a href="/base/intrinsics#simd_reduce_all">intrinsics</a>.simd_reduce_all</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reduce SIMD vector to a scalar by performing bitwise AND of all of the lanes.</p>
<p>This procedure returns a scalar that is the result of the bitwise AND operation
between all of the lanes in a vector.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: The vector to reduce.</span></p>
<p>Result:
<span class="doc-list">Bitwise AND of all lanes, as a scalar.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">res := 0
for i in 0 ..&lt; len(a) {
	res &= a[i]
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="reduce_and"><span><a class="doc-id-link" href="#reduce_and">reduce_and<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">reduce_and :: <a href="/base/intrinsics#simd_reduce_and">intrinsics</a>.simd_reduce_and</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reduce a vector to a scalar by performing bitwise AND of all of the lanes.</p>
<p>This procedure returns a scalar that is the result of the bitwise AND operation
between all of the lanes in a vector.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: The vector to reduce.</span></p>
<p>Result:
<span class="doc-list">Bitwise AND of all lanes, as a scalar.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">res := 0
for i in 0 ..&lt; len(a) {
	res &= a[i]
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="reduce_any"><span><a class="doc-id-link" href="#reduce_any">reduce_any<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">reduce_any :: <a href="/base/intrinsics#simd_reduce_any">intrinsics</a>.simd_reduce_any</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reduce SIMD vector to a scalar by performing bitwise OR of all of the lanes.</p>
<p>This procedure returns a scalar that is the result of the bitwise OR operation
between all of the lanes in a vector.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: The vector to reduce.</span></p>
<p>Result:
<span class="doc-list">Bitwise OR of all lanes, as a scalar.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">res := 0
for i in 0 ..&lt; len(a) {
	res |= a[i]
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="reduce_max"><span><a class="doc-id-link" href="#reduce_max">reduce_max<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">reduce_max :: <a href="/base/intrinsics#simd_reduce_max">intrinsics</a>.simd_reduce_max</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reduce a vector to a scalar by finding the maximum value between all of the lanes.</p>
<p>This procedure returns a scalar that is the maximum value of all the lanes
in a vector.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: The vector to reduce.</span></p>
<p>Result:
<span class="doc-list">Maximum value of all lanes, as a scalar.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">res := 0
for i in 0 ..&lt; len(a) {
	res = max(res, a[i])
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="reduce_min"><span><a class="doc-id-link" href="#reduce_min">reduce_min<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">reduce_min :: <a href="/base/intrinsics#simd_reduce_min">intrinsics</a>.simd_reduce_min</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reduce a vector to a scalar by finding the minimum value between all of the lanes.</p>
<p>This procedure returns a scalar that is the minimum value of all the lanes
in a vector.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: The vector to reduce.</span></p>
<p>Result:
<span class="doc-list">Minimum value of all lanes, as a scalar.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">res := 0
for i in 0 ..&lt; len(a) {
	res = min(res, a[i])
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="reduce_mul_bisect"><span><a class="doc-id-link" href="#reduce_mul_bisect">reduce_mul_bisect<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">reduce_mul_bisect :: <a href="/base/intrinsics#simd_reduce_mul_bisect">intrinsics</a>.simd_reduce_mul_bisect</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reduce a vector to a scalar by multiplying up all the lanes in a bisecting fashion.</p>
<p>This procedure returns a scalar that is the product of all lanes, calculated by
bisecting the vector into two parts, where the first contains indices [0, N/2)
and the second contains indices [N/2, N), and multiplying the two halves
together element-wise to produce N/2 values. This is repeated until only a
single element remains. This order may be faster to compute than the ordered
product for floats, as it can often be better parallelized.</p>
<p>The order of the product may be important for accounting for precision errors
in floating-point computation, as floating-point multiplication is not
associative, that is <code>(a*b)*c</code> may not be equal to <code>a*(b*c)</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>v</code>: The vector to reduce.</span></p>
<p>Result:
<span class="doc-list">Product of all lanes, as a scalar.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for n &gt; 1 {
	n = n / 2
	for i in 0 ..&lt; n {
		a[i] *= a[i+n]
	}
}
res := a[0]
</code></pre>
</details>
<p>Graphical representation of the operation for N=4:</p>
<pre>     +-----------------------+
     | v0  | v1  | v2  | v3  |
     +-----------------------+
        |     |     |     |
       [x]&lt;-- | ---'      |
        |    [x]&lt;--------'
        |     |
        `&gt;[x]&lt;'
           |
           v
        +-----+
result: | y0  |
        +-----+
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="reduce_mul_ordered"><span><a class="doc-id-link" href="#reduce_mul_ordered">reduce_mul_ordered<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">reduce_mul_ordered :: <a href="/base/intrinsics#simd_reduce_mul_ordered">intrinsics</a>.simd_reduce_mul_ordered</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reduce a vector to a scalar by multiplying all the lanes in an ordered fashion.</p>
<p>This procedure returns a scalar that is the ordered product of all lanes.
The ordered product may be important for accounting for precision errors in
floating-point computation, as floating-point multiplication is not associative,
that is <code>(a*b)*c</code> may not be equal to <code>a*(b*c)</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: The vector to reduce.</span></p>
<p>Result:
<span class="doc-list">Product of all lanes, as a scalar.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">res := 1
for i in 0 ..&lt; len(a) {
	res *= a[i]
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="reduce_mul_pairs"><span><a class="doc-id-link" href="#reduce_mul_pairs">reduce_mul_pairs<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">reduce_mul_pairs :: <a href="/base/intrinsics#simd_reduce_mul_pairs">intrinsics</a>.simd_reduce_mul_pairs</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reduce a vector to a scalar by multiplying all the lanes in a pairwise fashion.</p>
<p>This procedure returns a scalar that is the product of all lanes, calculated by
bisecting the vector into two parts, where the first contains lanes [0, N/2)
and the second contains lanes [N/2, N), and multiplying the two halves together
multiplying each even-indexed element with the following odd-indexed element to
produce N/2 values. This is repeated until only a single element remains. This
order may be faster to compute than the ordered product for floats, as it can
often be better parallelized.</p>
<p>The order of the product may be important for accounting for precision errors
in floating-point computation, as floating-point multiplication is not
associative, that is <code>(a*b)*c</code> may not be equal to <code>a*(b*c)</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>v</code>: The vector to reduce.</span></p>
<p>Result:
<span class="doc-list">Product of all lanes, as a scalar.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for n &gt; 1 {
	n = n / 2
	for i in 0 ..&lt; n {
		a[i] = a[2*i+0] * a[2*i+1]
	}
}
res := a[0]
</code></pre>
</details>
<p>Graphical representation of the operation for N=4:</p>
<pre>   +-----------------------+
v: | v0  | v1  | v2  | v3  |
   +-----------------------+
      |     |     |     |
      `&gt;[x]&lt;'     `&gt;[x]&lt;'
         |           |
         `---&gt;[x]&lt;--'
               |
               v
            +-----+
    result: | y0  |
            +-----+
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="reduce_or"><span><a class="doc-id-link" href="#reduce_or">reduce_or<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">reduce_or :: <a href="/base/intrinsics#simd_reduce_or">intrinsics</a>.simd_reduce_or</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reduce a vector to a scalar by performing bitwise OR of all of the lanes.</p>
<p>This procedure returns a scalar that is the result of the bitwise OR operation
between all of the lanes in a vector.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: The vector to reduce.</span></p>
<p>Result:
<span class="doc-list">Bitwise OR of all lanes, as a scalar.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">res := 0
for i in 0 ..&lt; len(a) {
	res |= a[i]
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="reduce_xor"><span><a class="doc-id-link" href="#reduce_xor">reduce_xor<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">reduce_xor :: <a href="/base/intrinsics#simd_reduce_xor">intrinsics</a>.simd_reduce_xor</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reduce SIMD vector to a scalar by performing bitwise XOR of all of the lanes.</p>
<p>This procedure returns a scalar that is the result of the bitwise XOR operation
between all of the lanes in a vector.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: The vector to reduce.</span></p>
<p>Result:
<span class="doc-list">Bitwise XOR of all lanes, as a scalar.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">res := 0
for i in 0 ..&lt; len(a) {
	res ~= a[i]
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="replace"><span><a class="doc-id-link" href="#replace">replace<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">replace :: <a href="/base/intrinsics#simd_replace">intrinsics</a>.simd_replace</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Replace the value in a vector's lane.</p>
<p>This procedure places a scalar value at the lane corresponding to the given index of
the vector.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: The vector to replace a lane in.</span>
<span class="doc-list"><code>idx</code>: The lane index.</span>
<span class="doc-list"><code>elem</code>: The scalar to place.</span></p>
<p><b>Returns:</b><br><span class="doc-list">Vector with the specified lane replaced.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">a[idx] = elem
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="reverse_bits"><span><a class="doc-id-link" href="#reverse_bits">reverse_bits<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">reverse_bits :: <a href="/base/intrinsics#reverse_bits">intrinsics</a>.reverse_bits</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reverse the bit pattern of a SIMD vector.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="runtime_swizzle"><span><a class="doc-id-link" href="#runtime_swizzle">runtime_swizzle<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">runtime_swizzle :: <a href="/base/intrinsics#simd_runtime_swizzle">intrinsics</a>.simd_runtime_swizzle</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Runtime Equivalent to Shuffle.</p>
<p>Performs element-wise table lookups using runtime indices.
Each element in the indices vector selects an element from the table vector.
The indices are automatically masked to prevent out-of-bounds access.</p>
<p>This operation is hardware-accelerated on most platforms when using 8-bit
integer vectors. For other element types or unsupported vector sizes, it
falls back to software emulation.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>table</code>: The lookup table vector (should be power-of-2 size for correct masking).</span>
<span class="doc-list"><code>indices</code>: The indices vector (automatically masked to valid range).</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector where <code>result[i] = table[indices[i] & (table_size-1)]</code>.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(indices) {
	masked_index := indices[i] & (len(table) - 1)
	result[i] = table[masked_index]
}
return result
</code></pre>
</details>
<p>Implementation:</p>
<pre>| Platform    | Lane Size                                 | Implementation      |
|-------------|-------------------------------------------|---------------------|
| x86-64      | pshufb (16B), vpshufb (32B), AVX512 (64B) | Single vector       |
| ARM64       | tbl1 (16B), tbl2 (32B), tbl4 (64B)        | Automatic splitting |
| ARM32       | vtbl1 (8B), vtbl2 (16B), vtbl4 (32B)      | Automatic splitting |
| WebAssembly | i8x16.swizzle (16B), Emulation (&gt;16B)     | Mixed               |
| Other       | Emulation                                 | Software            |

</pre>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">import "core:simd"
import "core:fmt"

runtime_swizzle_example :: proc() {
	table := simd.u8x16{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}
	indices := simd.u8x16{15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}
	result := simd.runtime_swizzle(table, indices)
	fmt.println(result) // Expected: {15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}
}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="saturating_add"><span><a class="doc-id-link" href="#saturating_add">saturating_add<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">saturating_add :: <a href="/base/intrinsics#simd_saturating_add">intrinsics</a>.simd_saturating_add</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Saturated addition of SIMD vectors.</p>
<p>The <i>saturated sum</i> is a just like a normal sum, except the treatment of the
result upon overflow or underflow is different. In saturated operations, the
result is not wrapped to the bit-width of the lane, and instead is kept clamped
between the minimum and the maximum values of the lane type.</p>
<p>This procedure returns a vector where each lane is the saturated sum of the
corresponding lanes of vectors <code>a</code> and <code>b</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer vector.</span>
<span class="doc-list"><code>b</code>: An integer vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">The saturated sum of the two vectors.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	switch {
	case b[i] &gt;= max(type_of(a[i])) - a[i]: // (overflow of a[i])
		res[i] = max(type_of(a[i]))
	case b[i] &lt;= min(type_of(a[i])) - a[i]: // (underflow of a[i])
		res[i] = min(type_of(a[i]))
	} else {
		res[i] = a[i] + b[i]
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// An example for a 4-lane vector `a` of 8-bit signed integers.

   +-----+-----+-----+-----+
a: |  0  | 255 |  2  |  3  |
   +-----+-----+-----+-----+
   +-----+-----+-----+-----+
b: |  1  |  3  |  2  | -1  |
   +-----+-----+-----+-----+
res:
   +-----+-----+-----+-----+
   |  1  | 255 |  4  |  2  |
   +-----+-----+-----+-----+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="saturating_sub"><span><a class="doc-id-link" href="#saturating_sub">saturating_sub<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">saturating_sub :: <a href="/base/intrinsics#simd_saturating_sub">intrinsics</a>.simd_saturating_sub</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Saturated subtraction of 2 lanes of vectors.</p>
<p>The <i>saturated difference</i> is a just like a normal difference, except the treatment of the
result upon overflow or underflow is different. In saturated operations, the
result is not wrapped to the bit-width of the lane, and instead is kept clamped
between the minimum and the maximum values of the lane type.</p>
<p>This procedure returns a vector where each lane is the saturated difference of
the corresponding lanes of vectors <code>a</code> and <code>b</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer vector to subtract from.</span>
<span class="doc-list"><code>b</code>: An integer vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">The saturated difference of the two vectors.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	switch {
	case b[i] &gt;= max(type_of(a[i])) + a[i]: // (overflow of a[i])
		res[i] = max(type_of(a[i]))
	case b[i] &lt;= min(type_of(a[i])) + a[i]: // (underflow of a[i])
		res[i] = min(type_of(a[i]))
	} else {
		res[i] = a[i] - b[i]
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// An example for a 4-lane vector `a` of 8-bit signed integers.

   +-----+-----+-----+-----+
a: |  0  | 255 |  2  |  3  |
   +-----+-----+-----+-----+
   +-----+-----+-----+-----+
b: |  3  |  3  |  2  | -1  |
   +-----+-----+-----+-----+
res:
   +-----+-----+-----+-----+
   |  0  | 252 |  0  |  4  |
   +-----+-----+-----+-----+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="scatter"><span><a class="doc-id-link" href="#scatter">scatter<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">scatter :: <a href="/base/intrinsics#simd_scatter">intrinsics</a>.simd_scatter</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Perform a scatter store from a vector.</p>
<p>A <i>scatter</i> operation is a memory store operation that stores values from a
vector into multiple memory locations. This operation is effectively the
opposite of the <i>gather</i> operation.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>ptr</code>: A vector of memory locations. Each masked location will be written</span></p>
<pre>to with a value from the `val` vector. Pointers in this vector can be `nil`
or any other invalid value if the corresponding value in the `mask`
parameter is zero.
</pre>
<p><span class="doc-list"><code>val</code>: A vector of values to write to the memory locations.</span>
<span class="doc-list"><code>mask</code>: A vector of booleans or unsigned integers that decides which lanes</span></p>
<pre>get written to memory. If the value of the mask is `true` (the lowest bit
set), the corresponding lane is written into memory. Otherwise it's not
written into memory.

</pre>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(ptr) {
	if mask[i]&1 == 1 {
		ptr[i]^ = val[i]
	}
}
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// Example below writes value `127` to the second element of two different
// vectors. The addresses of store destinations are written to the first and the
// third argument of the `ptr` vector, and the `mask` is set accordingly.

import "core:fmt"
import "core:simd"

simd_scatter_example :: proc() {
	v1 := [4] f32 {1, 2, 3, 4};
	v2 := [4] f32 {5, 6, 7, 8};
	ptrs := #simd [4]rawptr { &v1[1], nil, &v2[1], nil }
	mask := #simd [4]bool { true, false, true, false }
	vals := #simd [4]f32 { 0x7f, 0x7f, 0x7f, 0x7f }
	simd.scatter(ptrs, vals, mask)
	fmt.println(v1)
	fmt.println(v2)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">[1, 127, 3, 4]
[5, 127, 7, 8]
</pre>
<p>The graphic below shows how the data gets written into memory.</p>
<pre>      +-------------------+
mask: | 1  | 0  | 1  | 0  |
      +-------------------+
        |    |    |    |
        v    X    v    X
      +-------------------+
vals: | d0 | d1 | d2 | d3 |
      +-------------------+
         |         \
         v          v
      +-----------------------+
ptrs: | &m0 | nil | &m2 | nil |
      +-----------------------+
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="select"><span><a class="doc-id-link" href="#select">select<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">select :: <a href="/base/intrinsics#simd_select">intrinsics</a>.simd_select</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Select values from one of the two vectors.</p>
<p>This procedure returns a vector, which has, on each lane a value from one of the
corresponding lanes in one of the two input vectors based on the <code>cond</code>
parameter. On each lane, if the value of the <code>cond</code> parameter is <code>true</code> (or
non-zero), the result lane will have a value from the <code>true</code> input vector,
otherwise the result lane will have a value from the <code>false</code> input vector.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>cond</code>: The condition vector.</span>
<span class="doc-list"><code>true</code>: The first input vector.</span>
<span class="doc-list"><code>false</code>: The second input vector.</span></p>
<p>Result:
<span class="doc-list">The result of selecting values from the two input vectors.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">res = {}
for i in 0 ..&lt; len(cond) {
	if cond[i] {
		res[i] = true[i]
	} else {
		res[i] = false[i]
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// The following example selects values from the two input vectors, `a` and `b`
// into a single vector.

import "core:fmt"
import "core:simd"

simd_select_example :: proc() {
	a := #simd [4] f64 { 1,2,3,4 }
	b := #simd [4] f64 { 5,6,7,8 }
	cond := #simd[4] int { 1, 0, 1, 0 }
	fmt.println(simd.select(cond,a,b))
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">&lt;1, 6, 3, 8&gt;
</pre>
<p>Graphically, the operation looks as follows. The <code>t</code> and <code>f</code> represent the
<code>true</code> and <code>false</code> vectors respectively:</p>
<pre>      0     1     2     3            0     1     2     3
      +-----+-----+-----+-----+      +-----+-----+-----+-----+
t:    |  1  |  2  |  3  |  4  |  f:  |  5  |  6  |  7  |  8  |
      +-----+-----+-----+-----+      +-----+-----+-----+-----+
         ^           ^                        ^           ^
         |           |                        |           |
         |           |                        |           |
         |      .--- | ----------------------'            |
         |     |     |     .-----------------------------'
      +-----+-----+-----+-----+
cond: |  1  |  0  |  1  |  0  |
      +-----+-----+-----+-----+
         ^     ^     ^     ^
         |     |     |     |
      +-----+-----+-----+-----+
res:  |  1  |  5  |  3  |  6  |
      +-----+-----+-----+-----+
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="shl"><span><a class="doc-id-link" href="#shl">shl<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">shl :: <a href="/base/intrinsics#simd_shl">intrinsics</a>.simd_shl</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Shift left lanes of a vector.</p>
<p>This procedure returns a vector, such that each lane holds the result of a
shift-left (aka shift-up) operation of the corresponding lane from vector <code>a</code> by the shift
amount from the corresponding lane of the vector <code>b</code>.</p>
<p>If the shift amount is greater than the bit-width of a lane, the result is <code>0</code>
in the corresponding positions of the result.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer vector of values to shift.</span>
<span class="doc-list"><code>b</code>: An unsigned integer vector of the shift amounts.</span></p>
<p>Result:
<span class="doc-list">A vector, where each lane is the lane from <code>a</code> shifted left by the amount</span>
specified in the corresponding lane of the vector <code>b</code>.</p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	if b[i] &lt; 8*size_of(a[i]) {
		res[i] = a[i] &lt;&lt; b[i]
	} else {
		res[i] = 0
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// An example for a 4-lane 8-bit signed integer vector `a`.

   +-------+-------+-------+-------+
a: |  0x11 |  0x55 |  0x03 |  0xff |
   +-------+-------+-------+-------+
   +-------+-------+-------+-------+
b: |   2   |   1   |   33  |   1   |
   +-------+-------+-------+-------+
res:
   +-------+-------+-------+--------+
   |  0x44 |  0xaa |   0   |  0xfe  |
   +-------+-------+-------+--------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="shl_masked"><span><a class="doc-id-link" href="#shl_masked">shl_masked<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">shl_masked :: <a href="/base/intrinsics#simd_shl_masked">intrinsics</a>.simd_shl_masked</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Shift left lanes of a vector (masked).</p>
<p>This procedure returns a vector, such that each lane holds the result of a
shift-left (aka shift-up) operation, of lane from the vector <code>a</code> by the shift
amount from the corresponding lane of the vector <code>b</code>.</p>
<p>The shift amount is wrapped (masked) to the bit-width of the lane.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer vector of values to shift.</span>
<span class="doc-list"><code>b</code>: An unsigned integer vector of the shift amounts.</span></p>
<p>Result:
<span class="doc-list">A vector, where each lane is the lane from <code>a</code> shifted left by the amount</span>
specified in the corresponding lane of the vector <code>b</code>.</p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	mask := 8*size_of(a[i]) - 1
	res[i] = a[i] &lt;&lt; (b[i] & mask)
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// An example for a 4-lane vector `a` of 8-bit signed integers.

   +-------+-------+-------+-------+
a: |  0x11 |  0x55 |  0x03 |  0xff |
   +-------+-------+-------+-------+
   +-------+-------+-------+-------+
b: |   2   |   1   |   33  |   1   |
   +-------+-------+-------+-------+
res:
   +-------+-------+-------+--------+
   |  0x44 |  0xaa |  0x06 |  0xfe  |
   +-------+-------+-------+--------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="shr"><span><a class="doc-id-link" href="#shr">shr<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">shr :: <a href="/base/intrinsics#simd_shr">intrinsics</a>.simd_shr</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Shift right lanes of a vector.</p>
<p>This procedure returns a vector, such that each lane holds the result of a
shift-right (aka shift-down) operation, of lane from the vector <code>a</code> by the shift
amount from the corresponding lane of the vector <code>b</code>.</p>
<p>If the shift amount is greater than the bit-width of a lane, the result is <code>0</code>
in the corresponding positions of the result.</p>
<p>If the first vector is a vector of signed integers, the arithmetic shift
operation is performed. Otherwise, if the first vector is a vector of unsigned
integers, a logical shift is performed.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer vector of values to shift.</span>
<span class="doc-list"><code>b</code>: An unsigned integer vector of the shift amounts.</span></p>
<p>Result:
<span class="doc-list">A vector, where each lane is the lane from <code>a</code> shifted right by the amount</span>
specified in the corresponding lane of the vector <code>b</code>.</p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	if b[i] &lt; 8*size_of(a[i]) {
		res[i] = a[i] &gt;&gt; b[i]
	} else {
		res[i] = 0
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// An example for a 4-lane 8-bit signed integer vector `a`.

   +-------+-------+-------+-------+
a: |  0x11 |  0x55 |  0x03 |  0xff |
   +-------+-------+-------+-------+
   +-------+-------+-------+-------+
b: |   2   |   1   |   33  |   1   |
   +-------+-------+-------+-------+
res:
   +-------+-------+-------+--------+
   |  0x04 |  0x2a |   0   |  0xff  |
   +-------+-------+-------+--------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="shr_masked"><span><a class="doc-id-link" href="#shr_masked">shr_masked<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">shr_masked :: <a href="/base/intrinsics#simd_shr_masked">intrinsics</a>.simd_shr_masked</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Shift right lanes of a vector (masked).</p>
<p>This procedure returns a vector, such that each lane holds the result of a
shift-right (aka shift-down) operation, of lane from the vector <code>a</code> by the shift
amount from the corresponding lane of the vector <code>b</code>.</p>
<p>The shift amount is wrapped (masked) to the bit-width of the lane.</p>
<p>If the first vector is a vector of signed integers, the arithmetic shift
operation is performed. Otherwise, if the first vector is a vector of unsigned
integers, a logical shift is performed.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer vector of values to shift.</span>
<span class="doc-list"><code>b</code>: An unsigned integer vector of the shift amounts.</span></p>
<p>Result:
<span class="doc-list">A vector, where each lane is the lane from <code>a</code> shifted right by the amount</span>
specified in the corresponding lane of the vector <code>b</code>.</p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	mask := 8*size_of(a[i]) - 1
	res[i] = a[i] &gt;&gt; (b[i] & mask)
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// An example for a 4-lane vector `a` of 8-bit signed integers.

   +-------+-------+-------+-------+
a: |  0x11 |  0x55 |  0x03 |  0xff |
   +-------+-------+-------+-------+
   +-------+-------+-------+-------+
b: |   2   |   1   |   33  |   1   |
   +-------+-------+-------+-------+
res:
   +-------+-------+-------+--------+
   |  0x04 |  0x2a |  0x01 |  0xff  |
   +-------+-------+-------+--------+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="shuffle"><span><a class="doc-id-link" href="#shuffle">shuffle<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">shuffle :: <a href="/base/intrinsics#simd_shuffle">intrinsics</a>.simd_shuffle</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reorder the lanes of two SIMD vectors.</p>
<p>This procedure returns a vector, containing the scalars from the lanes of two
vectors, according to the provided indices vector. Each index in the indices
vector specifies, the lane of the scalar from one of the two input vectors,
which will be written at the corresponding position of the result vector. If
the index is within bounds 0 ..&lt; len(A), it corresponds to the indices of the
first input vector. Otherwise the index corresponds to the indices of the second
input vector.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: The first input vector.</span>
<span class="doc-list"><code>b</code>: The second input vector.</span>
<span class="doc-list"><code>indices</code>: The indices.</span></p>
<p>Result:
<span class="doc-list">Input vectors, shuffled according to the indices.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">res = {}
for i in 0 ..&lt; len(indices) {
	idx = indices[i];
	if idx &lt; len(a) {
		res[i] = a[idx]
	} else {
		res[i] = b[idx]
	}
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// The example below shows how the indices are used to determine lanes of the
// input vector that are shuffled into the result vector.

import "core:fmt"
import "core:simd"

simd_shuffle_example :: proc() {
	a := #simd [4]f32 { 1, 2, 3, 4 }
	b := #simd [4]f32 { 5, 6, 7, 8 }
	res := simd.shuffle(a, b, 0, 4, 2, 5)
	fmt.println(res)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">&lt;1, 5, 3, 6&gt;
</pre>
<p>The graphical representation of the operation is as follows. The <code>idx</code> vector in
the picture represents the <code>indices</code> parameter:</p>
<pre>      0     1     2     3            4     5     6     7
      +-----+-----+-----+-----+      +-----+-----+-----+-----+
a:    |  1  |  2  |  3  |  4  |  b:  |  5  |  6  |  7  |  8  |
      +-----+-----+-----+-----+      +-----+-----+-----+-----+
         ^           ^                  ^     ^
         |           |                  |     |
         |           |                  |     |
         |      .--- | ----------------'      |
         |     |     |     .-----------------'
      +-----+-----+-----+-----+
idx:  |  0  |  4  |  2  |  5  |
      +-----+-----+-----+-----+
         ^     ^     ^     ^
         |     |     |     |
      +-----+-----+-----+-----+
res:  |  1  |  5  |  3  |  6  |
      +-----+-----+-----+-----+
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="signum"><span><a class="doc-id-link" href="#signum">signum<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L2714"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">signum :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (v: <span class="directive">#simd</span>[0]$E) -> <span class="directive">#simd</span>[0]$E {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Return signs of SIMD lanes.</p>
<p>This procedure returns a vector, each lane of which contains either +1.0 or
-1.0 depending on the sign of the value in the corresponding lane of the
input vector. If the lane of the input vector has NaN, then the result vector
will contain this NaN value as-is.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="sqrt"><span><a class="doc-id-link" href="#sqrt">sqrt<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">sqrt :: <a href="/base/intrinsics#sqrt">intrinsics</a>.sqrt</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Compute the square root of each lane in a SIMD vector.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="sub"><span><a class="doc-id-link" href="#sub">sub<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">sub :: <a href="/base/intrinsics#simd_sub">intrinsics</a>.simd_sub</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Subtract SIMD vectors.</p>
<p>This procedure returns a vector, where each lane holds the difference between
the corresponding lanes of the vectors <code>a</code> and <code>b</code>. The lanes from the vector
<code>b</code> are subtracted from the corresponding lanes of the vector <code>a</code>.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>a</code>: An integer or a float vector to subtract from.</span>
<span class="doc-list"><code>b</code>: An integer or a float vector.</span></p>
<p><b>Returns:</b><br><span class="doc-list">A vector that is the difference of two vectors, <code>a</code> - <code>b</code>.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">for i in 0 ..&lt; len(res) {
	res[i] = a[i] - b[i]
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">   +-----+-----+-----+-----+
a: |  2  |  2  |  2  |  2  |
   +-----+-----+-----+-----+
   +-----+-----+-----+-----+
b: |  0  |  1  |  2  |  3  |
   +-----+-----+-----+-----+
res:
   +-----+-----+-----+-----+
   |  2  |  1  |  0  | -1  |
   +-----+-----+-----+-----+
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="swizzle"><span><a class="doc-id-link" href="#swizzle">swizzle<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">swizzle :: <a href="/base/builtin#swizzle">builtin</a>.swizzle</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reorder the lanes of a SIMD vector.</p>
<p>This procedure reorders the lanes of a vector, according to the provided
indices. The number of indices correspond to the number of lanes in the
result vector and must be the same as the number of lanes of the input vector.
Each index specifies, the lane of the scalar from the input vector, which
will be written at the corresponding position of the result vector.</p>
<p><b>Inputs:</b><br><span class="doc-list"><code>x</code>: The input vector.</span>
<span class="doc-list"><code>indices</code>: The indices of lanes to write to the result vector.</span></p>
<p>Result:
<span class="doc-list">Swizzled input vector.</span></p>
<details open class="code-example">
<summary><b>Operation:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">res = {}
for i in 0 ..&lt; len(indices) {
	res[i] = x[indices[i]]
}
return res
</code></pre>
</details>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">// The example below shows how the indices are used to determine which lanes of the
// input vector get written into the result vector.

import "core:fmt"
import "core:simd"

swizzle_example :: proc() {
	x := #simd [4]f32 { 1.5, 2.5, 3.5, 4.5 }
	res := simd.swizzle(x, 0, 3, 1, 1)
	fmt.println(res)
}
</code></pre>
</details>
<b>Output:</b>
<pre class="doc-code">&lt;1.5, 4.5, 2.5, 2.5&gt;
</pre>
<p>The graphical representation of the operation is as follows. The <code>idx</code> vector in
the picture represents the <code>indices</code> parameter:</p>
<pre>      0     1     2     3
      +-----+-----+-----+-----+
x:    | 1.5 | 2.5 | 3.5 | 4.5 |
      +-----+-----+-----+-----+
         ^     ^           ^
         |     |           |
         |      '----.     |
         |     .---- | ---'
         |     |     |
         |     |     +------.
      +-----+-----+-----+-----+
idx:  |  0  |  3  |  1  |  1  |
      +-----+-----+-----+-----+
         ^     ^     ^     ^
         |     |     |     |
      +-----+-----+-----+-----+
res:  | 1.5 | 3.5 | 2.5 | 2.5 |
      +-----+-----+-----+-----+
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_array"><span><a class="doc-id-link" href="#to_array">to_array<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L2646"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_array :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (v: <span class="directive">#simd</span>[0]$E) -> [0]$E {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Convert SIMD vector to an array.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_array_ptr"><span><a class="doc-id-link" href="#to_array_ptr">to_array_ptr<span class="a-hidden">&nbsp;¶</span></a></span><div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin#L2639"><em>Source</em></a></div></h3>
<div>
<pre class="doc-code">to_array_ptr :: <span class="keyword-type">proc</span> <span class="string">"contextless"</span> (v: ^<span class="directive">#simd</span>[0]$E) -> ^[0]$E {…}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Convert pointer to SIMD vector to an array pointer.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="to_bits"><span><a class="doc-id-link" href="#to_bits">to_bits<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">to_bits :: <a href="/base/intrinsics#simd_to_bits">intrinsics</a>.simd_to_bits</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Transmute a SIMD vector into an integer vector.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="trunc"><span><a class="doc-id-link" href="#trunc">trunc<span class="a-hidden">&nbsp;¶</span></a></span></h3>
<div>
<pre class="doc-code">trunc :: <a href="/base/intrinsics#simd_trunc">intrinsics</a>.simd_trunc</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Truncate each lane in a SIMD vector.</p>
</details>
</div>
<h2 id="pkg-Procedure Groups" class="pkg-header">Procedure Groups</h2>
<p class="pkg-empty-section">This section is empty.</p>
</section>
<h2 id="pkg-source-files">Source Files</h2>
<ul>
<li><a href="https://github.com/odin-lang/Odin/tree/master/core/simd/simd.odin">simd.odin</a></li>
</ul>
<h2 id="pkg-generation-information">Generation Information</h2>
<p>Generated with <code>odin version dev-2025-10 (vendor "odin") Windows_amd64 @ 2025-10-10 15:58:35.432097400 +0000 UTC</code></p>
</article>
<div class="col-lg-2 odin-toc-border navbar-light"><div class="sticky-top odin-below-navbar py-3">
<nav id="TableOfContents">
<ul>
<li><a href="#pkg-overview">Overview</a><li><a href="#pkg-Types">Types</a><ul>
<li><a href="#b16x16">b16x16</a></li>
<li><a href="#b16x32">b16x32</a></li>
<li><a href="#b16x8">b16x8</a></li>
<li><a href="#b32x16">b32x16</a></li>
<li><a href="#b32x4">b32x4</a></li>
<li><a href="#b32x8">b32x8</a></li>
<li><a href="#b64x2">b64x2</a></li>
<li><a href="#b64x4">b64x4</a></li>
<li><a href="#b64x8">b64x8</a></li>
<li><a href="#b8x16">b8x16</a></li>
<li><a href="#b8x32">b8x32</a></li>
<li><a href="#b8x64">b8x64</a></li>
<li><a href="#boolx16">boolx16</a></li>
<li><a href="#boolx32">boolx32</a></li>
<li><a href="#boolx64">boolx64</a></li>
<li><a href="#f32x16">f32x16</a></li>
<li><a href="#f32x4">f32x4</a></li>
<li><a href="#f32x8">f32x8</a></li>
<li><a href="#f64x2">f64x2</a></li>
<li><a href="#f64x4">f64x4</a></li>
<li><a href="#f64x8">f64x8</a></li>
<li><a href="#i16x16">i16x16</a></li>
<li><a href="#i16x32">i16x32</a></li>
<li><a href="#i16x8">i16x8</a></li>
<li><a href="#i32x16">i32x16</a></li>
<li><a href="#i32x4">i32x4</a></li>
<li><a href="#i32x8">i32x8</a></li>
<li><a href="#i64x2">i64x2</a></li>
<li><a href="#i64x4">i64x4</a></li>
<li><a href="#i64x8">i64x8</a></li>
<li><a href="#i8x16">i8x16</a></li>
<li><a href="#i8x32">i8x32</a></li>
<li><a href="#i8x64">i8x64</a></li>
<li><a href="#u16x16">u16x16</a></li>
<li><a href="#u16x32">u16x32</a></li>
<li><a href="#u16x8">u16x8</a></li>
<li><a href="#u32x16">u32x16</a></li>
<li><a href="#u32x4">u32x4</a></li>
<li><a href="#u32x8">u32x8</a></li>
<li><a href="#u64x2">u64x2</a></li>
<li><a href="#u64x4">u64x4</a></li>
<li><a href="#u64x8">u64x8</a></li>
<li><a href="#u8x16">u8x16</a></li>
<li><a href="#u8x32">u8x32</a></li>
<li><a href="#u8x64">u8x64</a></li>
</ul>
</li>
<li><a href="#pkg-Constants">Constants</a><ul>
<li><a href="#HAS_HARDWARE_SIMD">HAS_HARDWARE_SIMD</a></li>
</ul>
</li>
<li><a href="#pkg-Procedures">Procedures</a><ul>
<li><a href="#abs">abs</a></li>
<li><a href="#add">add</a></li>
<li><a href="#bit_and">bit_and</a></li>
<li><a href="#bit_and_not">bit_and_not</a></li>
<li><a href="#bit_not">bit_not</a></li>
<li><a href="#bit_or">bit_or</a></li>
<li><a href="#bit_xor">bit_xor</a></li>
<li><a href="#ceil">ceil</a></li>
<li><a href="#clamp">clamp</a></li>
<li><a href="#copysign">copysign</a></li>
<li><a href="#count_leading_zeros">count_leading_zeros</a></li>
<li><a href="#count_ones">count_ones</a></li>
<li><a href="#count_trailing_zeros">count_trailing_zeros</a></li>
<li><a href="#count_zeros">count_zeros</a></li>
<li><a href="#div">div</a></li>
<li><a href="#extract">extract</a></li>
<li><a href="#extract_lsbs">extract_lsbs</a></li>
<li><a href="#extract_msbs">extract_msbs</a></li>
<li><a href="#floor">floor</a></li>
<li><a href="#fma">fma</a></li>
<li><a href="#from_array">from_array</a></li>
<li><a href="#from_slice">from_slice</a></li>
<li><a href="#fused_mul_add">fused_mul_add</a></li>
<li><a href="#gather">gather</a></li>
<li><a href="#indices">indices</a></li>
<li><a href="#lanes_eq">lanes_eq</a></li>
<li><a href="#lanes_ge">lanes_ge</a></li>
<li><a href="#lanes_gt">lanes_gt</a></li>
<li><a href="#lanes_le">lanes_le</a></li>
<li><a href="#lanes_lt">lanes_lt</a></li>
<li><a href="#lanes_ne">lanes_ne</a></li>
<li><a href="#lanes_reverse">lanes_reverse</a></li>
<li><a href="#lanes_rotate_left">lanes_rotate_left</a></li>
<li><a href="#lanes_rotate_right">lanes_rotate_right</a></li>
<li><a href="#masked_compress_store">masked_compress_store</a></li>
<li><a href="#masked_expand_load">masked_expand_load</a></li>
<li><a href="#masked_load">masked_load</a></li>
<li><a href="#masked_store">masked_store</a></li>
<li><a href="#max">max</a></li>
<li><a href="#min">min</a></li>
<li><a href="#mul">mul</a></li>
<li><a href="#nearest">nearest</a></li>
<li><a href="#neg">neg</a></li>
<li><a href="#recip">recip</a></li>
<li><a href="#reduce_add_bisect">reduce_add_bisect</a></li>
<li><a href="#reduce_add_ordered">reduce_add_ordered</a></li>
<li><a href="#reduce_add_pairs">reduce_add_pairs</a></li>
<li><a href="#reduce_all">reduce_all</a></li>
<li><a href="#reduce_and">reduce_and</a></li>
<li><a href="#reduce_any">reduce_any</a></li>
<li><a href="#reduce_max">reduce_max</a></li>
<li><a href="#reduce_min">reduce_min</a></li>
<li><a href="#reduce_mul_bisect">reduce_mul_bisect</a></li>
<li><a href="#reduce_mul_ordered">reduce_mul_ordered</a></li>
<li><a href="#reduce_mul_pairs">reduce_mul_pairs</a></li>
<li><a href="#reduce_or">reduce_or</a></li>
<li><a href="#reduce_xor">reduce_xor</a></li>
<li><a href="#replace">replace</a></li>
<li><a href="#reverse_bits">reverse_bits</a></li>
<li><a href="#runtime_swizzle">runtime_swizzle</a></li>
<li><a href="#saturating_add">saturating_add</a></li>
<li><a href="#saturating_sub">saturating_sub</a></li>
<li><a href="#scatter">scatter</a></li>
<li><a href="#select">select</a></li>
<li><a href="#shl">shl</a></li>
<li><a href="#shl_masked">shl_masked</a></li>
<li><a href="#shr">shr</a></li>
<li><a href="#shr_masked">shr_masked</a></li>
<li><a href="#shuffle">shuffle</a></li>
<li><a href="#signum">signum</a></li>
<li><a href="#sqrt">sqrt</a></li>
<li><a href="#sub">sub</a></li>
<li><a href="#swizzle">swizzle</a></li>
<li><a href="#to_array">to_array</a></li>
<li><a href="#to_array_ptr">to_array_ptr</a></li>
<li><a href="#to_bits">to_bits</a></li>
<li><a href="#trunc">trunc</a></li>
</ul>
</li>
<li><a href="#pkg-source-files">Source Files</a></ul>
</nav>
</div></div>
<script type="text/javascript">var odin_pkg_name = "simd";</script>
</div>

</div>
</main>

<footer class="odin-footer">
	<div class="container pb-5 pt-5">
		<div class="row g-4">
		<div class="col">
		<a class="navbar-brand" href="https://odin-lang.org">
		<img class="mb-3" src="https://odin-lang.org/logo.svg" height="30" alt="Odin"></a>
		<p>
		The Data-Oriented Language for Sane Software Development.
		</p>
		</div>
		<nav class="col-md-auto">
			<h4 class="fw-normal">Resources</h4>
			<ul class="list-unstyled">
			<li><a href="https://odin-lang.org/docs" class="link-light">Docs</a></li>
			<li><a href="https://pkg.odin-lang.org/" class="link-light">Packages</a></li>
			<li><a href="https://odin-lang.org/news" class="link-light">News</a></li>
			</ul>
		</nav>
		<nav class="col-md-auto">
			<h4 class="fw-normal">Community</h4>
			<ul class="list-unstyled">
			<li><a href="https://github.com/odin-lang/Odin" target="_blank" class="link-light">GitHub</a></li>
			<li><a href="https://forum.odin-lang.org" target="_blank" class="link-light">Forum</a></li>
			<li><a href="https://discord.com/invite/sVBPHEv" target="_blank" class="link-light">Discord</a></li>
			<li><a href="https://www.twitch.tv/ginger_bill" target="_blank" class="link-light">Twitch</a></li>
			<li><a href="https://www.youtube.com/channel/UCUSck1dOH7VKmG4lRW7tZXg" target="_blank" class="link-light">YouTube</a></li>
			<li><a href="https://odin-lang.org/showcase" target="_blank" class="link-light">Showcase</a></li>
			</ul>
		</nav>
		<nav class="col-md-auto">
			<h4 class="fw-normal">Contribute</h4>
			<ul class="list-unstyled">
			<li><a href="https://github.com/odin-lang/Odin/issues" target="_blank" class="link-light">Issues</a></li>
			<li><a href="https://www.patreon.com/gingerbill" target="_blank" class="link-light">Donate</a></li>
			</ul>
			</nav>
		</div>
		<div class="mt-4 text-muted">© 2016–2023 Ginger Bill</div>
	</div>
</footer>

<script src="https://odin-lang.org/lib/bootstrap/js/bootstrap.min.js"></script>
<script src="https://odin-lang.org/js/script.js"></script>
<script src="/pkg-data.js"></script>
<script src="/search.js"></script>
</body>
</html>
