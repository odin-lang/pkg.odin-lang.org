<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>package intrinsics - pkg.odin-lang.org</title>	<link rel="icon" href="/favicon.svg">
	<link rel="stylesheet" type="text/css" href="https://odin-lang.org/scss/custom.min.css">
	<link rel=stylesheet href="//odin-lang.org/lib/highlight/styles/github-dark.min.css">
	<script src="//odin-lang.org/lib/highlight/highlight.min.js"></script>

	<script>hljs.registerLanguage("odin",function(a){return{aliases:["odin","odinlang","odin-lang"],keywords:{keyword:"auto_cast bit_set break case cast context continue defer distinct do dynamic else enum fallthrough for foreign if import in map not_in or_else or_return package proc return struct switch transmute type_of typeid union using when where",literal:"true false nil",built_in:"abs align_of cap clamp complex conj expand_to_tuple imag jmag kmag len max min offset_of quaternion real size_of soa_unzip soa_zip swizzle type_info_of type_of typeid_of"},illegal:"</",contains:[a.C_LINE_COMMENT_MODE,a.C_BLOCK_COMMENT_MODE,{className:"string",variants:[a.QUOTE_STRING_MODE,{begin:"'",end:"[^\\\\]'"},{begin:"`",end:"`"}]},{className:"number",variants:[{begin:a.C_NUMBER_RE+"[ijk]",relevance:1},a.C_NUMBER_MODE]}]}})</script>
	<script>hljs.highlightAll()</script>
	<script>
		function OSDarkModeQuery() {
			return window.matchMedia?.("(prefers-color-scheme: dark)");
		}
		function setDarkMode() {
			document.body.classList.add("dark-mode");
			window.localStorage.setItem("theme", "dark");
		}
		function removeDarkMode() {
			document.body.classList.remove("dark-mode");
			window.localStorage.setItem("theme", "light");
		}
		function toggleDarkMode() {
			if (document.body.classList.contains("dark-mode")) removeDarkMode()
			else setDarkMode()
		}
		function syncThemeToOS() {
			if (OSDarkModeQuery().matches) setDarkMode()
			else removeDarkMode()
		}
		document.addEventListener("DOMContentLoaded", () => {
			OSDarkModeQuery().addEventListener("change", syncThemeToOS);
		});
	</script>
	<link rel="stylesheet" type="text/css" href="https://odin-lang.org/css/style.css">

	<link rel="stylesheet" type="text/css" href="/style.css">

	</style>
</head>
<body>
<script>
	const themeSet = window.localStorage.getItem("theme");
	if (themeSet === null) {
		syncThemeToOS();
	} else if (themeSet === "dark") {
		setDarkMode();
	} else if (themeSet === "light") {
		removeDarkMode();
	}
</script>
<header class="sticky-top">
	<nav class="navbar navbar-expand-lg navbar-dark bg-primary odin-menu">
		<div class="container">
			<a class="navbar-brand" href="https://odin-lang.org/">
			<img src="https://odin-lang.org/logo.svg" height="30" alt="Odin"></a>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#odin-navbar-content" aria-controls="odin-navbar-content" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
			<div class="collapse navbar-collapse" id="odin-navbar-content">
			<ul class="navbar-nav ms-md-auto">
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/">Home</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/docs">Docs</a></li>
				<li class="nav-item"><a class="nav-link active" href="/">Packages</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/news">News</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/showcase">Showcase</a></li>
				<li class="nav-item"><a class="nav-link" href="https://forum.odin-lang.org">Forum</a></li>
				<li class="nav-item"><a class="nav-link" href="https://odin-lang.org/community">Community</a></li>
				<li class="nav-item"><a class="nav-link" href="https://github.com/odin-lang/Odin" target="_blank">GitHub</a></li>
				<li class="nav-item">
					<a
						class="nav-link btn-dark-mode"
						onclick="toggleDarkMode();"
						title="Toggle Light/Dark Mode"
					>
						<span class="dark-mode-appearance">Appearance:</span>
						<svg fill="white" id="dark-mode-icon" viewBox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"/></svg>
						<svg fill="white" id="light-mode-icon" viewBox="0 0 16 16">
						  <path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8M8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0m0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13m8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5M3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8m10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0m-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0m9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707M4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708"/>
						</svg>
					</button>
					</a>
				</li>
			</ul>
		</div>
		</div>
	</nav>
</header>
<main>
<div class="container full-width">
<div class="row odin-main" id="pkg">
<nav id="pkg-sidebar" class="col-lg-2 odin-sidebar-border navbar-light sticky-top odin-below-navbar">
<div class="py-3">
<h4><a style="text-transform: capitalize; color: inherit;" href="/base">base Library</a></h4>
<ul>
<li class="nav-item"><a href="/base/builtin">builtin</a></li>
<li class="nav-item"><a class="active" href="/base/intrinsics">intrinsics</a></li>
<li class="nav-item"><a href="/base/runtime">runtime</a></li>
<li class="nav-item"><a href="/base/sanitizer">sanitizer</a></li>
</ul>
</div>
</nav>
<article class="col-lg-8 p-4 documentation odin-article">
<nav class="pkg-breadcrumb" aria-label="breadcrumb">
<ol class="breadcrumb">
<li class="breadcrumb-item"><a href="/base">base</a></li>
<li class="breadcrumb-item">intrinsics</li>
</ol>
</nav>
<h1>package base:intrinsics<div class="doc-source"><a href="https://github.com/odin-lang/Odin/tree/master/base/intrinsics"><em>Source</em></a></div></h1>

		<div class="odin-search-wrapper">
			<input type="search" id="odin-search" class="odin-search-package" autocomplete="off" spellcheck="false" placeholder="Fuzzy Search...">
			<div class="odin-search-shortcut">
				<div class="odin-search-key key-macos">âŒ˜K</div>
				<div class="odin-search-key key-windows">Ctrl+K</div>
				<span class="odin-search-or">or</span>
				<div class="odin-search-key">/</div>
			</div>
		</div>
	
<div id="odin-search-info">
<div id="odin-search-time"></div>

		<div id="odin-search-options">
			<input type="checkbox" id="odin-search-filter" name="odin-search-filter">
			<label for="odin-search-filter">Filter Results</label>
		</div>
</div>
<ul id="odin-search-results"></ul>
<div id="pkg-top">
<h2>Overview</h2>
<div id="pkg-overview">
<p>package intrinsics provides documentation for Odin's compiler-level intrinsics.</p>
</div>
<div id="pkg-index">
<h2>Index</h2>
<div>
<details class="doc-index" id="doc-index-Constants" aria-labelledby="#doc-index-Constants-header">
<summary id="#doc-index-Constants-header">
Constants (0)</summary>
<p class="pkg-empty-section">This section is empty.</p>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Types" aria-labelledby="#doc-index-Types-header">
<summary id="#doc-index-Types-header">
Types (7)</summary>
<ul>
<li><a href="#Atomic_Memory_Order">Atomic_Memory_Order</a></li>
<li><a href="#objc_object">objc_object</a></li>
<li><a href="#objc_selector">objc_selector</a></li>
<li><a href="#objc_class">objc_class</a></li>
<li><a href="#objc_id">objc_id</a></li>
<li><a href="#objc_SEL">objc_SEL</a></li>
<li><a href="#objc_Class">objc_Class</a></li>
</ul>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Procedures" aria-labelledby="#doc-index-Procedures-header">
<summary id="#doc-index-Procedures-header">
Procedures (220)</summary>
<ul>
<li><a href="#transpose">transpose</a></li>
<li><a href="#outer_product">outer_product</a></li>
<li><a href="#hadamard_product">hadamard_product</a></li>
<li><a href="#matrix_flatten">matrix_flatten</a></li>
<li><a href="#soa_struct">soa_struct</a></li>
<li><a href="#volatile_load">volatile_load</a></li>
<li><a href="#volatile_store">volatile_store</a></li>
<li><a href="#non_temporal_load">non_temporal_load</a></li>
<li><a href="#non_temporal_store">non_temporal_store</a></li>
<li><a href="#debug_trap">debug_trap</a></li>
<li><a href="#trap">trap</a></li>
<li><a href="#alloca">alloca</a></li>
<li><a href="#cpu_relax">cpu_relax</a></li>
<li><a href="#read_cycle_counter">read_cycle_counter</a></li>
<li><a href="#read_cycle_counter_frequency">read_cycle_counter_frequency</a></li>
<li><a href="#count_ones">count_ones</a></li>
<li><a href="#count_zeros">count_zeros</a></li>
<li><a href="#count_trailing_zeros">count_trailing_zeros</a></li>
<li><a href="#count_leading_zeros">count_leading_zeros</a></li>
<li><a href="#reverse_bits">reverse_bits</a></li>
<li><a href="#byte_swap">byte_swap</a></li>
<li><a href="#overflow_add">overflow_add</a></li>
<li><a href="#overflow_sub">overflow_sub</a></li>
<li><a href="#overflow_mul">overflow_mul</a></li>
<li><a href="#saturating_add">saturating_add</a></li>
<li><a href="#saturating_sub">saturating_sub</a></li>
<li><a href="#sqrt">sqrt</a></li>
<li><a href="#fused_mul_add">fused_mul_add</a></li>
<li><a href="#mem_copy">mem_copy</a></li>
<li><a href="#mem_copy_non_overlapping">mem_copy_non_overlapping</a></li>
<li><a href="#mem_zero">mem_zero</a></li>
<li><a href="#mem_zero_volatile">mem_zero_volatile</a></li>
<li><a href="#ptr_offset">ptr_offset</a></li>
<li><a href="#ptr_sub">ptr_sub</a></li>
<li><a href="#unaligned_load">unaligned_load</a></li>
<li><a href="#unaligned_store">unaligned_store</a></li>
<li><a href="#fixed_point_mul">fixed_point_mul</a></li>
<li><a href="#fixed_point_div">fixed_point_div</a></li>
<li><a href="#fixed_point_mul_sat">fixed_point_mul_sat</a></li>
<li><a href="#fixed_point_div_sat">fixed_point_div_sat</a></li>
<li><a href="#prefetch_read_instruction">prefetch_read_instruction</a></li>
<li><a href="#prefetch_read_data">prefetch_read_data</a></li>
<li><a href="#prefetch_write_instruction">prefetch_write_instruction</a></li>
<li><a href="#prefetch_write_data">prefetch_write_data</a></li>
<li><a href="#expect">expect</a></li>
<li><a href="#syscall">syscall</a></li>
<li><a href="#syscall_bsd">syscall_bsd</a></li>
<li><a href="#atomic_type_is_lock_free">atomic_type_is_lock_free</a></li>
<li><a href="#atomic_thread_fence">atomic_thread_fence</a></li>
<li><a href="#atomic_signal_fence">atomic_signal_fence</a></li>
<li><a href="#atomic_store">atomic_store</a></li>
<li><a href="#atomic_store_explicit">atomic_store_explicit</a></li>
<li><a href="#atomic_load">atomic_load</a></li>
<li><a href="#atomic_load_explicit">atomic_load_explicit</a></li>
<li><a href="#atomic_add">atomic_add</a></li>
<li><a href="#atomic_add_explicit">atomic_add_explicit</a></li>
<li><a href="#atomic_sub">atomic_sub</a></li>
<li><a href="#atomic_sub_explicit">atomic_sub_explicit</a></li>
<li><a href="#atomic_and">atomic_and</a></li>
<li><a href="#atomic_and_explicit">atomic_and_explicit</a></li>
<li><a href="#atomic_nand">atomic_nand</a></li>
<li><a href="#atomic_nand_explicit">atomic_nand_explicit</a></li>
<li><a href="#atomic_or">atomic_or</a></li>
<li><a href="#atomic_or_explicit">atomic_or_explicit</a></li>
<li><a href="#atomic_xor">atomic_xor</a></li>
<li><a href="#atomic_xor_explicit">atomic_xor_explicit</a></li>
<li><a href="#atomic_exchange">atomic_exchange</a></li>
<li><a href="#atomic_exchange_explicit">atomic_exchange_explicit</a></li>
<li><a href="#atomic_compare_exchange_strong">atomic_compare_exchange_strong</a></li>
<li><a href="#atomic_compare_exchange_strong_explicit">atomic_compare_exchange_strong_explicit</a></li>
<li><a href="#atomic_compare_exchange_weak">atomic_compare_exchange_weak</a></li>
<li><a href="#atomic_compare_exchange_weak_explicit">atomic_compare_exchange_weak_explicit</a></li>
<li><a href="#type_base_type">type_base_type</a></li>
<li><a href="#type_core_type">type_core_type</a></li>
<li><a href="#type_elem_type">type_elem_type</a></li>
<li><a href="#type_is_boolean">type_is_boolean</a></li>
<li><a href="#type_is_integer">type_is_integer</a></li>
<li><a href="#type_is_rune">type_is_rune</a></li>
<li><a href="#type_is_float">type_is_float</a></li>
<li><a href="#type_is_complex">type_is_complex</a></li>
<li><a href="#type_is_quaternion">type_is_quaternion</a></li>
<li><a href="#type_is_typeid">type_is_typeid</a></li>
<li><a href="#type_is_any">type_is_any</a></li>
<li><a href="#type_is_string">type_is_string</a></li>
<li><a href="#type_is_string16">type_is_string16</a></li>
<li><a href="#type_is_cstring">type_is_cstring</a></li>
<li><a href="#type_is_cstring16">type_is_cstring16</a></li>
<li><a href="#type_is_endian_platform">type_is_endian_platform</a></li>
<li><a href="#type_is_endian_little">type_is_endian_little</a></li>
<li><a href="#type_is_endian_big">type_is_endian_big</a></li>
<li><a href="#type_is_unsigned">type_is_unsigned</a></li>
<li><a href="#type_is_numeric">type_is_numeric</a></li>
<li><a href="#type_is_ordered">type_is_ordered</a></li>
<li><a href="#type_is_ordered_numeric">type_is_ordered_numeric</a></li>
<li><a href="#type_is_indexable">type_is_indexable</a></li>
<li><a href="#type_is_sliceable">type_is_sliceable</a></li>
<li><a href="#type_is_comparable">type_is_comparable</a></li>
<li><a href="#type_is_simple_compare">type_is_simple_compare</a></li>
<li><a href="#type_is_nearly_simple_compare">type_is_nearly_simple_compare</a></li>
<li><a href="#type_is_dereferenceable">type_is_dereferenceable</a></li>
<li><a href="#type_is_valid_map_key">type_is_valid_map_key</a></li>
<li><a href="#type_is_valid_matrix_elements">type_is_valid_matrix_elements</a></li>
<li><a href="#type_is_named">type_is_named</a></li>
<li><a href="#type_is_pointer">type_is_pointer</a></li>
<li><a href="#type_is_multi_pointer">type_is_multi_pointer</a></li>
<li><a href="#type_is_array">type_is_array</a></li>
<li><a href="#type_is_enumerated_array">type_is_enumerated_array</a></li>
<li><a href="#type_is_slice">type_is_slice</a></li>
<li><a href="#type_is_dynamic_array">type_is_dynamic_array</a></li>
<li><a href="#type_is_map">type_is_map</a></li>
<li><a href="#type_is_struct">type_is_struct</a></li>
<li><a href="#type_is_union">type_is_union</a></li>
<li><a href="#type_is_enum">type_is_enum</a></li>
<li><a href="#type_is_proc">type_is_proc</a></li>
<li><a href="#type_is_bit_set">type_is_bit_set</a></li>
<li><a href="#type_is_simd_vector">type_is_simd_vector</a></li>
<li><a href="#type_is_matrix">type_is_matrix</a></li>
<li><a href="#type_is_raw_union">type_is_raw_union</a></li>
<li><a href="#type_has_nil">type_has_nil</a></li>
<li><a href="#type_is_matrix_row_major">type_is_matrix_row_major</a></li>
<li><a href="#type_is_matrix_column_major">type_is_matrix_column_major</a></li>
<li><a href="#type_is_specialization_of">type_is_specialization_of</a></li>
<li><a href="#type_is_variant_of">type_is_variant_of</a></li>
<li><a href="#type_union_tag_type">type_union_tag_type</a></li>
<li><a href="#type_union_tag_offset">type_union_tag_offset</a></li>
<li><a href="#type_union_base_tag_value">type_union_base_tag_value</a></li>
<li><a href="#type_union_variant_count">type_union_variant_count</a></li>
<li><a href="#type_variant_type_of">type_variant_type_of</a></li>
<li><a href="#type_variant_index_of">type_variant_index_of</a></li>
<li><a href="#type_bit_set_elem_type">type_bit_set_elem_type</a></li>
<li><a href="#type_bit_set_underlying_type">type_bit_set_underlying_type</a></li>
<li><a href="#type_has_field">type_has_field</a></li>
<li><a href="#type_field_type">type_field_type</a></li>
<li><a href="#type_proc_parameter_count">type_proc_parameter_count</a></li>
<li><a href="#type_proc_return_count">type_proc_return_count</a></li>
<li><a href="#type_proc_parameter_type">type_proc_parameter_type</a></li>
<li><a href="#type_proc_return_type">type_proc_return_type</a></li>
<li><a href="#type_struct_field_count">type_struct_field_count</a></li>
<li><a href="#type_struct_has_implicit_padding">type_struct_has_implicit_padding</a></li>
<li><a href="#type_polymorphic_record_parameter_count">type_polymorphic_record_parameter_count</a></li>
<li><a href="#type_polymorphic_record_parameter_value">type_polymorphic_record_parameter_value</a></li>
<li><a href="#type_is_specialized_polymorphic_record">type_is_specialized_polymorphic_record</a></li>
<li><a href="#type_is_unspecialized_polymorphic_record">type_is_unspecialized_polymorphic_record</a></li>
<li><a href="#type_is_subtype_of">type_is_subtype_of</a></li>
<li><a href="#type_field_index_of">type_field_index_of</a></li>
<li><a href="#type_equal_proc">type_equal_proc</a></li>
<li><a href="#type_hasher_proc">type_hasher_proc</a></li>
<li><a href="#type_map_info">type_map_info</a></li>
<li><a href="#type_map_cell_info">type_map_cell_info</a></li>
<li><a href="#type_convert_variants_to_pointers">type_convert_variants_to_pointers</a></li>
<li><a href="#type_merge">type_merge</a></li>
<li><a href="#constant_utf16_cstring">constant_utf16_cstring</a></li>
<li><a href="#constant_log2">constant_log2</a></li>
<li><a href="#simd_add">simd_add</a></li>
<li><a href="#simd_sub">simd_sub</a></li>
<li><a href="#simd_mul">simd_mul</a></li>
<li><a href="#simd_div">simd_div</a></li>
<li><a href="#simd_saturating_add">simd_saturating_add</a></li>
<li><a href="#simd_saturating_sub">simd_saturating_sub</a></li>
<li><a href="#simd_shl">simd_shl</a></li>
<li><a href="#simd_shr">simd_shr</a></li>
<li><a href="#simd_shl_masked">simd_shl_masked</a></li>
<li><a href="#simd_shr_masked">simd_shr_masked</a></li>
<li><a href="#simd_bit_and">simd_bit_and</a></li>
<li><a href="#simd_bit_or">simd_bit_or</a></li>
<li><a href="#simd_bit_xor">simd_bit_xor</a></li>
<li><a href="#simd_bit_and_not">simd_bit_and_not</a></li>
<li><a href="#simd_neg">simd_neg</a></li>
<li><a href="#simd_abs">simd_abs</a></li>
<li><a href="#simd_min">simd_min</a></li>
<li><a href="#simd_max">simd_max</a></li>
<li><a href="#simd_clamp">simd_clamp</a></li>
<li><a href="#simd_lanes_eq">simd_lanes_eq</a></li>
<li><a href="#simd_lanes_ne">simd_lanes_ne</a></li>
<li><a href="#simd_lanes_lt">simd_lanes_lt</a></li>
<li><a href="#simd_lanes_le">simd_lanes_le</a></li>
<li><a href="#simd_lanes_gt">simd_lanes_gt</a></li>
<li><a href="#simd_lanes_ge">simd_lanes_ge</a></li>
<li><a href="#simd_extract">simd_extract</a></li>
<li><a href="#simd_replace">simd_replace</a></li>
<li><a href="#simd_reduce_add_ordered">simd_reduce_add_ordered</a></li>
<li><a href="#simd_reduce_mul_ordered">simd_reduce_mul_ordered</a></li>
<li><a href="#simd_reduce_min">simd_reduce_min</a></li>
<li><a href="#simd_reduce_max">simd_reduce_max</a></li>
<li><a href="#simd_reduce_and">simd_reduce_and</a></li>
<li><a href="#simd_reduce_or">simd_reduce_or</a></li>
<li><a href="#simd_reduce_xor">simd_reduce_xor</a></li>
<li><a href="#simd_reduce_any">simd_reduce_any</a></li>
<li><a href="#simd_reduce_all">simd_reduce_all</a></li>
<li><a href="#simd_extract_msbs">simd_extract_msbs</a></li>
<li><a href="#simd_extract_lsbs">simd_extract_lsbs</a></li>
<li><a href="#simd_gather">simd_gather</a></li>
<li><a href="#simd_scatter">simd_scatter</a></li>
<li><a href="#simd_masked_load">simd_masked_load</a></li>
<li><a href="#simd_masked_store">simd_masked_store</a></li>
<li><a href="#simd_masked_expand_load">simd_masked_expand_load</a></li>
<li><a href="#simd_masked_compress_store">simd_masked_compress_store</a></li>
<li><a href="#simd_shuffle">simd_shuffle</a></li>
<li><a href="#simd_select">simd_select</a></li>
<li><a href="#simd_ceil">simd_ceil</a></li>
<li><a href="#simd_floor">simd_floor</a></li>
<li><a href="#simd_trunc">simd_trunc</a></li>
<li><a href="#simd_nearest">simd_nearest</a></li>
<li><a href="#simd_to_bits">simd_to_bits</a></li>
<li><a href="#simd_lanes_reverse">simd_lanes_reverse</a></li>
<li><a href="#simd_lanes_rotate_left">simd_lanes_rotate_left</a></li>
<li><a href="#simd_lanes_rotate_right">simd_lanes_rotate_right</a></li>
<li><a href="#has_target_feature">has_target_feature</a></li>
<li><a href="#procedure_of">procedure_of</a></li>
<li><a href="#wasm_memory_grow">wasm_memory_grow</a></li>
<li><a href="#wasm_memory_size">wasm_memory_size</a></li>
<li><a href="#wasm_memory_atomic_wait32">wasm_memory_atomic_wait32</a></li>
<li><a href="#wasm_memory_atomic_notify32">wasm_memory_atomic_notify32</a></li>
<li><a href="#x86_cpuid">x86_cpuid</a></li>
<li><a href="#x86_xgetbv">x86_xgetbv</a></li>
<li><a href="#objc_find_selector">objc_find_selector</a></li>
<li><a href="#objc_register_selector">objc_register_selector</a></li>
<li><a href="#objc_find_class">objc_find_class</a></li>
<li><a href="#objc_register_class">objc_register_class</a></li>
<li><a href="#valgrind_client_request">valgrind_client_request</a></li>
</ul>
</details>
</div>
<div>
<details class="doc-index" id="doc-index-Procedure Groups" aria-labelledby="#doc-index-Procedure Groups-header">
<summary id="#doc-index-Procedure Groups-header">
Procedure Groups (0)</summary>
<p class="pkg-empty-section">This section is empty.</p>
</details>
</div>
</div>
</div>
<section class="documentation">
<h2 id="pkg-Constants" class="pkg-header">Constants</h2>
<h2 id="pkg-Types" class="pkg-header">Types</h2>
<div class="pkg-entity">
<h3 id="Atomic_Memory_Order"><span><a class="doc-id-link" href="#Atomic_Memory_Order">Atomic_Memory_Order<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">Atomic_Memory_Order :: <span class="keyword-type">enum</span> {
	Relaxed = 0, <span class="comment">// Unordered</span>
	Consume = 1, <span class="comment">// Monotonic</span>
	Acquire = 2,
	Release = 3,
	Acq_Rel = 4,
	Seq_Cst = 5,
}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>An enumeration of atomic memory orderings used by the <code>atomic_*_explicit</code> intrinsics that determines which atomic instructions on the same address they synchronize with.This follows the same memory model as C11/C++11.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="objc_object"><span><a class="doc-id-link" href="#objc_object">objc_object<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">objc_object :: <span class="keyword-type">struct</span> {}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Darwin targets only
Represents an Objective-C <code>object</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="objc_selector"><span><a class="doc-id-link" href="#objc_selector">objc_selector<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">objc_selector :: <span class="keyword-type">struct</span> {}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Darwin targets only
Represents an Objective-C <code>selector</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="objc_class"><span><a class="doc-id-link" href="#objc_class">objc_class<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">objc_class :: <span class="keyword-type">struct</span> {}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Darwin targets only
Represents an Objective-C <code>class</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="objc_id"><span><a class="doc-id-link" href="#objc_id">objc_id<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">objc_id :: ^<a href="/base/intrinsics#objc_object"><span class="code-typename">objc_object</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Darwin targets only
Represents an Objective-C <code>id</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="objc_SEL"><span><a class="doc-id-link" href="#objc_SEL">objc_SEL<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">objc_SEL :: ^<a href="/base/intrinsics#objc_selector"><span class="code-typename">objc_selector</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Darwin targets only
Represents an Objective-C <code>SEL</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="objc_Class"><span><a class="doc-id-link" href="#objc_Class">objc_Class<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">objc_Class :: ^<a href="/base/intrinsics#objc_class"><span class="code-typename">objc_class</span></a></pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Darwin targets only
Represents an Objective-C <code>Class</code> type.</p>
</details>
</div>
<h2 id="pkg-Procedures" class="pkg-header">Procedures</h2>
<div class="pkg-entity">
<h3 id="transpose"><span><a class="doc-id-link" href="#transpose">transpose<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">transpose :: <span class="keyword-type">proc</span>(m: $M/<span class="keyword-type">matrix</span>[$R, $C]$E) -> <span class="keyword-type">matrix</span>[C, R]E {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="outer_product"><span><a class="doc-id-link" href="#outer_product">outer_product<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">outer_product :: <span class="keyword-type">proc</span>(a: $A/[$X]$E, b: $B/[$Y]E) -> <span class="keyword-type">matrix</span>[X, Y]E {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="hadamard_product"><span><a class="doc-id-link" href="#hadamard_product">hadamard_product<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">hadamard_product :: <span class="keyword-type">proc</span>(a, b: $T/<span class="keyword-type">matrix</span>[$R, $C]$E) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="matrix_flatten"><span><a class="doc-id-link" href="#matrix_flatten">matrix_flatten<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">matrix_flatten :: <span class="keyword-type">proc</span>(m: $T/<span class="keyword-type">matrix</span>[$R, $C]$E) -> [R*C]E {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="soa_struct"><span><a class="doc-id-link" href="#soa_struct">soa_struct<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">soa_struct :: <span class="keyword-type">proc</span>($N: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>, $T: <span class="keyword-type">typeid</span>) -> type/<span class="directive">#soa</span>[N]T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>A call-like way to construct an #soa struct. Possibly to be deprecated in the future.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="volatile_load"><span><a class="doc-id-link" href="#volatile_load">volatile_load<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">volatile_load :: <span class="keyword-type">proc</span>(dst: ^$T) -> T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Tells the optimizing backend of a compiler to not change the number of 'volatile' operations nor change their order of execution relative to other 'volatile' operations. Optimizers are allowed to change the order of volatile operations relative to non-volatile operations.</p>
<p>Note: This has nothing to do with Java's 'volatile' and has no cross-thread synchronization behaviour. Use atomics if this behaviour is wanted.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="volatile_store"><span><a class="doc-id-link" href="#volatile_store">volatile_store<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">volatile_store :: <span class="keyword-type">proc</span>(dst: ^$T, val: T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Tells the optimizing backend of a compiler to not change the number of 'volatile' operations nor change their order of execution relative to other 'volatile' operations. Optimizers are allowed to change the order of volatile operations relative to non-volatile operations.</p>
<p>Note: This has nothing to do with Java's 'volatile' and has no cross-thread synchronization behaviour. Use atomics if this behaviour is wanted.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="non_temporal_load"><span><a class="doc-id-link" href="#non_temporal_load">non_temporal_load<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">non_temporal_load :: <span class="keyword-type">proc</span>(dst: ^$T) -> T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Tells the code generator of a compiler that this operation is not expected to be reused in the cache. The code generator may select special instructions to save cache bandwidth (e.g. on x86, <code>movnt</code> instruct might be used).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="non_temporal_store"><span><a class="doc-id-link" href="#non_temporal_store">non_temporal_store<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">non_temporal_store :: <span class="keyword-type">proc</span>(dst: ^$T, val: T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Tells the code generator of a compiler that this operation is not expected to be reused in the cache. The code generator may select special instructions to save cache bandwidth (e.g. on x86, <code>movnt</code> instruct might be used).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="debug_trap"><span><a class="doc-id-link" href="#debug_trap">debug_trap<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">debug_trap :: <span class="keyword-type">proc</span>() {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>A call intended to cause an execution trap with the intention of requesting a debugger's attention.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="trap"><span><a class="doc-id-link" href="#trap">trap<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">trap :: <span class="keyword-type">proc</span>() -> ! {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Lowered to a target dependent trap instruction.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="alloca"><span><a class="doc-id-link" href="#alloca">alloca<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">alloca :: <span class="keyword-type">proc</span>(size, align: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> [^]byte {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>A procedure that allocates <code>size</code> bytes of space in the stack frame of the caller, aligned to <code>align</code> bytes. This temporary space is automatically freed when the procedure that called <code>alloca</code> returns to its caller.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="cpu_relax"><span><a class="doc-id-link" href="#cpu_relax">cpu_relax<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">cpu_relax :: <span class="keyword-type">proc</span>() {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>On i386/amd64, it should map to the <code>pause</code> instruction. On arm64, it should map to <code>isb</code> instruction (see https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8258604 for more information).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="read_cycle_counter"><span><a class="doc-id-link" href="#read_cycle_counter">read_cycle_counter<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">read_cycle_counter :: <span class="keyword-type">proc</span>() -> <a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>This provides access to the cycle counter register (or similar low latency, high accuracy clocks) on the targets that support it. On i386/amd64, it should map to the <code>rdtsc</code> instruction. On arm64, it should map to the <code>cntvct_el0</code> instruction.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="read_cycle_counter_frequency"><span><a class="doc-id-link" href="#read_cycle_counter_frequency">read_cycle_counter_frequency<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">read_cycle_counter_frequency :: <span class="keyword-type">proc</span>() -> <a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>This provides access to the frequency that the cycle counter register (or similar low latency, high accuracy clocks) uses on the targets that support it.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="count_ones"><span><a class="doc-id-link" href="#count_ones">count_ones<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">count_ones :: <span class="keyword-type">proc</span>(x: $T) -> T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) || <a href="/base/intrinsics#type_is_simd_vector"><span class="code-procedure">type_is_simd_vector</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Counts the number of set bits (<code>1</code>s).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="count_zeros"><span><a class="doc-id-link" href="#count_zeros">count_zeros<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">count_zeros :: <span class="keyword-type">proc</span>(x: $T) -> T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) || <a href="/base/intrinsics#type_is_simd_vector"><span class="code-procedure">type_is_simd_vector</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Counts the number of unset bits (<code>0</code>s).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="count_trailing_zeros"><span><a class="doc-id-link" href="#count_trailing_zeros">count_trailing_zeros<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">count_trailing_zeros :: <span class="keyword-type">proc</span>(x: $T) -> T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) || <a href="/base/intrinsics#type_is_simd_vector"><span class="code-procedure">type_is_simd_vector</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Counts the number of trailing unset bits (<code>0</code>s) until a set bit (<code>1</code>) is seen or all bits have been counted.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="count_leading_zeros"><span><a class="doc-id-link" href="#count_leading_zeros">count_leading_zeros<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">count_leading_zeros :: <span class="keyword-type">proc</span>(x: $T) -> T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) || <a href="/base/intrinsics#type_is_simd_vector"><span class="code-procedure">type_is_simd_vector</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Counts the number of leading unset bits (<code>0</code>s) until a set bit (<code>1</code>) is seen or all bits have been counted.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="reverse_bits"><span><a class="doc-id-link" href="#reverse_bits">reverse_bits<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">reverse_bits :: <span class="keyword-type">proc</span>(x: $T) -> T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) || <a href="/base/intrinsics#type_is_simd_vector"><span class="code-procedure">type_is_simd_vector</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reverses the bits from ascending order to descending order e.g. 0b01110101 -&gt; 0b10101110</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="byte_swap"><span><a class="doc-id-link" href="#byte_swap">byte_swap<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">byte_swap :: <span class="keyword-type">proc</span>(x: $T) -> T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) || <a href="/base/intrinsics#type_is_float"><span class="code-procedure">type_is_float</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Reverses the bytes from ascending order to descending order e.g. 0xfe_ed_01_12 -&gt; `0x12_01_ed_fe</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="overflow_add"><span><a class="doc-id-link" href="#overflow_add">overflow_add<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">overflow_add :: <span class="keyword-type">proc</span>(lhs, rhs: $T) -> (T, <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) <span class="directive">#optional_ok</span> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Performs an "add" operation with an overflow check. The second return value will be true if an overflow occurs.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="overflow_sub"><span><a class="doc-id-link" href="#overflow_sub">overflow_sub<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">overflow_sub :: <span class="keyword-type">proc</span>(lhs, rhs: $T) -> (T, <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) <span class="directive">#optional_ok</span> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Performs a "subtract" operation with an overflow check. The second return value will be true if an overflow occurs.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="overflow_mul"><span><a class="doc-id-link" href="#overflow_mul">overflow_mul<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">overflow_mul :: <span class="keyword-type">proc</span>(lhs, rhs: $T) -> (T, <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) <span class="directive">#optional_ok</span> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Performs a "multiply" operation with an overflow check. The second return value will be true if an overflow occurs.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="saturating_add"><span><a class="doc-id-link" href="#saturating_add">saturating_add<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">saturating_add :: <span class="keyword-type">proc</span>(lhs, rhs: $T) -> T -> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Performs a saturating "add" operation, where the return value is clamped between <code>min(T)</code> and <code>max(T)</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="saturating_sub"><span><a class="doc-id-link" href="#saturating_sub">saturating_sub<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">saturating_sub :: <span class="keyword-type">proc</span>(lhs, rhs: $T) -> T -> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Performs a saturating "subtract" operation, where the return value is clamped between <code>min(T)</code> and <code>max(T)</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="sqrt"><span><a class="doc-id-link" href="#sqrt">sqrt<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">sqrt :: <span class="keyword-type">proc</span>(x: $T) -> T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_float"><span class="code-procedure">type_is_float</span></a>(T) || (<a href="/base/intrinsics#type_is_simd_vector"><span class="code-procedure">type_is_simd_vector</span></a>(T) && <a href="/base/intrinsics#type_is_float"><span class="code-procedure">type_is_float</span></a>(type_elem_type(T))) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the square root of a value. If the input value is negative, this is platform defined behaviour.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="fused_mul_add"><span><a class="doc-id-link" href="#fused_mul_add">fused_mul_add<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">fused_mul_add :: <span class="keyword-type">proc</span>(a, b, c: $T) -> T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_float"><span class="code-procedure">type_is_float</span></a>(T) || (<a href="/base/intrinsics#type_is_simd_vector"><span class="code-procedure">type_is_simd_vector</span></a>(T) && <a href="/base/intrinsics#type_is_float"><span class="code-procedure">type_is_float</span></a>(type_elem_type(T))) {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="mem_copy"><span><a class="doc-id-link" href="#mem_copy">mem_copy<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">mem_copy :: <span class="keyword-type">proc</span>(dst, src: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Copies a block of memory from the <code>src</code> location to the <code>dst</code> location but assumes that the memory ranges could be overlapping. It is equivalent to C's <code>memmove</code>, but unlike the C's libc procedure, it does not return value.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="mem_copy_non_overlapping"><span><a class="doc-id-link" href="#mem_copy_non_overlapping">mem_copy_non_overlapping<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">mem_copy_non_overlapping :: <span class="keyword-type">proc</span>(dst, src: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Copies a block of memory from the <code>src</code> location to the <code>dst</code> location but it does not assume the memory ranges could be overlapping. It is equivalent to C's <code>memcpy</code>, but unlike the C's libc procedure, it does not return value.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="mem_zero"><span><a class="doc-id-link" href="#mem_zero">mem_zero<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">mem_zero :: <span class="keyword-type">proc</span>(ptr: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Zeroes a block of memory at the <code>ptr</code> location for <code>len</code> bytes.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="mem_zero_volatile"><span><a class="doc-id-link" href="#mem_zero_volatile">mem_zero_volatile<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">mem_zero_volatile :: <span class="keyword-type">proc</span>(ptr: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, len: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Zeroes a block of memory at the <code>ptr</code> location for <code>len</code> bytes with volatile semantics.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="ptr_offset"><span><a class="doc-id-link" href="#ptr_offset">ptr_offset<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">ptr_offset :: <span class="keyword-type">proc</span>(ptr: ^$T, offset: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> ^T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Prefer using [^]T operations if possible. e.g. <code>ptr[offset:]</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="ptr_sub"><span><a class="doc-id-link" href="#ptr_sub">ptr_sub<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">ptr_sub :: <span class="keyword-type">proc</span>(a, b: ^$T) -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Equivalent to <code>int(uintptr(a) - uintptr(b)) / size_of(T)</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="unaligned_load"><span><a class="doc-id-link" href="#unaligned_load">unaligned_load<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">unaligned_load :: <span class="keyword-type">proc</span>(src: ^$T) -> T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Performs a load on an unaligned value <code>src</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="unaligned_store"><span><a class="doc-id-link" href="#unaligned_store">unaligned_store<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">unaligned_store :: <span class="keyword-type">proc</span>(dst: ^$T, val: T) -> T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Performs a store on an unaligned value <code>dst</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="fixed_point_mul"><span><a class="doc-id-link" href="#fixed_point_mul">fixed_point_mul<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">fixed_point_mul :: <span class="keyword-type">proc</span>(lhs, rhs: $T, <span class="directive">#const</span> scale: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>) -> T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>A fixed point number represents a real data type for a number that has a fixed number of digits after a radix point. The number of digits after the radix point is referred to as <code>scale</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="fixed_point_div"><span><a class="doc-id-link" href="#fixed_point_div">fixed_point_div<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">fixed_point_div :: <span class="keyword-type">proc</span>(lhs, rhs: $T, <span class="directive">#const</span> scale: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>) -> T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>A fixed point number represents a real data type for a number that has a fixed number of digits after a radix point. The number of digits after the radix point is referred to as <code>scale</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="fixed_point_mul_sat"><span><a class="doc-id-link" href="#fixed_point_mul_sat">fixed_point_mul_sat<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">fixed_point_mul_sat :: <span class="keyword-type">proc</span>(lhs, rhs: $T, <span class="directive">#const</span> scale: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>) -> T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>A fixed point number represents a real data type for a number that has a fixed number of digits after a radix point. The number of digits after the radix point is referred to as <code>scale</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="fixed_point_div_sat"><span><a class="doc-id-link" href="#fixed_point_div_sat">fixed_point_div_sat<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">fixed_point_div_sat :: <span class="keyword-type">proc</span>(lhs, rhs: $T, <span class="directive">#const</span> scale: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>) -> T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>A fixed point number represents a real data type for a number that has a fixed number of digits after a radix point. The number of digits after the radix point is referred to as <code>scale</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="prefetch_read_instruction"><span><a class="doc-id-link" href="#prefetch_read_instruction">prefetch_read_instruction<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">prefetch_read_instruction :: <span class="keyword-type">proc</span>(address: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, <span class="directive">#const</span> locality: <a href="/base/builtin#i32"><span class="doc-builtin">i32</span></a> <span class="comment">/* 0..=3 */</span>) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>The <code>prefetch_*</code> intrinsic are a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no affect on the behaviour of the program but can change its performance characteristics.</p>
<p>The <code>locality</code> parameter must be a constant integer, and its temporal locality value ranges from <code>0</code> (no locality) to <code>3</code> (extremely local, keep in cache).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="prefetch_read_data"><span><a class="doc-id-link" href="#prefetch_read_data">prefetch_read_data<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">prefetch_read_data :: <span class="keyword-type">proc</span>(address: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, <span class="directive">#const</span> locality: <a href="/base/builtin#i32"><span class="doc-builtin">i32</span></a> <span class="comment">/* 0..=3 */</span>) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>The <code>prefetch_*</code> intrinsic are a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no affect on the behaviour of the program but can change its performance characteristics.</p>
<p>The <code>locality</code> parameter must be a constant integer, and its temporal locality value ranges from <code>0</code> (no locality) to <code>3</code> (extremely local, keep in cache).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="prefetch_write_instruction"><span><a class="doc-id-link" href="#prefetch_write_instruction">prefetch_write_instruction<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">prefetch_write_instruction :: <span class="keyword-type">proc</span>(address: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, <span class="directive">#const</span> locality: <a href="/base/builtin#i32"><span class="doc-builtin">i32</span></a> <span class="comment">/* 0..=3 */</span>) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>The <code>prefetch_*</code> intrinsic are a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no affect on the behaviour of the program but can change its performance characteristics.</p>
<p>The <code>locality</code> parameter must be a constant integer, and its temporal locality value ranges from <code>0</code> (no locality) to <code>3</code> (extremely local, keep in cache).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="prefetch_write_data"><span><a class="doc-id-link" href="#prefetch_write_data">prefetch_write_data<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">prefetch_write_data :: <span class="keyword-type">proc</span>(address: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, <span class="directive">#const</span> locality: <a href="/base/builtin#i32"><span class="doc-builtin">i32</span></a> <span class="comment">/* 0..=3 */</span>) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>The <code>prefetch_*</code> intrinsic are a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no affect on the behaviour of the program but can change its performance characteristics.</p>
<p>The <code>locality</code> parameter must be a constant integer, and its temporal locality value ranges from <code>0</code> (no locality) to <code>3</code> (extremely local, keep in cache).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="expect"><span><a class="doc-id-link" href="#expect">expect<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">expect :: <span class="keyword-type">proc</span>(val, expected_val: T) -> T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Provides information about expected (the most probable) value of <code>val</code>, which can be used by optimizing backends.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="syscall"><span><a class="doc-id-link" href="#syscall">syscall<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">syscall :: <span class="keyword-type">proc</span>(id: <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>, args: ..<a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>) -> <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>system call for Linux and Darwin Only</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="syscall_bsd"><span><a class="doc-id-link" href="#syscall_bsd">syscall_bsd<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">syscall_bsd :: <span class="keyword-type">proc</span>(id: <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>, args: ..<a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>) -> (<a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>, <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>system call FreeBSD, NetBSD, etc.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_type_is_lock_free"><span><a class="doc-id-link" href="#atomic_type_is_lock_free">atomic_type_is_lock_free<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_type_is_lock_free :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_thread_fence"><span><a class="doc-id-link" href="#atomic_thread_fence">atomic_thread_fence<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_thread_fence :: <span class="keyword-type">proc</span>(order: <a href="/base/intrinsics#Atomic_Memory_Order"><span class="code-typename">Atomic_Memory_Order</span></a>) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Adds a "fence" to introduce a "happens-before" edges between operations.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_signal_fence"><span><a class="doc-id-link" href="#atomic_signal_fence">atomic_signal_fence<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_signal_fence :: <span class="keyword-type">proc</span>(order: <a href="/base/intrinsics#Atomic_Memory_Order"><span class="code-typename">Atomic_Memory_Order</span></a>) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Adds a "fence" to introduce a "happens-before" edges between operations.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="atomic_store"><span><a class="doc-id-link" href="#atomic_store">atomic_store<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_store :: <span class="keyword-type">proc</span>(dst: ^$T, val: T) {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_store_explicit"><span><a class="doc-id-link" href="#atomic_store_explicit">atomic_store_explicit<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_store_explicit :: <span class="keyword-type">proc</span>(dst: ^$T, val: T, order: <a href="/base/intrinsics#Atomic_Memory_Order"><span class="code-typename">Atomic_Memory_Order</span></a>) {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_load"><span><a class="doc-id-link" href="#atomic_load">atomic_load<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_load :: <span class="keyword-type">proc</span>(dst: ^$T) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_load_explicit"><span><a class="doc-id-link" href="#atomic_load_explicit">atomic_load_explicit<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_load_explicit :: <span class="keyword-type">proc</span>(dst: ^$T, order: <a href="/base/intrinsics#Atomic_Memory_Order"><span class="code-typename">Atomic_Memory_Order</span></a>) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_add"><span><a class="doc-id-link" href="#atomic_add">atomic_add<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_add :: <span class="keyword-type">proc</span>(dst: ^$T, val: T) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_add_explicit"><span><a class="doc-id-link" href="#atomic_add_explicit">atomic_add_explicit<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_add_explicit :: <span class="keyword-type">proc</span>(dst: ^$T, val: T, order: <a href="/base/intrinsics#Atomic_Memory_Order"><span class="code-typename">Atomic_Memory_Order</span></a>) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_sub"><span><a class="doc-id-link" href="#atomic_sub">atomic_sub<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_sub :: <span class="keyword-type">proc</span>(dst: ^$T, val: T) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_sub_explicit"><span><a class="doc-id-link" href="#atomic_sub_explicit">atomic_sub_explicit<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_sub_explicit :: <span class="keyword-type">proc</span>(dst: ^$T, val: T, order: <a href="/base/intrinsics#Atomic_Memory_Order"><span class="code-typename">Atomic_Memory_Order</span></a>) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_and"><span><a class="doc-id-link" href="#atomic_and">atomic_and<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_and :: <span class="keyword-type">proc</span>(dst: ^$T, val: T) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_and_explicit"><span><a class="doc-id-link" href="#atomic_and_explicit">atomic_and_explicit<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_and_explicit :: <span class="keyword-type">proc</span>(dst: ^$T, val: T, order: <a href="/base/intrinsics#Atomic_Memory_Order"><span class="code-typename">Atomic_Memory_Order</span></a>) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_nand"><span><a class="doc-id-link" href="#atomic_nand">atomic_nand<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_nand :: <span class="keyword-type">proc</span>(dst: ^$T, val: T) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_nand_explicit"><span><a class="doc-id-link" href="#atomic_nand_explicit">atomic_nand_explicit<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_nand_explicit :: <span class="keyword-type">proc</span>(dst: ^$T, val: T, order: <a href="/base/intrinsics#Atomic_Memory_Order"><span class="code-typename">Atomic_Memory_Order</span></a>) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_or"><span><a class="doc-id-link" href="#atomic_or">atomic_or<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_or :: <span class="keyword-type">proc</span>(dst: ^$T, val: T) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_or_explicit"><span><a class="doc-id-link" href="#atomic_or_explicit">atomic_or_explicit<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_or_explicit :: <span class="keyword-type">proc</span>(dst: ^$T, val: T, order: <a href="/base/intrinsics#Atomic_Memory_Order"><span class="code-typename">Atomic_Memory_Order</span></a>) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_xor"><span><a class="doc-id-link" href="#atomic_xor">atomic_xor<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_xor :: <span class="keyword-type">proc</span>(dst: ^$T, val: T) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_xor_explicit"><span><a class="doc-id-link" href="#atomic_xor_explicit">atomic_xor_explicit<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_xor_explicit :: <span class="keyword-type">proc</span>(dst: ^$T, val: T, order: <a href="/base/intrinsics#Atomic_Memory_Order"><span class="code-typename">Atomic_Memory_Order</span></a>) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_exchange"><span><a class="doc-id-link" href="#atomic_exchange">atomic_exchange<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_exchange :: <span class="keyword-type">proc</span>(dst: ^$T, val: T) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_exchange_explicit"><span><a class="doc-id-link" href="#atomic_exchange_explicit">atomic_exchange_explicit<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_exchange_explicit :: <span class="keyword-type">proc</span>(dst: ^$T, val: T, order: <a href="/base/intrinsics#Atomic_Memory_Order"><span class="code-typename">Atomic_Memory_Order</span></a>) -> T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_compare_exchange_strong"><span><a class="doc-id-link" href="#atomic_compare_exchange_strong">atomic_compare_exchange_strong<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_compare_exchange_strong :: <span class="keyword-type">proc</span>(dst: ^$T, old, new: T) -> (T, <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) <span class="directive">#optional_ok</span> {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_compare_exchange_strong_explicit"><span><a class="doc-id-link" href="#atomic_compare_exchange_strong_explicit">atomic_compare_exchange_strong_explicit<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_compare_exchange_strong_explicit :: <span class="keyword-type">proc</span>(dst: ^$T, old, new: T, success, failure: <a href="/base/intrinsics#Atomic_Memory_Order"><span class="code-typename">Atomic_Memory_Order</span></a>) -> (T, <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) <span class="directive">#optional_ok</span> {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_compare_exchange_weak"><span><a class="doc-id-link" href="#atomic_compare_exchange_weak">atomic_compare_exchange_weak<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_compare_exchange_weak :: <span class="keyword-type">proc</span>(dst: ^$T, old, new: T) -> (T, <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) <span class="directive">#optional_ok</span> {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="atomic_compare_exchange_weak_explicit"><span><a class="doc-id-link" href="#atomic_compare_exchange_weak_explicit">atomic_compare_exchange_weak_explicit<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">atomic_compare_exchange_weak_explicit :: <span class="keyword-type">proc</span>(dst: ^$T, old, new: T, success, failure: <a href="/base/intrinsics#Atomic_Memory_Order"><span class="code-typename">Atomic_Memory_Order</span></a>) -> (T, <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>) <span class="directive">#optional_ok</span> {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="type_base_type"><span><a class="doc-id-link" href="#type_base_type">type_base_type<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_base_type :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> type {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the type without any <code>distinct</code> indirection e.g. <code>Foo :: distinct int</code>, <code>type_base_type(Foo) == int</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_core_type"><span><a class="doc-id-link" href="#type_core_type">type_core_type<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_core_type :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> type {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the type without any <code>distinct</code> indirection and the underlying integer type for an enum or bit_set e.g. <code>Foo :: distinct int</code>, <code>type_core_type(Foo) == int</code>, or <code>Bar :: enum u8 {A}</code>, <code>type_core_type(Bar) == u8</code>, or <code>Baz :: bit_set[Bar; u32]</code>, <code>type_core_type(Baz) == u32</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_elem_type"><span><a class="doc-id-link" href="#type_elem_type">type_elem_type<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_elem_type :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> type {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the element type of an compound type.</p>
<p><span class="doc-list">Complex number: the underlying float type (e.g. <code>complex64 -&gt; f32</code>)</span>
<span class="doc-list">Quaternion: the underlying float type (e.g. <code>quaternion256 -&gt; f64</code>)</span>
<span class="doc-list">Pointer: the base type (e.g. <code>^T -&gt; T</code>)</span>
<span class="doc-list">Array: the element type (e.g. <code>[N]T -&gt; T</code>)</span>
<span class="doc-list">Enumerated Array: the element type (e.g. <code>[Enum]T -&gt; T</code>)</span>
<span class="doc-list">Slice: the element type (e.g. <code>[]T -&gt; T</code>)</span>
<span class="doc-list">Dynamic Array: the element type (e.g. <code>[dynamic]T -&gt; T</code>)</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_boolean"><span><a class="doc-id-link" href="#type_is_boolean">type_is_boolean<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_boolean :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Return true if the type is derived from any boolean type: <code>bool</code>, <code>b8</code>, <code>b16</code>, <code>b32</code>, <code>b64</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_integer"><span><a class="doc-id-link" href="#type_is_integer">type_is_integer<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_integer :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Return true if the type is derived from any integer type</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_rune"><span><a class="doc-id-link" href="#type_is_rune">type_is_rune<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_rune :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Return true if the type is derived from the <code>rune</code> type</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_float"><span><a class="doc-id-link" href="#type_is_float">type_is_float<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_float :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Return true if the type is derived from any float type</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_complex"><span><a class="doc-id-link" href="#type_is_complex">type_is_complex<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_complex :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Return true if the type is derived from any complex type: <code>complex32</code>, <code>complex64</code>, <code>complex128</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_quaternion"><span><a class="doc-id-link" href="#type_is_quaternion">type_is_quaternion<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_quaternion :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Return true if the type is derived from any quaternion type: <code>quaternion64</code>, <code>quaternion128</code>, <code>quaternion256</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_typeid"><span><a class="doc-id-link" href="#type_is_typeid">type_is_typeid<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_typeid :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Return true if the type is derived from <code>typeid</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_any"><span><a class="doc-id-link" href="#type_is_any">type_is_any<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_any :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Return true if the type is derived from <code>any</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_string"><span><a class="doc-id-link" href="#type_is_string">type_is_string<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_string :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the type is derived from any string type: <code>string</code>, <code>cstring</code>, <code>string16</code>, <code>cstring16</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_string16"><span><a class="doc-id-link" href="#type_is_string16">type_is_string16<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_string16 :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the type is derived from the <code>string16</code> type AND not <code>cstring16</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_cstring"><span><a class="doc-id-link" href="#type_is_cstring">type_is_cstring<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_cstring :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the type is derived from the <code>cstring</code> type</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_cstring16"><span><a class="doc-id-link" href="#type_is_cstring16">type_is_cstring16<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_cstring16 :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the type is derived from the <code>cstring16</code> type</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_endian_platform"><span><a class="doc-id-link" href="#type_is_endian_platform">type_is_endian_platform<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_endian_platform :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the type uses the platform native layout rather than a specific layout. Example: <code>type_is_endian_platform(u32) == true</code>, <code>type_is_endian_platform(u32le) == false</code>, <code>type_is_endian_platform(u32be) == false</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_endian_little"><span><a class="doc-id-link" href="#type_is_endian_little">type_is_endian_little<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_endian_little :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the type is little endian specific or it is a platform native layout which is also little endian. Example: <code>type_is_endian_little(u32le) == true</code>, <code>type_is_endian_little(u32be) == false</code>, <code>type_is_endian_little(u32) == (ODIN_ENDIAN == .Little)</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_endian_big"><span><a class="doc-id-link" href="#type_is_endian_big">type_is_endian_big<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_endian_big :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the type is big endian specific or it is a platform native layout which is also big endian. Example: <code>type_is_endian_big(u32be) == true</code>, <code>type_is_endian_big(u32le) == false</code>, <code>type_is_endian_big(u32) == (ODIN_ENDIAN == .Big)</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_unsigned"><span><a class="doc-id-link" href="#type_is_unsigned">type_is_unsigned<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_unsigned :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the type is an unsigned integer or an enum backed by an unsigned integer, and false otherwise for any other type</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_numeric"><span><a class="doc-id-link" href="#type_is_numeric">type_is_numeric<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_numeric :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if it is a "numeric" type in nature:</p>
<p><span class="doc-list">Any integer</span>
<span class="doc-list">Any float</span>
<span class="doc-list">Any complex number</span>
<span class="doc-list">Any quaternion</span>
<span class="doc-list">Any enum</span>
<span class="doc-list">Any fixed-length array of a numeric type</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_ordered"><span><a class="doc-id-link" href="#type_is_ordered">type_is_ordered<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_ordered :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the type is an integer, float, rune, any string, pointer, or multi-pointer</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_ordered_numeric"><span><a class="doc-id-link" href="#type_is_ordered_numeric">type_is_ordered_numeric<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_ordered_numeric :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the type is an integer, float, or rune</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_indexable"><span><a class="doc-id-link" href="#type_is_indexable">type_is_indexable<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_indexable :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if a value of this type can indexed:</p>
<p><span class="doc-list"><code>string</code> or <code>string16</code></span>
<span class="doc-list">Any fixed-length array</span>
<span class="doc-list">Any slice</span>
<span class="doc-list">Any dynamic array</span>
<span class="doc-list">Any map</span>
<span class="doc-list">Any multi-pointer</span>
<span class="doc-list">Any enumerated array</span>
<span class="doc-list">Any matrix</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_sliceable"><span><a class="doc-id-link" href="#type_is_sliceable">type_is_sliceable<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_sliceable :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if a value of this type can indexed:</p>
<p><span class="doc-list"><code>string</code> or <code>string16</code></span>
<span class="doc-list">Any fixed-length array</span>
<span class="doc-list">Any slice</span>
<span class="doc-list">Any dynamic array</span>
<span class="doc-list">Any multi-pointer</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_comparable"><span><a class="doc-id-link" href="#type_is_comparable">type_is_comparable<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_comparable :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the type is comparable, which allows for the use of <code>==</code> and <code>!=</code> binary operators.</p>
<p>One of the following non-compound types (as well as any <code>distinct</code> forms): <code>rune</code>, <code>string</code>, <code>cstring</code>, <code>string16</code>, <code>cstring16</code>, <code>typeid</code>, pointer, <code>#soa</code> related pointer, multi-pointer, enum, procedure, matrix, <code>bit_set</code>, <code>#simd</code> vector.</p>
<p>One of the following compound types (as well as any <code>distinct</code> forms): any array or enumerated array where its element type is also comparable; any <code>struct</code> where all of its fields are comparable; any <code>struct #raw_union</code> were all of its fields are simply comparable (see <code>type_is_simple_compare</code>); any <code>union</code> where all of its variants are comparable.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_simple_compare"><span><a class="doc-id-link" href="#type_is_simple_compare">type_is_simple_compare<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_simple_compare :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>easily compared using memcmp (<code>==</code> and <code>!=</code>) (not including floats)</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_nearly_simple_compare"><span><a class="doc-id-link" href="#type_is_nearly_simple_compare">type_is_nearly_simple_compare<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_nearly_simple_compare :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>easily compared using memcmp (<code>==</code> and <code>!=</code>) (including floats)</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_dereferenceable"><span><a class="doc-id-link" href="#type_is_dereferenceable">type_is_dereferenceable<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_dereferenceable :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Must be a pointer type <code>^T</code> (not <code>rawptr</code>) or an <code>#soa</code> related pointer type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_valid_map_key"><span><a class="doc-id-link" href="#type_is_valid_map_key">type_is_valid_map_key<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_valid_map_key :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Any comparable type which is not-untyped nor generic.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_valid_matrix_elements"><span><a class="doc-id-link" href="#type_is_valid_matrix_elements">type_is_valid_matrix_elements<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_valid_matrix_elements :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Any integer, float, or complex number type (not-untyped).</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_named"><span><a class="doc-id-link" href="#type_is_named">type_is_named<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_named :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the type is a named</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_pointer"><span><a class="doc-id-link" href="#type_is_pointer">type_is_pointer<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_pointer :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the base-type is a pointer, i.e. <code>^T</code> or <code>rawptr</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_multi_pointer"><span><a class="doc-id-link" href="#type_is_multi_pointer">type_is_multi_pointer<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_multi_pointer :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the base-type is a multi pointer, i.e. <code>[^]T</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_array"><span><a class="doc-id-link" href="#type_is_array">type_is_array<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_array :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the base-type is a fixed-length array, i.e. <code>[N]T</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_enumerated_array"><span><a class="doc-id-link" href="#type_is_enumerated_array">type_is_enumerated_array<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_enumerated_array :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the base-type is a enumerated array, i.e. <code>[Some_Enum]T</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_slice"><span><a class="doc-id-link" href="#type_is_slice">type_is_slice<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_slice :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the base-type is a slice, i.e. <code>[]T</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_dynamic_array"><span><a class="doc-id-link" href="#type_is_dynamic_array">type_is_dynamic_array<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_dynamic_array :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the base-type is a dynamic array, i.e. <code>[dynamic]T</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_map"><span><a class="doc-id-link" href="#type_is_map">type_is_map<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_map :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the base-type is a <code>map</code>, i.e. <code>map[K]V</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_struct"><span><a class="doc-id-link" href="#type_is_struct">type_is_struct<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_struct :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the base-type is a <code>struct</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_union"><span><a class="doc-id-link" href="#type_is_union">type_is_union<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_union :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the base-type is a <code>union</code>, but not <code>struct #raw_union</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_enum"><span><a class="doc-id-link" href="#type_is_enum">type_is_enum<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_enum :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the base-type is a <code>enum</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_proc"><span><a class="doc-id-link" href="#type_is_proc">type_is_proc<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_proc :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the base-type is a <code>proc</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_bit_set"><span><a class="doc-id-link" href="#type_is_bit_set">type_is_bit_set<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_bit_set :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the base-type is a <code>bit_set</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_simd_vector"><span><a class="doc-id-link" href="#type_is_simd_vector">type_is_simd_vector<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_simd_vector :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the base-type is a simd vector, i.e. <code>#simd[N]T</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_matrix"><span><a class="doc-id-link" href="#type_is_matrix">type_is_matrix<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_matrix :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the base-type is a <code>matrix</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_raw_union"><span><a class="doc-id-link" href="#type_is_raw_union">type_is_raw_union<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_raw_union :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the base-type is a <code>struct #raw_union</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_has_nil"><span><a class="doc-id-link" href="#type_has_nil">type_has_nil<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_has_nil :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Types that support <code>nil</code>:</p>
<p><span class="doc-list"><code>rawptr</code></span>
<span class="doc-list"><code>any</code></span>
<span class="doc-list"><code>cstring</code></span>
<span class="doc-list"><code>cstring16</code></span>
<span class="doc-list"><code>typeid</code></span>
<span class="doc-list"><code>enum</code></span>
<span class="doc-list"><code>bit_set</code></span>
<span class="doc-list">Slices</span>
<span class="doc-list"><code>proc</code> values</span>
<span class="doc-list">Pointers</span>
<span class="doc-list">#soa Pointers</span>
<span class="doc-list">Multi-Pointers</span>
<span class="doc-list">Dynamic Arrays</span>
<span class="doc-list"><code>map</code></span>
<span class="doc-list"><code>union</code> without the <code>#no_nil</code> directive</span>
<span class="doc-list"><code>#soa</code> slices</span>
<span class="doc-list"><code>#soa</code> dynamic arrays</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_matrix_row_major"><span><a class="doc-id-link" href="#type_is_matrix_row_major">type_is_matrix_row_major<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_matrix_row_major :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_matrix"><span class="code-procedure">type_is_matrix</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the type passed is a matrix using <code>#row_major</code> ordering, this intrinsic only allows for matrices and will not compile otherwise. Note: The default matrix layout is <code>#column_major</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_matrix_column_major"><span><a class="doc-id-link" href="#type_is_matrix_column_major">type_is_matrix_column_major<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_matrix_column_major :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_matrix"><span class="code-procedure">type_is_matrix</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the type passed is a matrix using <code>#column_major</code> ordering, this intrinsic only allows for matrices and will not compile otherwise. Note: The default matrix layout is <code>#column_major</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_specialization_of"><span><a class="doc-id-link" href="#type_is_specialization_of">type_is_specialization_of<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_specialization_of :: <span class="keyword-type">proc</span>($T, $S: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the type passed is a specialization of a parametric polymorphic type.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">Foo :: struct($T: typeid) {x: T}
assert(type_is_specialization_of(Foo(int)) == true)
assert(type_is_specialization_of(Foo)      == false)
assert(type_is_specialization_of(i32)      == false)
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_variant_of"><span><a class="doc-id-link" href="#type_is_variant_of">type_is_variant_of<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_variant_of :: <span class="keyword-type">proc</span>($U, $V: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_union"><span class="code-procedure">type_is_union</span></a>(U) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the <code>V</code> is a variant of the union type <code>U</code>.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">Foo:: union {i32, f32}
assert(type_is_variant_of(Foo, i32)    == true)
assert(type_is_variant_of(Foo, f32)    == true)
assert(type_is_variant_of(Foo, string) == false)
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_union_tag_type"><span><a class="doc-id-link" href="#type_union_tag_type">type_union_tag_type<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_union_tag_type :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <span class="keyword-type">typeid</span> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_union"><span class="code-procedure">type_is_union</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the type used to store the tag for a union. If no tag is used (e.g. <code>Maybe(Pointer_Like_Type)</code>), then <code>u8</code> is returned.</p>
<p>Possible tag types: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_union_tag_offset"><span><a class="doc-id-link" href="#type_union_tag_offset">type_union_tag_offset<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_union_tag_offset :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_union"><span class="code-procedure">type_is_union</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the offset to the tag in bytes from the start of the union. If no tag is used (e.g. 'Maybe(Pointer_Like_Type)`), then size of the variant block space is returned.</p>
<p>Note: unions store the tag after the variant block space.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_union_base_tag_value"><span><a class="doc-id-link" href="#type_union_base_tag_value">type_union_base_tag_value<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_union_base_tag_value :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_union"><span class="code-procedure">type_is_union</span></a>(U) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the first valid tag value for the first variant. If <code>#no_nil</code> is used, the returned value will be <code>0</code>, otherwise <code>1</code> will be returned.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">assert(type_union_base_tag_value(union {i32, f32})         == 1)
assert(type_union_base_tag_value(union #no_nil {i32, f32}) == 0)
assert(type_union_base_tag_value(Maybe(rawptr})            == 1)
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_union_variant_count"><span><a class="doc-id-link" href="#type_union_variant_count">type_union_variant_count<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_union_variant_count :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_union"><span class="code-procedure">type_is_union</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the number of possible variants a union can be (excluding a possible <code>nil</code> state).</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">assert(type_union_variant_count(union {i32, f32})      == 2)
assert(type_union_variant_count(union {i32, f32, b32}) == 3)
assert(type_union_variant_count(union {})              == 0)
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_variant_type_of"><span><a class="doc-id-link" href="#type_variant_type_of">type_variant_type_of<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_variant_type_of :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>, $index: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <span class="keyword-type">typeid</span> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_union"><span class="code-procedure">type_is_union</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the type of a union <code>T</code>'s variant at a specified <code>index</code>.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">Foo :: union{i32, f32, string}
assert(type_variant_type_of(Foo, 0) == i32)
assert(type_variant_type_of(Foo, 1) == f32)
assert(type_variant_type_of(Foo, 2) == string)
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_variant_index_of"><span><a class="doc-id-link" href="#type_variant_index_of">type_variant_index_of<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_variant_index_of :: <span class="keyword-type">proc</span>($U, $V: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_union"><span class="code-procedure">type_is_union</span></a>(U) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the index of a variant <code>V</code> of a union <code>U</code>.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">Foo :: union{i32, f32, string}
assert(type_variant_type_of(Foo, i32)    == 0)
assert(type_variant_type_of(Foo, f32)    == 1)
assert(type_variant_type_of(Foo, string) == 2)
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_bit_set_elem_type"><span><a class="doc-id-link" href="#type_bit_set_elem_type">type_bit_set_elem_type<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_bit_set_elem_type :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <span class="keyword-type">typeid</span> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_bit_set"><span class="code-procedure">type_is_bit_set</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the element type of a <code>bit_set</code> <code>T</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_bit_set_underlying_type"><span><a class="doc-id-link" href="#type_bit_set_underlying_type">type_bit_set_underlying_type<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_bit_set_underlying_type :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <span class="keyword-type">typeid</span> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_bit_set"><span class="code-procedure">type_is_bit_set</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the underlying/backing type of a <code>bit_set</code> <code>T</code> rather than the element type.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">assert(type_bit_set_underlying_type(bit_set[0..&lt;8])     == u8)
assert(type_bit_set_underlying_type(bit_set[Enum; int]) == int)
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_has_field"><span><a class="doc-id-link" href="#type_has_field">type_has_field<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_has_field :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>, $name: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the field <code>name</code> exists on the type <code>T</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_field_type"><span><a class="doc-id-link" href="#type_field_type">type_field_type<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_field_type :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>, $name: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> <span class="keyword-type">typeid</span> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns type of the field <code>name</code> on the type <code>T</code>. Note: the field must exist otherwise this will not compile.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_proc_parameter_count"><span><a class="doc-id-link" href="#type_proc_parameter_count">type_proc_parameter_count<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_proc_parameter_count :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_proc"><span class="code-procedure">type_is_proc</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the number of parameters a procedure type has.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">assert(type_proc_parameter_count(proc(i32, f32) -&gt; bool) == 2)
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_proc_return_count"><span><a class="doc-id-link" href="#type_proc_return_count">type_proc_return_count<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_proc_return_count :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_proc"><span class="code-procedure">type_is_proc</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the number of return values a procedure type has.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">assert(type_proc_return_count(proc(i32, f32) -&gt; bool) == 1)
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_proc_parameter_type"><span><a class="doc-id-link" href="#type_proc_parameter_type">type_proc_parameter_type<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_proc_parameter_type :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>, index: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <span class="keyword-type">typeid</span> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_proc"><span class="code-procedure">type_is_proc</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the type of a parameter of a procedure type at the specified <code>index</code>.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">assert(type_proc_parameter_type(proc(i32, f32) -&gt; bool, 1) == f32)
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_proc_return_type"><span><a class="doc-id-link" href="#type_proc_return_type">type_proc_return_type<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_proc_return_type :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>, index: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <span class="keyword-type">typeid</span> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_proc"><span class="code-procedure">type_is_proc</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the type of a return value of a procedure type at the specified <code>index</code>.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">assert(type_proc_return_type(proc(i32, f32) -&gt; bool, 0) == bool)
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_struct_field_count"><span><a class="doc-id-link" href="#type_struct_field_count">type_struct_field_count<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_struct_field_count :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_struct"><span class="code-procedure">type_is_struct</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the number of fields in a <code>struct</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_struct_has_implicit_padding"><span><a class="doc-id-link" href="#type_struct_has_implicit_padding">type_struct_has_implicit_padding<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_struct_has_implicit_padding :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_struct"><span class="code-procedure">type_is_struct</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns whether the struct has any implicit padding to ensure correct alignment for the fields.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">Foo :: struct {x: u8, y: u32}
assert(type_struct_has_implicit_padding(Foo) == true)
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_polymorphic_record_parameter_count"><span><a class="doc-id-link" href="#type_polymorphic_record_parameter_count">type_polymorphic_record_parameter_count<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_polymorphic_record_parameter_count :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <span class="keyword-type">typeid</span> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the number of parametric polymorphic parameters to a parametric polymorphic record type (<code>struct</code> or <code>union</code>). Fails if the type is not such a type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_polymorphic_record_parameter_value"><span><a class="doc-id-link" href="#type_polymorphic_record_parameter_value">type_polymorphic_record_parameter_value<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_polymorphic_record_parameter_value :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>, index: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> $V {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the value of a specifialized parametric polymorphic record type (<code>struct</code> or <code>union</code>) at a specified <code>index</code>. Fails if the type is not such a type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_specialized_polymorphic_record"><span><a class="doc-id-link" href="#type_is_specialized_polymorphic_record">type_is_specialized_polymorphic_record<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_specialized_polymorphic_record :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the record type (<code>struct</code> or <code>union</code>) passed is a specialized polymorphic record. Returns false when the type is not polymorphic in the first place.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_unspecialized_polymorphic_record"><span><a class="doc-id-link" href="#type_is_unspecialized_polymorphic_record">type_is_unspecialized_polymorphic_record<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_unspecialized_polymorphic_record :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if the record type (<code>struct</code> or <code>union</code>) passed is a unspecialized polymorphic record. Returns false when the type is not polymorphic in the first place.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_is_subtype_of"><span><a class="doc-id-link" href="#type_is_subtype_of">type_is_subtype_of<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_is_subtype_of :: <span class="keyword-type">proc</span>($T, $U: <span class="keyword-type">typeid</span>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns true if <code>T</code> is a subtype (i.e. <code>using</code> was applied on a field) to type <code>U</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_field_index_of"><span><a class="doc-id-link" href="#type_field_index_of">type_field_index_of<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_field_index_of :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>, $name: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a> {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="type_equal_proc"><span><a class="doc-id-link" href="#type_equal_proc">type_equal_proc<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_equal_proc :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> (equal:  <span class="keyword-type">proc</span> "contextless" (<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a>)                 <span class="keyword">where</span> <a href="/base/intrinsics#type_is_comparable"><span class="code-procedure">type_is_comparable</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the underlying procedure that is used to compare pointers to two values of the same type together. This is used by the <code>map</code> type and general complicated comparisons.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_hasher_proc"><span><a class="doc-id-link" href="#type_hasher_proc">type_hasher_proc<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_hasher_proc :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> (hasher: <span class="keyword-type">proc</span> "contextless" (data: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, seed: <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>) -> <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>) <span class="keyword">where</span> <a href="/base/intrinsics#type_is_comparable"><span class="code-procedure">type_is_comparable</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the underlying procedure that is used to hash a pointer to a value used by the <code>map</code> type.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_map_info"><span><a class="doc-id-link" href="#type_map_info">type_map_info<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_map_info :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>/<span class="keyword-type">map</span>[$K]$V) -> ^runtime.<a href="/base/runtime#Map_Info"><span class="code-typename">Map_Info</span></a> {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="type_map_cell_info"><span><a class="doc-id-link" href="#type_map_cell_info">type_map_cell_info<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_map_cell_info :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> ^runtime.<a href="/base/runtime#Map_Cell_Info"><span class="code-typename">Map_Cell_Info</span></a> {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="type_convert_variants_to_pointers"><span><a class="doc-id-link" href="#type_convert_variants_to_pointers">type_convert_variants_to_pointers<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_convert_variants_to_pointers :: <span class="keyword-type">proc</span>($T: <span class="keyword-type">typeid</span>) -> <span class="keyword-type">typeid</span> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_union"><span class="code-procedure">type_is_union</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns a type which converts all of the variants of a <code>union</code> to be pointer types of those variants.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">Foo :: union {A, B, C}
type_convert_variants_to_pointers(Foo) == union {^A, ^B, ^C}
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="type_merge"><span><a class="doc-id-link" href="#type_merge">type_merge<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">type_merge :: <span class="keyword-type">proc</span>($U, $V: <span class="keyword-type">typeid</span>) -> <span class="keyword-type">typeid</span> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_union"><span class="code-procedure">type_is_union</span></a>(U), <a href="/base/intrinsics#type_is_union"><span class="code-procedure">type_is_union</span></a>(V) {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="constant_utf16_cstring"><span><a class="doc-id-link" href="#constant_utf16_cstring">constant_utf16_cstring<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">constant_utf16_cstring :: <span class="keyword-type">proc</span>($literal: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> [^]<a href="/base/builtin#u16"><span class="doc-builtin">u16</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns a runtime value of a constant string UTF-8 value encoded as a UTF-16 NULL terminated string value, useful for interfacing with UTF-16 procedure such as the Windows API.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="constant_log2"><span><a class="doc-id-link" href="#constant_log2">constant_log2<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">constant_log2 :: <span class="keyword-type">proc</span>($v: $T) -> T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the log2 value of the given constant integer.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_add"><span><a class="doc-id-link" href="#simd_add">simd_add<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_add :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_sub"><span><a class="doc-id-link" href="#simd_sub">simd_sub<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_sub :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_mul"><span><a class="doc-id-link" href="#simd_mul">simd_mul<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_mul :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_div"><span><a class="doc-id-link" href="#simd_div">simd_div<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_div :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_float"><span class="code-procedure">type_is_float</span></a>(T) {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_saturating_add"><span><a class="doc-id-link" href="#simd_saturating_add">simd_saturating_add<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_saturating_add :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_saturating_sub"><span><a class="doc-id-link" href="#simd_saturating_sub">simd_saturating_sub<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_saturating_sub :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_shl"><span><a class="doc-id-link" href="#simd_shl">simd_shl<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_shl :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T, b: <span class="directive">#simd</span>[N]Unsigned_Integer) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Keeps Odin's behaviour: <code>(x &lt;&lt; y) if y &lt;= mask else 0</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_shr"><span><a class="doc-id-link" href="#simd_shr">simd_shr<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_shr :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T, b: <span class="directive">#simd</span>[N]Unsigned_Integer) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Keeps Odin's behaviour: `(x &gt;&gt; y) if y &lt;= mask else 0</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_shl_masked"><span><a class="doc-id-link" href="#simd_shl_masked">simd_shl_masked<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_shl_masked :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T, b: <span class="directive">#simd</span>[N]Unsigned_Integer) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Similar to C's behaviour: <code>x &lt;&lt; (y & mask)</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_shr_masked"><span><a class="doc-id-link" href="#simd_shr_masked">simd_shr_masked<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_shr_masked :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T, b: <span class="directive">#simd</span>[N]Unsigned_Integer) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Similar to C's behaviour: `x &gt;&gt; (y & mask)</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_bit_and"><span><a class="doc-id-link" href="#simd_bit_and">simd_bit_and<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_bit_and :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_bit_or"><span><a class="doc-id-link" href="#simd_bit_or">simd_bit_or<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_bit_or :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_bit_xor"><span><a class="doc-id-link" href="#simd_bit_xor">simd_bit_xor<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_bit_xor :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_bit_and_not"><span><a class="doc-id-link" href="#simd_bit_and_not">simd_bit_and_not<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_bit_and_not :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_neg"><span><a class="doc-id-link" href="#simd_neg">simd_neg<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_neg :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_abs"><span><a class="doc-id-link" href="#simd_abs">simd_abs<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_abs :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_min"><span><a class="doc-id-link" href="#simd_min">simd_min<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_min :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_max"><span><a class="doc-id-link" href="#simd_max">simd_max<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_max :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_clamp"><span><a class="doc-id-link" href="#simd_clamp">simd_clamp<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_clamp :: <span class="keyword-type">proc</span>(v, min, max: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_lanes_eq"><span><a class="doc-id-link" href="#simd_lanes_eq">simd_lanes_eq<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_lanes_eq :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]Integer {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Return an unsigned integer of the same size as the input type, NOT A BOOLEAN. element-wise: <code>false =&gt; 0x00...00</code>, <code>true =&gt; 0xff...ff</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_lanes_ne"><span><a class="doc-id-link" href="#simd_lanes_ne">simd_lanes_ne<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_lanes_ne :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]Integer {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Return an unsigned integer of the same size as the input type, NOT A BOOLEAN. element-wise: <code>false =&gt; 0x00...00</code>, <code>true =&gt; 0xff...ff</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_lanes_lt"><span><a class="doc-id-link" href="#simd_lanes_lt">simd_lanes_lt<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_lanes_lt :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]Integer {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Return an unsigned integer of the same size as the input type, NOT A BOOLEAN. element-wise: <code>false =&gt; 0x00...00</code>, <code>true =&gt; 0xff...ff</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_lanes_le"><span><a class="doc-id-link" href="#simd_lanes_le">simd_lanes_le<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_lanes_le :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]Integer {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Return an unsigned integer of the same size as the input type, NOT A BOOLEAN. element-wise: <code>false =&gt; 0x00...00</code>, <code>true =&gt; 0xff...ff</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_lanes_gt"><span><a class="doc-id-link" href="#simd_lanes_gt">simd_lanes_gt<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_lanes_gt :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]Integer {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Return an unsigned integer of the same size as the input type, NOT A BOOLEAN. element-wise: <code>false =&gt; 0x00...00</code>, <code>true =&gt; 0xff...ff</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_lanes_ge"><span><a class="doc-id-link" href="#simd_lanes_ge">simd_lanes_ge<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_lanes_ge :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]Integer {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Return an unsigned integer of the same size as the input type, NOT A BOOLEAN. element-wise: <code>false =&gt; 0x00...00</code>, <code>true =&gt; 0xff...ff</code></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_extract"><span><a class="doc-id-link" href="#simd_extract">simd_extract<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_extract :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T, idx: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>) -> T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Extracts a single scalar element from a <code>#simd</code> vector at a specified index.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_replace"><span><a class="doc-id-link" href="#simd_replace">simd_replace<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_replace :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T, idx: <a href="/base/builtin#uint"><span class="doc-builtin">uint</span></a>, elem: T) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Replaces a single scalar element from a <code>#simd</code> vector and returns a new vector.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_reduce_add_ordered"><span><a class="doc-id-link" href="#simd_reduce_add_ordered">simd_reduce_add_ordered<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_reduce_add_ordered :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T) -> T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Performs a reduction of a <code>#simd</code> vector <code>a</code>, returning the result as a scalar. The return type matches the element-type <code>T</code> of the <code>#simd</code> vector input. See the following pseudocode:</p>
<pre>simd_reduce_add_ordered :: proc(v: #simd[N]T) -&gt; T {
	result := simd_extract(v, 0)
	for i in 1..&lt;N {
		e := simd_extract(v, i)
		result = result + e
	}
	return result
}
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_reduce_mul_ordered"><span><a class="doc-id-link" href="#simd_reduce_mul_ordered">simd_reduce_mul_ordered<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_reduce_mul_ordered :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T) -> T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Performs a reduction of a <code>#simd</code> vector <code>a</code>, returning the result as a scalar. The return type matches the element-type <code>T</code> of the <code>#simd</code> vector input. See the following pseudocode:</p>
<pre>simd_reduce_mul_ordered :: proc(v: #simd[N]T) -&gt; T {
	result := simd_extract(v, 0)
	for i in 1..&lt;N {
		e := simd_extract(v, i)
		result = result * e
	}
	return result
}
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_reduce_min"><span><a class="doc-id-link" href="#simd_reduce_min">simd_reduce_min<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_reduce_min :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T) -> T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Performs a reduction of a <code>#simd</code> vector <code>a</code>, returning the result as a scalar. The return type matches the element-type <code>T</code> of the <code>#simd</code> vector input. See the following pseudocode:</p>
<pre>simd_reduce_min :: proc(v: #simd[N]T) -&gt; T {
	result := simd_extract(v, 0)
	for i in 1..&lt;N {
		e := simd_extract(v, i)
		result = min(result, e)
	}
	return result
}
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_reduce_max"><span><a class="doc-id-link" href="#simd_reduce_max">simd_reduce_max<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_reduce_max :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T) -> T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Performs a reduction of a <code>#simd</code> vector <code>a</code>, returning the result as a scalar. The return type matches the element-type <code>T</code> of the <code>#simd</code> vector input. See the following pseudocode:</p>
<pre>simd_reduce_max :: proc(v: #simd[N]T) -&gt; T {
	result := simd_extract(v, 0)
	for i in 1..&lt;N {
		e := simd_extract(v, i)
		result = max(result, e)
	}
	return result
}
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_reduce_and"><span><a class="doc-id-link" href="#simd_reduce_and">simd_reduce_and<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_reduce_and :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T) -> T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Performs a reduction of a <code>#simd</code> vector <code>a</code>, returning the result as a scalar. The return type matches the element-type <code>T</code> of the <code>#simd</code> vector input. See the following pseudocode:</p>
<pre>simd_reduce_and :: proc(v: #simd[N]T) -&gt; T {
	result := simd_extract(v, 0)
	for i in 1..&lt;N {
		e := simd_extract(v, i)
		result = result & e
	}
	return result
}
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_reduce_or"><span><a class="doc-id-link" href="#simd_reduce_or">simd_reduce_or<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_reduce_or :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T) -> T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Performs a reduction of a <code>#simd</code> vector <code>a</code>, returning the result as a scalar. The return type matches the element-type <code>T</code> of the <code>#simd</code> vector input. See the following pseudocode:</p>
<pre>simd_reduce_or :: proc(v: #simd[N]T) -&gt; T {
	result := simd_extract(v, 0)
	for i in 1..&lt;N {
		e := simd_extract(v, i)
		result = result | e
	}
	return result
}
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_reduce_xor"><span><a class="doc-id-link" href="#simd_reduce_xor">simd_reduce_xor<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_reduce_xor :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T) -> T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Performs a reduction of a <code>#simd</code> vector <code>a</code>, returning the result as a scalar. The return type matches the element-type <code>T</code> of the <code>#simd</code> vector input. See the following pseudocode:</p>
<pre>simd_reduce_xor :: proc(v: #simd[N]T) -&gt; T {
	result := simd_extract(v, 0)
	for i in 1..&lt;N {
		e := simd_extract(v, i)
		result = result ~ e
	}
	return result
}
</pre>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_reduce_any"><span><a class="doc-id-link" href="#simd_reduce_any">simd_reduce_any<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_reduce_any :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T) -> T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_boolean"><span class="code-procedure">type_is_boolean</span></a>(T) {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_reduce_all"><span><a class="doc-id-link" href="#simd_reduce_all">simd_reduce_all<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_reduce_all :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T) -> T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_boolean"><span class="code-procedure">type_is_boolean</span></a>(T) {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_extract_msbs"><span><a class="doc-id-link" href="#simd_extract_msbs">simd_extract_msbs<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_extract_msbs :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T) -> bit_set[0..<N] <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) || <a href="/base/intrinsics#type_is_boolean"><span class="code-procedure">type_is_boolean</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Extracts the most significant bit of each element of the given vector into a <code>bit_set</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_extract_lsbs"><span><a class="doc-id-link" href="#simd_extract_lsbs">simd_extract_lsbs<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_extract_lsbs :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T) -> bit_set[0..<N] <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(T) || <a href="/base/intrinsics#type_is_boolean"><span class="code-procedure">type_is_boolean</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Extracts the least significant bit of each element of the given vector into a <code>bit_set</code>.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_gather"><span><a class="doc-id-link" href="#simd_gather">simd_gather<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_gather :: <span class="keyword-type">proc</span>(ptr: <span class="directive">#simd</span>[N]<a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, val: <span class="directive">#simd</span>[N]T, mask: <span class="directive">#simd</span>[N]U) -> <span class="directive">#simd</span>[N]T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(U) || <a href="/base/intrinsics#type_is_boolean"><span class="code-procedure">type_is_boolean</span></a>(U) {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_scatter"><span><a class="doc-id-link" href="#simd_scatter">simd_scatter<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_scatter :: <span class="keyword-type">proc</span>(ptr: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, val: <span class="directive">#simd</span>[N]T, mask: <span class="directive">#simd</span>[N]U) <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(U) || <a href="/base/intrinsics#type_is_boolean"><span class="code-procedure">type_is_boolean</span></a>(U) {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_masked_load"><span><a class="doc-id-link" href="#simd_masked_load">simd_masked_load<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_masked_load :: <span class="keyword-type">proc</span>(ptr: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, val: <span class="directive">#simd</span>[N]T, mask: <span class="directive">#simd</span>[N]U) -> <span class="directive">#simd</span>[N]T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(U) || <a href="/base/intrinsics#type_is_boolean"><span class="code-procedure">type_is_boolean</span></a>(U) {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_masked_store"><span><a class="doc-id-link" href="#simd_masked_store">simd_masked_store<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_masked_store :: <span class="keyword-type">proc</span>(ptr: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, val: <span class="directive">#simd</span>[N]T, mask: <span class="directive">#simd</span>[N]U) <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(U) || <a href="/base/intrinsics#type_is_boolean"><span class="code-procedure">type_is_boolean</span></a>(U) {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_masked_expand_load"><span><a class="doc-id-link" href="#simd_masked_expand_load">simd_masked_expand_load<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_masked_expand_load :: <span class="keyword-type">proc</span>(ptr: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, val: <span class="directive">#simd</span>[N]T, mask: <span class="directive">#simd</span>[N]U) -> <span class="directive">#simd</span>[N]T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(U) || <a href="/base/intrinsics#type_is_boolean"><span class="code-procedure">type_is_boolean</span></a>(U) {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_masked_compress_store"><span><a class="doc-id-link" href="#simd_masked_compress_store">simd_masked_compress_store<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_masked_compress_store :: <span class="keyword-type">proc</span>(ptr: <a href="/base/builtin#rawptr"><span class="doc-builtin">rawptr</span></a>, val: <span class="directive">#simd</span>[N]T, mask: <span class="directive">#simd</span>[N]U) <span class="keyword">where</span> <a href="/base/intrinsics#type_is_integer"><span class="code-procedure">type_is_integer</span></a>(U) || <a href="/base/intrinsics#type_is_boolean"><span class="code-procedure">type_is_boolean</span></a>(U) {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_shuffle"><span><a class="doc-id-link" href="#simd_shuffle">simd_shuffle<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_shuffle :: <span class="keyword-type">proc</span>(a, b: <span class="directive">#simd</span>[N]T, $indices: ..<a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <span class="directive">#simd</span>[len(indices)]T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>The first two operators of <code>simd_shuffle</code> are <code>#simd</code> vectors of the same type. The indices following these represent the shuffle mask values. The mask elements must be constant integers. The result of the procedure is a vector whose length is the same as the number of indices passed to the procedure type.</p>
<p>The elements of the two input <code>#simd</code> vectors are numbers from left to right across both of the vectors. For each element of the result <code>#simd</code> vector, the shuffle indices selement an element from one of the two input vectors to copy to the result.</p>
<details open class="code-example">
<summary><b>Example:</b></summary>
<pre><code class="hljs language-odin" data-lang="odin">a, b: #simd[4]T = ...
x: #simd[4]T = intrinsics.simd_shuffle(a, b, 0, 1, 2, 3) // identity shuffle of `a`
y: #simd[4]T = intrinsics.simd_shuffle(a, b, 4, 5, 6, 7) // identity shuffle of `b`
z: #simd[4]T = intrinsics.simd_shuffle(a, b, 0, 4, 1, 5)
w: #simd[8]T = intrinsics.simd_shuffle(a, b, 0, 1, 2, 3, 4, 5, 6, 7)
v: #simd[6]T = intrinsics.simd_shuffle(a, b, 0, 1, 0, 3, 0, 4) // repeated indices and different sized vector
</code></pre>
</details>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_select"><span><a class="doc-id-link" href="#simd_select">simd_select<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_select :: <span class="keyword-type">proc</span>(cond: <span class="directive">#simd</span>[N]boolean_or_integer, true, false: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_ceil"><span><a class="doc-id-link" href="#simd_ceil">simd_ceil<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_ceil :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]any_float) -> <span class="directive">#simd</span>[N]any_float {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>lane-wise ceil</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_floor"><span><a class="doc-id-link" href="#simd_floor">simd_floor<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_floor :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]any_float) -> <span class="directive">#simd</span>[N]any_float {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>lane-wise floor</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_trunc"><span><a class="doc-id-link" href="#simd_trunc">simd_trunc<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_trunc :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]any_float) -> <span class="directive">#simd</span>[N]any_float {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>lane-wise trunc</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_nearest"><span><a class="doc-id-link" href="#simd_nearest">simd_nearest<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_nearest :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]any_float) -> <span class="directive">#simd</span>[N]any_float {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>rounding to the nearest integral value; if two values are equally near, rounds to the even one</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_to_bits"><span><a class="doc-id-link" href="#simd_to_bits">simd_to_bits<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_to_bits :: <span class="keyword-type">proc</span>(v: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]Integer <span class="keyword">where</span> size_of(T) == size_of(Integer), <a href="/base/intrinsics#type_is_unsigned"><span class="code-procedure">type_is_unsigned</span></a>(Integer) {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_lanes_reverse"><span><a class="doc-id-link" href="#simd_lanes_reverse">simd_lanes_reverse<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_lanes_reverse :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>equivalent a swizzle with descending indices, e.g. reserve(a, 3, 2, 1, 0)</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="simd_lanes_rotate_left"><span><a class="doc-id-link" href="#simd_lanes_rotate_left">simd_lanes_rotate_left<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_lanes_rotate_left :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T, $offset: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="simd_lanes_rotate_right"><span><a class="doc-id-link" href="#simd_lanes_rotate_right">simd_lanes_rotate_right<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">simd_lanes_rotate_right :: <span class="keyword-type">proc</span>(a: <span class="directive">#simd</span>[N]T, $offset: <a href="/base/builtin#int"><span class="doc-builtin">int</span></a>) -> <span class="directive">#simd</span>[N]T {â€¦}</pre>
</div>
</div>
<div class="pkg-entity">
<h3 id="has_target_feature"><span><a class="doc-id-link" href="#has_target_feature">has_target_feature<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">has_target_feature :: <span class="keyword-type">proc</span>($test: $T) -> <a href="/base/builtin#bool"><span class="doc-builtin">bool</span></a> <span class="keyword">where</span> <a href="/base/intrinsics#type_is_string"><span class="code-procedure">type_is_string</span></a>(T) || <a href="/base/intrinsics#type_is_proc"><span class="code-procedure">type_is_proc</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Checks if the current target supports the given target features.</p>
<p>Takes a constant comma-separated string (eg: "sha512,sse4.1"), or a procedure type which has either <code>@(require_target_feature)</code> or <code>@(enable_target_feature)</code> as its input and returns a boolean indicating if all listed features are supported.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="procedure_of"><span><a class="doc-id-link" href="#procedure_of">procedure_of<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">procedure_of :: <span class="keyword-type">proc</span>(x: $T) -> T <span class="keyword">where</span> <a href="/base/intrinsics#type_is_proc"><span class="code-procedure">type_is_proc</span></a>(T) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Returns the value of the procedure where <code>x</code> must be a call expression.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="wasm_memory_grow"><span><a class="doc-id-link" href="#wasm_memory_grow">wasm_memory_grow<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">wasm_memory_grow :: <span class="keyword-type">proc</span>(index, delta: <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>) -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>WASM targets only</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="wasm_memory_size"><span><a class="doc-id-link" href="#wasm_memory_size">wasm_memory_size<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">wasm_memory_size :: <span class="keyword-type">proc</span>(index: <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>) -> <a href="/base/builtin#int"><span class="doc-builtin">int</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>WASM targets only</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="wasm_memory_atomic_wait32"><span><a class="doc-id-link" href="#wasm_memory_atomic_wait32">wasm_memory_atomic_wait32<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">wasm_memory_atomic_wait32 :: <span class="keyword-type">proc</span>(ptr: ^<a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a>, expected: <a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a>, timeout_ns: <a href="/base/builtin#i64"><span class="doc-builtin">i64</span></a>) -> <a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Blocks the calling thread for a given duration if the value pointed to by <code>ptr</code> is equal to the value of <code>expected</code>.
<code>timeout_ns</code> is the maximum number of nanoseconds the calling thread will be blocked for.  If <code>timeout_ns</code> is negative, the calling thread will be blocked forever.
Returns:
<span class="doc-list"><code>0</code>: the thread blocked and then was woken up</span>
<span class="doc-list"><code>1</code>: the loaded value from <code>ptr</code> did not match <code>expected</code>, the thread did not block</span>
<span class="doc-list"><code>2</code>: the thread blocked, but the timeout expired</span></p>
</details>
</div>
<div class="pkg-entity">
<h3 id="wasm_memory_atomic_notify32"><span><a class="doc-id-link" href="#wasm_memory_atomic_notify32">wasm_memory_atomic_notify32<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">wasm_memory_atomic_notify32 :: <span class="keyword-type">proc</span>(ptr: ^<a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a>, waiters: <a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a>) -> (waiters_woken_up: <a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a>) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Wakes threads waiting on the address indicated by <code>ptr</code>, up to the given maximum (<code>waiters</code>). If <code>waiters</code> is zero, no threads are woken up. Threads previously blocked with <code>wasm_memory_atomic_wait32</code> will be woken up.
Returns:
The number of threads woken up.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="x86_cpuid"><span><a class="doc-id-link" href="#x86_cpuid">x86_cpuid<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">x86_cpuid :: <span class="keyword-type">proc</span>(ax, cx: <a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a>) -> (eax, ebx, ecx, edx: <a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a>) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>x86 Targets Only (i386, amd64)
Implements the <code>cpuid</code> instruction.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="x86_xgetbv"><span><a class="doc-id-link" href="#x86_xgetbv">x86_xgetbv<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">x86_xgetbv :: <span class="keyword-type">proc</span>(cx: <a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a>) -> (eax, edx: <a href="/base/builtin#u32"><span class="doc-builtin">u32</span></a>) {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>x86 Targets Only (i386, amd64)
Implements in <code>xgetbv</code> instruction.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="objc_find_selector"><span><a class="doc-id-link" href="#objc_find_selector">objc_find_selector<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">objc_find_selector :: <span class="keyword-type">proc</span>($name: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> <a href="/base/intrinsics#objc_SEL"><span class="code-typename">objc_SEL</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Darwin targets only
Will return a run-time cached selector value for the given constant string value.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="objc_register_selector"><span><a class="doc-id-link" href="#objc_register_selector">objc_register_selector<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">objc_register_selector :: <span class="keyword-type">proc</span>($name: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> <a href="/base/intrinsics#objc_SEL"><span class="code-typename">objc_SEL</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Darwin targets only
Will register a selector value at run-time for the given constant string value.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="objc_find_class"><span><a class="doc-id-link" href="#objc_find_class">objc_find_class<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">objc_find_class :: <span class="keyword-type">proc</span>($name: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> <a href="/base/intrinsics#objc_Class"><span class="code-typename">objc_Class</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Darwin targets only
Will return a run-time cached class value for the given constant string value.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="objc_register_class"><span><a class="doc-id-link" href="#objc_register_class">objc_register_class<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">objc_register_class :: <span class="keyword-type">proc</span>($name: <a href="/base/builtin#string"><span class="doc-builtin">string</span></a>) -> <a href="/base/intrinsics#objc_Class"><span class="code-typename">objc_Class</span></a> {â€¦}</pre>
</div>
<details class="odin-doc-toggle" open>
<summary class="hideme"><span>&nbsp;</span></summary>
<p>Darwin targets only
Will register a class value at run-time for the given constant string value.</p>
</details>
</div>
<div class="pkg-entity">
<h3 id="valgrind_client_request"><span><a class="doc-id-link" href="#valgrind_client_request">valgrind_client_request<span class="a-hidden">&nbsp;Â¶</span></a></span></h3>
<div>
<pre class="doc-code">valgrind_client_request :: <span class="keyword-type">proc</span>(default: <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>, request: <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>, a0, a1, a2, a3, a4: <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a>) -> <a href="/base/builtin#uintptr"><span class="doc-builtin">uintptr</span></a> {â€¦}</pre>
</div>
</div>
<h2 id="pkg-Procedure Groups" class="pkg-header">Procedure Groups</h2>
<script type="text/javascript">var odin_pkg_name = "intrinsics";</script>
</section></article>
<div class="col-lg-2 odin-toc-border navbar-light"><div class="sticky-top odin-below-navbar py-3">
<nav id="TableOfContents">
<ul>
<li><a href="#pkg-overview">Overview</a></li>
<li>
<a href="#pkg-Constants">Constants</a><ul>
</ul>
</li>
<li>
<a href="#pkg-Types">Types</a><ul>
<li><a href="#Atomic_Memory_Order">Atomic_Memory_Order</a></li>
<li><a href="#objc_object">objc_object</a></li>
<li><a href="#objc_selector">objc_selector</a></li>
<li><a href="#objc_class">objc_class</a></li>
<li><a href="#objc_id">objc_id</a></li>
<li><a href="#objc_SEL">objc_SEL</a></li>
<li><a href="#objc_Class">objc_Class</a></li>
</ul>
</li>
<li>
<a href="#pkg-Procedures">Procedures</a><ul>
<li><a href="#transpose">transpose</a></li>
<li><a href="#outer_product">outer_product</a></li>
<li><a href="#hadamard_product">hadamard_product</a></li>
<li><a href="#matrix_flatten">matrix_flatten</a></li>
<li><a href="#soa_struct">soa_struct</a></li>
<li><a href="#volatile_load">volatile_load</a></li>
<li><a href="#volatile_store">volatile_store</a></li>
<li><a href="#non_temporal_load">non_temporal_load</a></li>
<li><a href="#non_temporal_store">non_temporal_store</a></li>
<li><a href="#debug_trap">debug_trap</a></li>
<li><a href="#trap">trap</a></li>
<li><a href="#alloca">alloca</a></li>
<li><a href="#cpu_relax">cpu_relax</a></li>
<li><a href="#read_cycle_counter">read_cycle_counter</a></li>
<li><a href="#read_cycle_counter_frequency">read_cycle_counter_frequency</a></li>
<li><a href="#count_ones">count_ones</a></li>
<li><a href="#count_zeros">count_zeros</a></li>
<li><a href="#count_trailing_zeros">count_trailing_zeros</a></li>
<li><a href="#count_leading_zeros">count_leading_zeros</a></li>
<li><a href="#reverse_bits">reverse_bits</a></li>
<li><a href="#byte_swap">byte_swap</a></li>
<li><a href="#overflow_add">overflow_add</a></li>
<li><a href="#overflow_sub">overflow_sub</a></li>
<li><a href="#overflow_mul">overflow_mul</a></li>
<li><a href="#saturating_add">saturating_add</a></li>
<li><a href="#saturating_sub">saturating_sub</a></li>
<li><a href="#sqrt">sqrt</a></li>
<li><a href="#fused_mul_add">fused_mul_add</a></li>
<li><a href="#mem_copy">mem_copy</a></li>
<li><a href="#mem_copy_non_overlapping">mem_copy_non_overlapping</a></li>
<li><a href="#mem_zero">mem_zero</a></li>
<li><a href="#mem_zero_volatile">mem_zero_volatile</a></li>
<li><a href="#ptr_offset">ptr_offset</a></li>
<li><a href="#ptr_sub">ptr_sub</a></li>
<li><a href="#unaligned_load">unaligned_load</a></li>
<li><a href="#unaligned_store">unaligned_store</a></li>
<li><a href="#fixed_point_mul">fixed_point_mul</a></li>
<li><a href="#fixed_point_div">fixed_point_div</a></li>
<li><a href="#fixed_point_mul_sat">fixed_point_mul_sat</a></li>
<li><a href="#fixed_point_div_sat">fixed_point_div_sat</a></li>
<li><a href="#prefetch_read_instruction">prefetch_read_instruction</a></li>
<li><a href="#prefetch_read_data">prefetch_read_data</a></li>
<li><a href="#prefetch_write_instruction">prefetch_write_instruction</a></li>
<li><a href="#prefetch_write_data">prefetch_write_data</a></li>
<li><a href="#expect">expect</a></li>
<li><a href="#syscall">syscall</a></li>
<li><a href="#syscall_bsd">syscall_bsd</a></li>
<li><a href="#atomic_type_is_lock_free">atomic_type_is_lock_free</a></li>
<li><a href="#atomic_thread_fence">atomic_thread_fence</a></li>
<li><a href="#atomic_signal_fence">atomic_signal_fence</a></li>
<li><a href="#atomic_store">atomic_store</a></li>
<li><a href="#atomic_store_explicit">atomic_store_explicit</a></li>
<li><a href="#atomic_load">atomic_load</a></li>
<li><a href="#atomic_load_explicit">atomic_load_explicit</a></li>
<li><a href="#atomic_add">atomic_add</a></li>
<li><a href="#atomic_add_explicit">atomic_add_explicit</a></li>
<li><a href="#atomic_sub">atomic_sub</a></li>
<li><a href="#atomic_sub_explicit">atomic_sub_explicit</a></li>
<li><a href="#atomic_and">atomic_and</a></li>
<li><a href="#atomic_and_explicit">atomic_and_explicit</a></li>
<li><a href="#atomic_nand">atomic_nand</a></li>
<li><a href="#atomic_nand_explicit">atomic_nand_explicit</a></li>
<li><a href="#atomic_or">atomic_or</a></li>
<li><a href="#atomic_or_explicit">atomic_or_explicit</a></li>
<li><a href="#atomic_xor">atomic_xor</a></li>
<li><a href="#atomic_xor_explicit">atomic_xor_explicit</a></li>
<li><a href="#atomic_exchange">atomic_exchange</a></li>
<li><a href="#atomic_exchange_explicit">atomic_exchange_explicit</a></li>
<li><a href="#atomic_compare_exchange_strong">atomic_compare_exchange_strong</a></li>
<li><a href="#atomic_compare_exchange_strong_explicit">atomic_compare_exchange_strong_explicit</a></li>
<li><a href="#atomic_compare_exchange_weak">atomic_compare_exchange_weak</a></li>
<li><a href="#atomic_compare_exchange_weak_explicit">atomic_compare_exchange_weak_explicit</a></li>
<li><a href="#type_base_type">type_base_type</a></li>
<li><a href="#type_core_type">type_core_type</a></li>
<li><a href="#type_elem_type">type_elem_type</a></li>
<li><a href="#type_is_boolean">type_is_boolean</a></li>
<li><a href="#type_is_integer">type_is_integer</a></li>
<li><a href="#type_is_rune">type_is_rune</a></li>
<li><a href="#type_is_float">type_is_float</a></li>
<li><a href="#type_is_complex">type_is_complex</a></li>
<li><a href="#type_is_quaternion">type_is_quaternion</a></li>
<li><a href="#type_is_typeid">type_is_typeid</a></li>
<li><a href="#type_is_any">type_is_any</a></li>
<li><a href="#type_is_string">type_is_string</a></li>
<li><a href="#type_is_string16">type_is_string16</a></li>
<li><a href="#type_is_cstring">type_is_cstring</a></li>
<li><a href="#type_is_cstring16">type_is_cstring16</a></li>
<li><a href="#type_is_endian_platform">type_is_endian_platform</a></li>
<li><a href="#type_is_endian_little">type_is_endian_little</a></li>
<li><a href="#type_is_endian_big">type_is_endian_big</a></li>
<li><a href="#type_is_unsigned">type_is_unsigned</a></li>
<li><a href="#type_is_numeric">type_is_numeric</a></li>
<li><a href="#type_is_ordered">type_is_ordered</a></li>
<li><a href="#type_is_ordered_numeric">type_is_ordered_numeric</a></li>
<li><a href="#type_is_indexable">type_is_indexable</a></li>
<li><a href="#type_is_sliceable">type_is_sliceable</a></li>
<li><a href="#type_is_comparable">type_is_comparable</a></li>
<li><a href="#type_is_simple_compare">type_is_simple_compare</a></li>
<li><a href="#type_is_nearly_simple_compare">type_is_nearly_simple_compare</a></li>
<li><a href="#type_is_dereferenceable">type_is_dereferenceable</a></li>
<li><a href="#type_is_valid_map_key">type_is_valid_map_key</a></li>
<li><a href="#type_is_valid_matrix_elements">type_is_valid_matrix_elements</a></li>
<li><a href="#type_is_named">type_is_named</a></li>
<li><a href="#type_is_pointer">type_is_pointer</a></li>
<li><a href="#type_is_multi_pointer">type_is_multi_pointer</a></li>
<li><a href="#type_is_array">type_is_array</a></li>
<li><a href="#type_is_enumerated_array">type_is_enumerated_array</a></li>
<li><a href="#type_is_slice">type_is_slice</a></li>
<li><a href="#type_is_dynamic_array">type_is_dynamic_array</a></li>
<li><a href="#type_is_map">type_is_map</a></li>
<li><a href="#type_is_struct">type_is_struct</a></li>
<li><a href="#type_is_union">type_is_union</a></li>
<li><a href="#type_is_enum">type_is_enum</a></li>
<li><a href="#type_is_proc">type_is_proc</a></li>
<li><a href="#type_is_bit_set">type_is_bit_set</a></li>
<li><a href="#type_is_simd_vector">type_is_simd_vector</a></li>
<li><a href="#type_is_matrix">type_is_matrix</a></li>
<li><a href="#type_is_raw_union">type_is_raw_union</a></li>
<li><a href="#type_has_nil">type_has_nil</a></li>
<li><a href="#type_is_matrix_row_major">type_is_matrix_row_major</a></li>
<li><a href="#type_is_matrix_column_major">type_is_matrix_column_major</a></li>
<li><a href="#type_is_specialization_of">type_is_specialization_of</a></li>
<li><a href="#type_is_variant_of">type_is_variant_of</a></li>
<li><a href="#type_union_tag_type">type_union_tag_type</a></li>
<li><a href="#type_union_tag_offset">type_union_tag_offset</a></li>
<li><a href="#type_union_base_tag_value">type_union_base_tag_value</a></li>
<li><a href="#type_union_variant_count">type_union_variant_count</a></li>
<li><a href="#type_variant_type_of">type_variant_type_of</a></li>
<li><a href="#type_variant_index_of">type_variant_index_of</a></li>
<li><a href="#type_bit_set_elem_type">type_bit_set_elem_type</a></li>
<li><a href="#type_bit_set_underlying_type">type_bit_set_underlying_type</a></li>
<li><a href="#type_has_field">type_has_field</a></li>
<li><a href="#type_field_type">type_field_type</a></li>
<li><a href="#type_proc_parameter_count">type_proc_parameter_count</a></li>
<li><a href="#type_proc_return_count">type_proc_return_count</a></li>
<li><a href="#type_proc_parameter_type">type_proc_parameter_type</a></li>
<li><a href="#type_proc_return_type">type_proc_return_type</a></li>
<li><a href="#type_struct_field_count">type_struct_field_count</a></li>
<li><a href="#type_struct_has_implicit_padding">type_struct_has_implicit_padding</a></li>
<li><a href="#type_polymorphic_record_parameter_count">type_polymorphic_record_parameter_count</a></li>
<li><a href="#type_polymorphic_record_parameter_value">type_polymorphic_record_parameter_value</a></li>
<li><a href="#type_is_specialized_polymorphic_record">type_is_specialized_polymorphic_record</a></li>
<li><a href="#type_is_unspecialized_polymorphic_record">type_is_unspecialized_polymorphic_record</a></li>
<li><a href="#type_is_subtype_of">type_is_subtype_of</a></li>
<li><a href="#type_field_index_of">type_field_index_of</a></li>
<li><a href="#type_equal_proc">type_equal_proc</a></li>
<li><a href="#type_hasher_proc">type_hasher_proc</a></li>
<li><a href="#type_map_info">type_map_info</a></li>
<li><a href="#type_map_cell_info">type_map_cell_info</a></li>
<li><a href="#type_convert_variants_to_pointers">type_convert_variants_to_pointers</a></li>
<li><a href="#type_merge">type_merge</a></li>
<li><a href="#constant_utf16_cstring">constant_utf16_cstring</a></li>
<li><a href="#constant_log2">constant_log2</a></li>
<li><a href="#simd_add">simd_add</a></li>
<li><a href="#simd_sub">simd_sub</a></li>
<li><a href="#simd_mul">simd_mul</a></li>
<li><a href="#simd_div">simd_div</a></li>
<li><a href="#simd_saturating_add">simd_saturating_add</a></li>
<li><a href="#simd_saturating_sub">simd_saturating_sub</a></li>
<li><a href="#simd_shl">simd_shl</a></li>
<li><a href="#simd_shr">simd_shr</a></li>
<li><a href="#simd_shl_masked">simd_shl_masked</a></li>
<li><a href="#simd_shr_masked">simd_shr_masked</a></li>
<li><a href="#simd_bit_and">simd_bit_and</a></li>
<li><a href="#simd_bit_or">simd_bit_or</a></li>
<li><a href="#simd_bit_xor">simd_bit_xor</a></li>
<li><a href="#simd_bit_and_not">simd_bit_and_not</a></li>
<li><a href="#simd_neg">simd_neg</a></li>
<li><a href="#simd_abs">simd_abs</a></li>
<li><a href="#simd_min">simd_min</a></li>
<li><a href="#simd_max">simd_max</a></li>
<li><a href="#simd_clamp">simd_clamp</a></li>
<li><a href="#simd_lanes_eq">simd_lanes_eq</a></li>
<li><a href="#simd_lanes_ne">simd_lanes_ne</a></li>
<li><a href="#simd_lanes_lt">simd_lanes_lt</a></li>
<li><a href="#simd_lanes_le">simd_lanes_le</a></li>
<li><a href="#simd_lanes_gt">simd_lanes_gt</a></li>
<li><a href="#simd_lanes_ge">simd_lanes_ge</a></li>
<li><a href="#simd_extract">simd_extract</a></li>
<li><a href="#simd_replace">simd_replace</a></li>
<li><a href="#simd_reduce_add_ordered">simd_reduce_add_ordered</a></li>
<li><a href="#simd_reduce_mul_ordered">simd_reduce_mul_ordered</a></li>
<li><a href="#simd_reduce_min">simd_reduce_min</a></li>
<li><a href="#simd_reduce_max">simd_reduce_max</a></li>
<li><a href="#simd_reduce_and">simd_reduce_and</a></li>
<li><a href="#simd_reduce_or">simd_reduce_or</a></li>
<li><a href="#simd_reduce_xor">simd_reduce_xor</a></li>
<li><a href="#simd_reduce_any">simd_reduce_any</a></li>
<li><a href="#simd_reduce_all">simd_reduce_all</a></li>
<li><a href="#simd_extract_msbs">simd_extract_msbs</a></li>
<li><a href="#simd_extract_lsbs">simd_extract_lsbs</a></li>
<li><a href="#simd_gather">simd_gather</a></li>
<li><a href="#simd_scatter">simd_scatter</a></li>
<li><a href="#simd_masked_load">simd_masked_load</a></li>
<li><a href="#simd_masked_store">simd_masked_store</a></li>
<li><a href="#simd_masked_expand_load">simd_masked_expand_load</a></li>
<li><a href="#simd_masked_compress_store">simd_masked_compress_store</a></li>
<li><a href="#simd_shuffle">simd_shuffle</a></li>
<li><a href="#simd_select">simd_select</a></li>
<li><a href="#simd_ceil">simd_ceil</a></li>
<li><a href="#simd_floor">simd_floor</a></li>
<li><a href="#simd_trunc">simd_trunc</a></li>
<li><a href="#simd_nearest">simd_nearest</a></li>
<li><a href="#simd_to_bits">simd_to_bits</a></li>
<li><a href="#simd_lanes_reverse">simd_lanes_reverse</a></li>
<li><a href="#simd_lanes_rotate_left">simd_lanes_rotate_left</a></li>
<li><a href="#simd_lanes_rotate_right">simd_lanes_rotate_right</a></li>
<li><a href="#has_target_feature">has_target_feature</a></li>
<li><a href="#procedure_of">procedure_of</a></li>
<li><a href="#wasm_memory_grow">wasm_memory_grow</a></li>
<li><a href="#wasm_memory_size">wasm_memory_size</a></li>
<li><a href="#wasm_memory_atomic_wait32">wasm_memory_atomic_wait32</a></li>
<li><a href="#wasm_memory_atomic_notify32">wasm_memory_atomic_notify32</a></li>
<li><a href="#x86_cpuid">x86_cpuid</a></li>
<li><a href="#x86_xgetbv">x86_xgetbv</a></li>
<li><a href="#objc_find_selector">objc_find_selector</a></li>
<li><a href="#objc_register_selector">objc_register_selector</a></li>
<li><a href="#objc_find_class">objc_find_class</a></li>
<li><a href="#objc_register_class">objc_register_class</a></li>
<li><a href="#valgrind_client_request">valgrind_client_request</a></li>
</ul>
</li>
<li>
<a href="#pkg-Procedure Groups">Procedure Groups</a><ul>
</ul>
</li>
</ul>
</nav>
</div></div>
</div>

</div>
</main>

<footer class="odin-footer">
	<div class="container pb-5 pt-5">
		<div class="row g-4">
		<div class="col">
		<a class="navbar-brand" href="https://odin-lang.org">
		<img class="mb-3" src="https://odin-lang.org/logo.svg" height="30" alt="Odin"></a>
		<p>
		The Data-Oriented Language for Sane Software Development.
		</p>
		</div>
		<nav class="col-md-auto">
			<h4 class="fw-normal">Resources</h4>
			<ul class="list-unstyled">
			<li><a href="https://odin-lang.org/docs" class="link-light">Docs</a></li>
			<li><a href="https://pkg.odin-lang.org/" class="link-light">Packages</a></li>
			<li><a href="https://odin-lang.org/news" class="link-light">News</a></li>
			</ul>
		</nav>
		<nav class="col-md-auto">
			<h4 class="fw-normal">Community</h4>
			<ul class="list-unstyled">
			<li><a href="https://github.com/odin-lang/Odin" target="_blank" class="link-light">GitHub</a></li>
			<li><a href="https://forum.odin-lang.org" target="_blank" class="link-light">Forum</a></li>
			<li><a href="https://discord.com/invite/sVBPHEv" target="_blank" class="link-light">Discord</a></li>
			<li><a href="https://www.twitch.tv/ginger_bill" target="_blank" class="link-light">Twitch</a></li>
			<li><a href="https://www.youtube.com/channel/UCUSck1dOH7VKmG4lRW7tZXg" target="_blank" class="link-light">YouTube</a></li>
			<li><a href="https://odin-lang.org/showcase" target="_blank" class="link-light">Showcase</a></li>
			</ul>
		</nav>
		<nav class="col-md-auto">
			<h4 class="fw-normal">Contribute</h4>
			<ul class="list-unstyled">
			<li><a href="https://github.com/odin-lang/Odin/issues" target="_blank" class="link-light">Issues</a></li>
			<li><a href="https://www.patreon.com/gingerbill" target="_blank" class="link-light">Donate</a></li>
			</ul>
			</nav>
		</div>
		<div class="mt-4 text-muted">Â© 2016â€“2023 Ginger Bill</div>
	</div>
</footer>

<script src="https://odin-lang.org/lib/bootstrap/js/bootstrap.min.js"></script>
<script src="https://odin-lang.org/js/script.js"></script>
<script src="/pkg-data.js"></script>
<script src="/search.js"></script>
</body>
</html>
